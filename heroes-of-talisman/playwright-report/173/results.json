{
  "config": {
    "configFile": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/playwright.config.js",
    "rootDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
    "forbidOnly": false,
    "fullyParallel": true,
    "globalSetup": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-setup.js",
    "globalTeardown": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-teardown.js",
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
        "commitHash": "00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
        "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/33",
        "prTitle": "Add card_draw stage with metal_armor card",
        "prBaseHash": "6db5943692b40caef32caa8c6c7bf54848f4403e",
        "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21158449323"
      },
      "gitCommit": {
        "shortHash": "00a7473",
        "hash": "00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
        "subject": "Merge 0016712d60a0d9b60f0c0d66dd3175c6c509616c into 6db5943692b40caef32caa8c6c7bf54848f4403e",
        "body": "Merge 0016712d60a0d9b60f0c0d66dd3175c6c509616c into 6db5943692b40caef32caa8c6c7bf54848f4403e\n",
        "author": {
          "name": "mark kolodkin",
          "email": "mark.kolodkin@gmail.com",
          "time": 1768879768000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1768879768000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 2c1329f..1827087 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -6,6 +6,8 @@ from ..common import (\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\n@@ -22,6 +24,7 @@ from ..common import (\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n@@ -35,6 +38,8 @@ ACTION_MAP: Dict[str, type[Action]] = {\n     DISCONNECT: DisconnectAction,\n     CHARACTER_PRESS: CharacterPressAction,\n     CHARACTER_SELECT_ACTION: CharacterSelectAction,\n+    CARD_DRAW_ACTION: CardDrawAction,\n+    CARD_SELECT_ACTION: CardSelectAction,\n     ABILITY_PRESS: AbilityPressAction,\n     ABILITY_SELECT: AbilitySelectAction,\n     ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex 0d9861f..f9bc5a1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -46,17 +46,22 @@ class BattleEndAction(Action):\n         active_character = self.active_character\n         opponent_character = self.opponent_character\n \n-        # Calculate scores\n-        active_score = sum(self.game.active.dice_roll) + active_character.attack\n-        opponent_score = sum(self.game.opponent.dice_roll) + opponent_character.attack\n+        # Calculate scores (including effects)\n+        active_total_attack = active_character.attack + active_character.effect.attack_bonus + active_character.effect.attack_neg_bonus\n+        opponent_total_attack = opponent_character.attack + opponent_character.effect.attack_bonus + opponent_character.effect.attack_neg_bonus\n \n-        # Determine loser and reduce health\n+        active_score = sum(self.game.active.dice_roll) + active_total_attack\n+        opponent_score = sum(self.game.opponent.dice_roll) + opponent_total_attack\n+\n+        # Determine loser and reduce health (defense reduces incoming damage)\n         if active_score > opponent_score:\n             # Active player wins, opponent loses health\n-            opponent_character.health = max(0, opponent_character.health - 1)\n+            damage = max(0, 1 - opponent_character.effect.defense_bonus)\n+            opponent_character.health = max(0, opponent_character.health - damage)\n         elif opponent_score > active_score:\n             # Opponent wins, active player loses health\n-            active_character.health = max(0, active_character.health - 1)\n+            damage = max(0, 1 - active_character.effect.defense_bonus)\n+            active_character.health = max(0, active_character.health - damage)\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n@@ -84,6 +89,8 @@ class BattleEndAction(Action):\n         # Clear battle state and transition to next turn\n         self.game.active = ActivePlayer1(player=next_player_name)\n         self.game.opponent = None\n+        self.game.card = None\n+        self.game.ability = None\n         self.game.stage = CHARACTER_SELECT\n         self.game.stage_meta = None\n \ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nnew file mode 100644\nindex 0000000..a9e196c\n--- /dev/null\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -0,0 +1,113 @@\n+\"\"\"\n+Card Draw Stage Actions\n+\n+This module implements actions for the card draw stage:\n+- CardDrawAction: Automatically draws a random card and stores it in stage_meta\n+- CardSelectAction: Applies the drawn card's effects and transitions to ability_selection\n+\"\"\"\n+\n+import random\n+import copy\n+from .action import Action\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n+from ..cards import CardName, CARDS_MAP, CARDS_NAMES\n+from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n+\n+\n+class CardDrawAction(Action):\n+    \"\"\"\n+    Action invoked when entering the card draw stage.\n+\n+    Draws a random card from the available cards and stores it in stage_meta.\n+    This action should be called automatically when the stage starts.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Draw a random card\n+        drawn_card = random.choice(CARDS_NAMES)\n+\n+        # Store the drawn card in stage metadata\n+        self.game.stage_meta = CardDrawMeta(drawn_card=drawn_card)\n+\n+        return self.game\n+\n+\n+class CardSelectAction(Action):\n+    \"\"\"\n+    Action invoked when the player confirms to use the drawn card.\n+\n+    Applies the card's effects to the active player's character and transitions\n+    to the ability_selection stage.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Get the active character\n+        if not hasattr(self.game.active, \"character\"):\n+            raise GameException(\"No character selected\")\n+\n+        # Validate that a card was drawn\n+        if not self.game.stage_meta or not isinstance(self.game.stage_meta, CardDrawMeta):\n+            raise GameException(\"No card was drawn\")\n+\n+        player = self.game.players[self.user]\n+        character = player.characters[self.game.active.character]\n+\n+        # Get the drawn card\n+        drawn_card_name = self.game.stage_meta.drawn_card\n+        card_obj = CARDS_MAP.get(drawn_card_name)\n+\n+        if not card_obj:\n+            raise GameException(f\"Card {drawn_card_name} not found\")\n+\n+        # Store the selected card in GamePlay.card\n+        self.game.card = drawn_card_name\n+\n+        # Apply \"self\" effects to the active player's character\n+        for effect in card_obj.effects:\n+            if effect.apply_to == APPLY_TO_SELF:\n+                # Deep copy the effect to avoid modifying the original card definition\n+                effect_copy = copy.deepcopy(effect)\n+                character.effects.append(effect_copy)\n+\n+        # Add the card to the player's card list (for display purposes)\n+        player.cards.append(drawn_card_name)\n+\n+        # Clear stage_meta after selection\n+        self.game.stage_meta = None\n+\n+        # Transition to ability_selection stage\n+        self.game.stage = ABILITY_SELECTION\n+\n+        # Auto-select if character has only one ability\n+        if len(character.abilities) == 1:\n+            self.game.stage_meta = AbilitySelectMeta(\n+                selected=character.abilities[0].name\n+            )\n+\n+        return self.game\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 474748e..cd8ba75 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -3,7 +3,7 @@ Character Select Stage Actions\n \n This module implements actions for the character selection stage:\n - CharacterPressAction: Highlights selected character by setting stage_meta\n-- CharacterSelectAction: Confirms selection, disposes effects, and transitions to ability_selection\n+- CharacterSelectAction: Confirms selection, disposes effects, and transitions to card_draw\n \"\"\"\n \n from .action import Action\n@@ -13,10 +13,12 @@ from ..common import (\n     CHARACTER_SELECT_ACTION,\n )\n from ..gameplay import (\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n+    CardDrawMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n )\n@@ -63,7 +65,7 @@ class CharacterSelectAction(Action):\n     Action invoked when the Select button is pressed to confirm character choice.\n \n     Populates selected_character in game metadata, disposes effects with\n-    'character_select' in dispose_actions, and transitions the game stage to 'ability_selection'.\n+    'character_select' in dispose_actions, and transitions the game stage to 'card_draw'.\n     \"\"\"\n \n     @property\n@@ -98,16 +100,10 @@ class CharacterSelectAction(Action):\n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n-        # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n-\n-        # Auto-select if character has only one ability\n-        selected_character = player.characters[character]\n-        if len(selected_character.abilities) == 1:\n-            self.game.stage_meta = AbilitySelectMeta(\n-                selected=selected_character.abilities[0].name\n-            )\n-        else:\n-            self.game.stage_meta = None\n+        # Transition to card_draw stage\n+        self.game.stage = CARD_DRAW\n+\n+        # Clear stage_meta - will be populated by CardDrawAction\n+        self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex ff48b63..0195959 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -3,7 +3,7 @@ Opponent Selection Stage Actions\n \n This module implements actions for the opponent selection stage:\n - OpponentPressAction: Highlights selected opponent by setting stage_meta\n-- OpponentSelectAction: Confirms opponent selection and transitions to battle stage\n+- OpponentSelectAction: Confirms opponent selection, applies card and ability effects to opponent, and transitions to battle stage\n \"\"\"\n \n import copy\n@@ -100,7 +100,18 @@ class OpponentSelectAction(Action):\n         # Set opponent in game metadata\n         self.game.opponent = selected_opponent\n \n-        # Apply \"battle_opponent\" effects to the opponent's character\n+        # Apply \"battle_opponent\" effects from card to the opponent's character\n+        if self.game.card:\n+            from ..cards import CARDS_MAP\n+            card_obj = CARDS_MAP.get(self.game.card)\n+            if card_obj:\n+                for effect in card_obj.effects:\n+                    if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\n+                        # Deep copy the effect to avoid modifying the original card definition\n+                        effect_copy = copy.deepcopy(effect)\n+                        opponent_character.effects.append(effect_copy)\n+\n+        # Apply \"battle_opponent\" effects from ability to the opponent's character\n         if self.game.ability:\n             for effect in self.game.ability.effects:\n                 if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\ndiff --git a/server/gameplay/actions/test_stage_card_draw.py b/server/gameplay/actions/test_stage_card_draw.py\nnew file mode 100644\nindex 0000000..0c75197\n--- /dev/null\n+++ b/server/gameplay/actions/test_stage_card_draw.py\n@@ -0,0 +1,187 @@\n+\"\"\"\n+Tests for Card Draw Stage Actions.\n+\n+These tests verify card draw behavior including drawing a random card\n+and applying card effects to the character.\n+\"\"\"\n+\n+import pytest\n+\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n+from ..common import GameException, ReportedException, KNIGHT, MAGE\n+from ..cards import METAL_ARMOR, CARDS_MAP\n+from ..effects import DefenseBonusEffect\n+from ..gameplay import (\n+    CARD_DRAW,\n+    ABILITY_SELECTION,\n+    CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    ActivePlayer2,\n+    CardDrawMeta,\n+    init_characters,\n+)\n+\n+\n+def test_card_draw_action_valid():\n+    \"\"\"Test drawing a card stores it in stage_meta\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardDrawAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    assert updated_game.stage_meta is not None\n+    assert isinstance(updated_game.stage_meta, CardDrawMeta)\n+    assert updated_game.stage_meta.drawn_card in CARDS_MAP\n+    assert updated_game.stage == CARD_DRAW  # Still in card draw stage\n+\n+\n+def test_card_draw_action_not_active_player():\n+    \"\"\"Test drawing card when not active player raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\n+            \"player1\": Player(name=\"player1\", characters=characters),\n+            \"player2\": Player(name=\"player2\", characters=init_characters()),\n+        },\n+    )\n+\n+    action = CardDrawAction(\"player2\", game)\n+\n+    with pytest.raises(ReportedException, match=\"It's not your turn\"):\n+        action.run()\n+\n+\n+def test_card_draw_action_wrong_stage():\n+    \"\"\"Test drawing card in wrong stage raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardDrawAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n+        action.run()\n+\n+\n+def test_card_select_action_applies_effects():\n+    \"\"\"Test selecting a card applies its effects to the character\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    # Check game state\n+    assert updated_game.stage == ABILITY_SELECTION\n+    assert updated_game.card == METAL_ARMOR\n+    assert updated_game.stage_meta is not None  # Auto-selected ability\n+\n+    # Check character has defense effect\n+    player = updated_game.players[\"player1\"]\n+    knight = player.characters[KNIGHT]\n+    assert len(knight.effects) == 1\n+    assert isinstance(knight.effects[0], DefenseBonusEffect)\n+    assert knight.effects[0].defense_bonus == 2\n+    assert knight.effects[0].source == METAL_ARMOR\n+    assert knight.effects[0].dispose_actions == []  # Persistent effect\n+\n+    # Check card added to player's card list\n+    assert METAL_ARMOR in player.cards\n+\n+\n+def test_card_select_action_not_active_player():\n+    \"\"\"Test selecting card when not active player raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\n+            \"player1\": Player(name=\"player1\", characters=characters),\n+            \"player2\": Player(name=\"player2\", characters=init_characters()),\n+        },\n+    )\n+\n+    action = CardSelectAction(\"player2\", game)\n+\n+    with pytest.raises(ReportedException, match=\"It's not your turn\"):\n+        action.run()\n+\n+\n+def test_card_select_action_no_card_drawn():\n+    \"\"\"Test selecting card when no card was drawn raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"No card was drawn\"):\n+        action.run()\n+\n+\n+def test_card_select_action_wrong_stage():\n+    \"\"\"Test selecting card in wrong stage raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n+        action.run()\n+\n+\n+def test_metal_armor_defense_persists():\n+    \"\"\"Test metal_armor defense effect persists across battles using preset\"\"\"\n+    from ..presets import get_debug_preset, BATTLE_METAL_ARMOR\n+    from .battle_end import BattleEndAction\n+\n+    # Get preset with knight having metal_armor and losing battle\n+    game = get_debug_preset(BATTLE_METAL_ARMOR, player1_name=\"player1\", player2_name=\"player2\")\n+\n+    # Knight should have defense effect before battle ends\n+    player1 = game.players[\"player1\"]\n+    knight = player1.characters[KNIGHT]\n+    assert len(knight.effects) == 1\n+    assert isinstance(knight.effects[0], DefenseBonusEffect)\n+    assert knight.effects[0].defense_bonus == 2\n+\n+    # Knight's initial health\n+    knight_health_before = knight.health\n+\n+    # End battle (knight loses but has +2 defense)\n+    action = BattleEndAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    # Knight should take 0 damage (1 - 2 defense = 0)\n+    knight_after = updated_game.players[\"player1\"].characters[KNIGHT]\n+    assert knight_after.health == knight_health_before  # No damage taken\n+\n+    # Defense effect should still be present (persistent, not disposed)\n+    assert len(knight_after.effects) == 1\n+    assert isinstance(knight_after.effects[0], DefenseBonusEffect)\n+    assert knight_after.effects[0].defense_bonus == 2\ndiff --git a/server/gameplay/actions_names.py b/server/gameplay/actions_names.py\nindex 0d4eafc..9c48bba 100644\n--- a/server/gameplay/actions_names.py\n+++ b/server/gameplay/actions_names.py\n@@ -11,6 +11,8 @@ LEAVE = \"leave\"\n DISCONNECT = \"disconnect\"\n CHARACTER_PRESS = \"character_press\"\n CHARACTER_SELECT_ACTION = \"character_select\"\n+CARD_DRAW_ACTION = \"card_draw\"\n+CARD_SELECT_ACTION = \"card_select\"\n ABILITY_PRESS = \"ability_press\"\n ABILITY_SELECT = \"ability_select\"\n ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n@@ -30,6 +32,8 @@ ACTION_NAMES = [\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\ndiff --git a/server/gameplay/cards.py b/server/gameplay/cards.py\nnew file mode 100644\nindex 0000000..d37eeb0\n--- /dev/null\n+++ b/server/gameplay/cards.py\n@@ -0,0 +1,50 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_CARD_MAP\n+    DEFENSE_BONUS,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+)\n+\n+########################################################\n+# Card names - defined before imports from effects to avoid circular dependency\n+########################################################\n+METAL_ARMOR = \"metal_armor\"\n+CARDS_NAMES: list[str] = [METAL_ARMOR]\n+CardName = Literal[*CARDS_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which cards can create which effects\n+# This is used for validation to ensure effects have valid source cards\n+EFFECTS_SOURCE_CARD_MAP: dict[str, set[str]] = {\n+    DEFENSE_BONUS: {METAL_ARMOR},  # DefenseBonusEffect can come from METAL_ARMOR\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    DefenseBonusEffect,\n+)\n+\n+\n+class Card(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+\n+CARDS_MAP: dict[CardName, Card] = {\n+    METAL_ARMOR: Card(\n+        name=METAL_ARMOR,\n+        effects=[\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nindex 6eb879e..5a59b55 100644\n--- a/server/gameplay/effects.py\n+++ b/server/gameplay/effects.py\n@@ -18,6 +18,7 @@ from .actions_names import (\n ########################################################\n ATTACK_BONUS = \"attack_bonus\"\n ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+DEFENSE_BONUS = \"defense_bonus\"\n REROLL_DICE = \"reroll_dice\"\n SKIP_TURN = \"skip_turn\"\n DRAW_CARD = \"draw_card\"\n@@ -48,10 +49,13 @@ class Effect(StrictModel):\n     @model_validator(mode=\"after\")\n     def validate_source(self) -> Self:\n         \"\"\"Validate that source is valid for this effect type\"\"\"\n-        # Lazy import to avoid circular dependency\n         from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n+        from .cards import EFFECTS_SOURCE_CARD_MAP\n+\n+        ability_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        card_sources = EFFECTS_SOURCE_CARD_MAP.get(self.name, set())\n+        valid_sources = ability_sources | card_sources\n \n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n         if self.source not in valid_sources and len(valid_sources) > 0:\n             raise ValueError(\n                 f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n@@ -86,6 +90,19 @@ class AttackBonusEffect(Effect):\n     attack_bonus: int\n \n \n+class DefenseBonusEffect(Effect):\n+    \"\"\"\n+    Character's defense is increased, reducing incoming attack damage.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DEFENSE_BONUS] = DEFENSE_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    defense_bonus: int\n+\n+\n class RerollDiceEffect(Effect):\n     \"\"\"\n     Character's dice are rerolled if lost the battle.\n@@ -127,7 +144,7 @@ class DrawCardEffect(Effect):\n \n # Define EffectUnion for discriminated union of all effect types (without base classes)\n EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Union[AttackBonusEffect, AttackNegBonusEffect, DefenseBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n     Field(discriminator=\"name\"),\n ]\n \n@@ -140,6 +157,7 @@ class EffectTotal(StrictModel):\n \n     attack_bonus: int = 0\n     attack_neg_bonus: int = 0\n+    defense_bonus: int = 0\n     skip_next_turn: bool = False\n     reroll_dice_available: bool = False\n     draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nindex 937d1f7..7cc6b3a 100644\n--- a/server/gameplay/gameplay.py\n+++ b/server/gameplay/gameplay.py\n@@ -18,6 +18,7 @@ from .common import (\n # Stages\n ########################################################\n CHARACTER_SELECT = \"character_select\"\n+CARD_DRAW = \"card_draw\"\n ABILITY_SELECTION = \"ability_selection\"\n ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n OPPONENT_SELECTION = \"opponent_selection\"\n@@ -25,6 +26,7 @@ BATTLE_DICE_ROLL = \"battle_dice_roll\"\n BATTLE_END = \"battle_end\"\n STAGES_NAMES = [\n     CHARACTER_SELECT,\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n@@ -46,6 +48,7 @@ from .effects import (\n     EffectTotal,\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -79,6 +82,8 @@ class Character(StrictModel):\n                 total.attack_bonus += eff.attack_bonus\n             elif isinstance(eff, AttackNegBonusEffect):\n                 total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, DefenseBonusEffect):\n+                total.defense_bonus += eff.defense_bonus\n             elif isinstance(eff, SkipTurnEffect):\n                 total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n             elif isinstance(eff, RerollDiceEffect):\n@@ -98,6 +103,12 @@ class CharacterSelectMeta(StrictModel):\n     selected: str  # Currently highlighted character\n \n \n+class CardDrawMeta(StrictModel):\n+    \"\"\"Stage metadata for card draw stage\"\"\"\n+\n+    drawn_card: str  # The card that was randomly drawn\n+\n+\n class AbilitySelectMeta(StrictModel):\n     \"\"\"Stage metadata for ability selection stage\"\"\"\n \n@@ -171,10 +182,11 @@ class GamePlay(StrictModel):\n     stage: StageName = CHARACTER_SELECT\n     players: dict[str, Player] = Field(default_factory=dict)\n     active: Optional[ActivePlayer] = None  # The active player and its selections\n+    card: Optional[str] = None  # Selected card from card_draw stage\n     ability: Optional[Ability] = None  # Selected ability\n     ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n     opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+    stage_meta: Optional[Ability | CharacterSelectMeta | CardDrawMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n \n     def reorder_players(self, username: str):\n         \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\ndiff --git a/server/gameplay/presets.py b/server/gameplay/presets.py\nindex cc9a0ab..d1f6ab0 100644\n--- a/server/gameplay/presets.py\n+++ b/server/gameplay/presets.py\n@@ -5,6 +5,7 @@ from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -38,6 +39,7 @@ BATTLE_DRAW = \"battle_draw\"\n BATTLE_PLAYER_1_WIN = \"battle_player_1_win\"\n BATTLE_PLAYER_2_WIN = \"battle_player_2_win\"\n BATTLE_WITH_EFFECTS = \"battle_with_effects\"\n+BATTLE_METAL_ARMOR = \"battle_metal_armor\"\n HEALTH_1 = \"health_1\"\n KNIGHT_NOT_ALIVE = \"knight_not_alive\"\n EFFECT_ATTACK_BONUS = \"effect_attack_bonus\"\n@@ -55,6 +57,7 @@ DEBUG_PRESETS = Literal[\n     \"battle_player_1_win\",\n     \"battle_player_2_win\",\n     \"battle_with_effects\",\n+    \"battle_metal_armor\",\n     \"effect_attack_bonus\",\n     \"effect_reroll\",\n     \"effect_skip_turn\",\n@@ -316,6 +319,33 @@ def get_debug_preset(\n                 p2_name: Player(name=p2_name, characters=characters_p2),\n             },\n         )\n+    elif preset == \"battle_metal_armor\":\n+        # Knight with metal_armor loses to mage but takes 0 damage due to +2 defense\n+        # Player 1: knight (dice=[3], attack=1) with metal_armor (+2 defense) = 4\n+        # Player 2: mage (dice=[5], attack=0) = 5\n+        # Result: knight loses (4 < 5) but takes 0 damage (1 - 2 defense = 0)\n+        from .cards import METAL_ARMOR\n+\n+        characters_p1 = init_characters()\n+        characters_p1[KNIGHT].effects = [\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ]\n+\n+        characters_p2 = init_characters()\n+\n+        ret = GamePlay(\n+            stage=BATTLE_END,\n+            active=ActivePlayer4(\n+                player=p1_name, character=KNIGHT, dice_roll=[3], result=BattleResult(winner=False, score=4)\n+            ),\n+            opponent=Opponent4(\n+                player=p2_name, character=MAGE, dice_roll=[5], result=BattleResult(winner=True, score=5)\n+            ),\n+            players={\n+                p1_name: Player(name=p1_name, characters=characters_p1),\n+                p2_name: Player(name=p2_name, characters=characters_p2),\n+            },\n+        )\n     else:\n         raise ValueError(f\"Invalid preset: {preset}\")\n \ndiff --git a/src/constants/stages.js b/src/constants/stages.js\nindex 176cc8f..08ca49d 100644\n--- a/src/constants/stages.js\n+++ b/src/constants/stages.js\n@@ -1,5 +1,6 @@\n // Stage constants - must match backend stage names in server/gameplay/models.py\n export const CHARACTER_SELECT = \"character_select\";\n+export const CARD_DRAW = \"card_draw\";\n export const ABILITY_SELECTION = \"ability_selection\";\n export const ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\";\n export const OPPONENT_SELECTION = \"opponent_selection\";"
    },
    "preserveOutput": "always",
    "reporter": [
      [
        "html",
        {
          "open": "never"
        }
      ],
      [
        "json",
        {
          "outputFile": "playwright-report/results.json"
        }
      ],
      [
        "junit",
        {
          "outputFile": "playwright-report/results.xml"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "quiet": false,
    "projects": [
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
            "commitHash": "00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/33",
            "prTitle": "Add card_draw stage with metal_armor card",
            "prBaseHash": "6db5943692b40caef32caa8c6c7bf54848f4403e",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21158449323"
          },
          "gitCommit": {
            "shortHash": "00a7473",
            "hash": "00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
            "subject": "Merge 0016712d60a0d9b60f0c0d66dd3175c6c509616c into 6db5943692b40caef32caa8c6c7bf54848f4403e",
            "body": "Merge 0016712d60a0d9b60f0c0d66dd3175c6c509616c into 6db5943692b40caef32caa8c6c7bf54848f4403e\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768879768000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768879768000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 2c1329f..1827087 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -6,6 +6,8 @@ from ..common import (\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\n@@ -22,6 +24,7 @@ from ..common import (\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n@@ -35,6 +38,8 @@ ACTION_MAP: Dict[str, type[Action]] = {\n     DISCONNECT: DisconnectAction,\n     CHARACTER_PRESS: CharacterPressAction,\n     CHARACTER_SELECT_ACTION: CharacterSelectAction,\n+    CARD_DRAW_ACTION: CardDrawAction,\n+    CARD_SELECT_ACTION: CardSelectAction,\n     ABILITY_PRESS: AbilityPressAction,\n     ABILITY_SELECT: AbilitySelectAction,\n     ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex 0d9861f..f9bc5a1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -46,17 +46,22 @@ class BattleEndAction(Action):\n         active_character = self.active_character\n         opponent_character = self.opponent_character\n \n-        # Calculate scores\n-        active_score = sum(self.game.active.dice_roll) + active_character.attack\n-        opponent_score = sum(self.game.opponent.dice_roll) + opponent_character.attack\n+        # Calculate scores (including effects)\n+        active_total_attack = active_character.attack + active_character.effect.attack_bonus + active_character.effect.attack_neg_bonus\n+        opponent_total_attack = opponent_character.attack + opponent_character.effect.attack_bonus + opponent_character.effect.attack_neg_bonus\n \n-        # Determine loser and reduce health\n+        active_score = sum(self.game.active.dice_roll) + active_total_attack\n+        opponent_score = sum(self.game.opponent.dice_roll) + opponent_total_attack\n+\n+        # Determine loser and reduce health (defense reduces incoming damage)\n         if active_score > opponent_score:\n             # Active player wins, opponent loses health\n-            opponent_character.health = max(0, opponent_character.health - 1)\n+            damage = max(0, 1 - opponent_character.effect.defense_bonus)\n+            opponent_character.health = max(0, opponent_character.health - damage)\n         elif opponent_score > active_score:\n             # Opponent wins, active player loses health\n-            active_character.health = max(0, active_character.health - 1)\n+            damage = max(0, 1 - active_character.effect.defense_bonus)\n+            active_character.health = max(0, active_character.health - damage)\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n@@ -84,6 +89,8 @@ class BattleEndAction(Action):\n         # Clear battle state and transition to next turn\n         self.game.active = ActivePlayer1(player=next_player_name)\n         self.game.opponent = None\n+        self.game.card = None\n+        self.game.ability = None\n         self.game.stage = CHARACTER_SELECT\n         self.game.stage_meta = None\n \ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nnew file mode 100644\nindex 0000000..a9e196c\n--- /dev/null\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -0,0 +1,113 @@\n+\"\"\"\n+Card Draw Stage Actions\n+\n+This module implements actions for the card draw stage:\n+- CardDrawAction: Automatically draws a random card and stores it in stage_meta\n+- CardSelectAction: Applies the drawn card's effects and transitions to ability_selection\n+\"\"\"\n+\n+import random\n+import copy\n+from .action import Action\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n+from ..cards import CardName, CARDS_MAP, CARDS_NAMES\n+from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n+\n+\n+class CardDrawAction(Action):\n+    \"\"\"\n+    Action invoked when entering the card draw stage.\n+\n+    Draws a random card from the available cards and stores it in stage_meta.\n+    This action should be called automatically when the stage starts.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Draw a random card\n+        drawn_card = random.choice(CARDS_NAMES)\n+\n+        # Store the drawn card in stage metadata\n+        self.game.stage_meta = CardDrawMeta(drawn_card=drawn_card)\n+\n+        return self.game\n+\n+\n+class CardSelectAction(Action):\n+    \"\"\"\n+    Action invoked when the player confirms to use the drawn card.\n+\n+    Applies the card's effects to the active player's character and transitions\n+    to the ability_selection stage.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Get the active character\n+        if not hasattr(self.game.active, \"character\"):\n+            raise GameException(\"No character selected\")\n+\n+        # Validate that a card was drawn\n+        if not self.game.stage_meta or not isinstance(self.game.stage_meta, CardDrawMeta):\n+            raise GameException(\"No card was drawn\")\n+\n+        player = self.game.players[self.user]\n+        character = player.characters[self.game.active.character]\n+\n+        # Get the drawn card\n+        drawn_card_name = self.game.stage_meta.drawn_card\n+        card_obj = CARDS_MAP.get(drawn_card_name)\n+\n+        if not card_obj:\n+            raise GameException(f\"Card {drawn_card_name} not found\")\n+\n+        # Store the selected card in GamePlay.card\n+        self.game.card = drawn_card_name\n+\n+        # Apply \"self\" effects to the active player's character\n+        for effect in card_obj.effects:\n+            if effect.apply_to == APPLY_TO_SELF:\n+                # Deep copy the effect to avoid modifying the original card definition\n+                effect_copy = copy.deepcopy(effect)\n+                character.effects.append(effect_copy)\n+\n+        # Add the card to the player's card list (for display purposes)\n+        player.cards.append(drawn_card_name)\n+\n+        # Clear stage_meta after selection\n+        self.game.stage_meta = None\n+\n+        # Transition to ability_selection stage\n+        self.game.stage = ABILITY_SELECTION\n+\n+        # Auto-select if character has only one ability\n+        if len(character.abilities) == 1:\n+            self.game.stage_meta = AbilitySelectMeta(\n+                selected=character.abilities[0].name\n+            )\n+\n+        return self.game\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 474748e..cd8ba75 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -3,7 +3,7 @@ Character Select Stage Actions\n \n This module implements actions for the character selection stage:\n - CharacterPressAction: Highlights selected character by setting stage_meta\n-- CharacterSelectAction: Confirms selection, disposes effects, and transitions to ability_selection\n+- CharacterSelectAction: Confirms selection, disposes effects, and transitions to card_draw\n \"\"\"\n \n from .action import Action\n@@ -13,10 +13,12 @@ from ..common import (\n     CHARACTER_SELECT_ACTION,\n )\n from ..gameplay import (\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n+    CardDrawMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n )\n@@ -63,7 +65,7 @@ class CharacterSelectAction(Action):\n     Action invoked when the Select button is pressed to confirm character choice.\n \n     Populates selected_character in game metadata, disposes effects with\n-    'character_select' in dispose_actions, and transitions the game stage to 'ability_selection'.\n+    'character_select' in dispose_actions, and transitions the game stage to 'card_draw'.\n     \"\"\"\n \n     @property\n@@ -98,16 +100,10 @@ class CharacterSelectAction(Action):\n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n-        # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n-\n-        # Auto-select if character has only one ability\n-        selected_character = player.characters[character]\n-        if len(selected_character.abilities) == 1:\n-            self.game.stage_meta = AbilitySelectMeta(\n-                selected=selected_character.abilities[0].name\n-            )\n-        else:\n-            self.game.stage_meta = None\n+        # Transition to card_draw stage\n+        self.game.stage = CARD_DRAW\n+\n+        # Clear stage_meta - will be populated by CardDrawAction\n+        self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex ff48b63..0195959 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -3,7 +3,7 @@ Opponent Selection Stage Actions\n \n This module implements actions for the opponent selection stage:\n - OpponentPressAction: Highlights selected opponent by setting stage_meta\n-- OpponentSelectAction: Confirms opponent selection and transitions to battle stage\n+- OpponentSelectAction: Confirms opponent selection, applies card and ability effects to opponent, and transitions to battle stage\n \"\"\"\n \n import copy\n@@ -100,7 +100,18 @@ class OpponentSelectAction(Action):\n         # Set opponent in game metadata\n         self.game.opponent = selected_opponent\n \n-        # Apply \"battle_opponent\" effects to the opponent's character\n+        # Apply \"battle_opponent\" effects from card to the opponent's character\n+        if self.game.card:\n+            from ..cards import CARDS_MAP\n+            card_obj = CARDS_MAP.get(self.game.card)\n+            if card_obj:\n+                for effect in card_obj.effects:\n+                    if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\n+                        # Deep copy the effect to avoid modifying the original card definition\n+                        effect_copy = copy.deepcopy(effect)\n+                        opponent_character.effects.append(effect_copy)\n+\n+        # Apply \"battle_opponent\" effects from ability to the opponent's character\n         if self.game.ability:\n             for effect in self.game.ability.effects:\n                 if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\ndiff --git a/server/gameplay/actions/test_stage_card_draw.py b/server/gameplay/actions/test_stage_card_draw.py\nnew file mode 100644\nindex 0000000..0c75197\n--- /dev/null\n+++ b/server/gameplay/actions/test_stage_card_draw.py\n@@ -0,0 +1,187 @@\n+\"\"\"\n+Tests for Card Draw Stage Actions.\n+\n+These tests verify card draw behavior including drawing a random card\n+and applying card effects to the character.\n+\"\"\"\n+\n+import pytest\n+\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n+from ..common import GameException, ReportedException, KNIGHT, MAGE\n+from ..cards import METAL_ARMOR, CARDS_MAP\n+from ..effects import DefenseBonusEffect\n+from ..gameplay import (\n+    CARD_DRAW,\n+    ABILITY_SELECTION,\n+    CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    ActivePlayer2,\n+    CardDrawMeta,\n+    init_characters,\n+)\n+\n+\n+def test_card_draw_action_valid():\n+    \"\"\"Test drawing a card stores it in stage_meta\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardDrawAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    assert updated_game.stage_meta is not None\n+    assert isinstance(updated_game.stage_meta, CardDrawMeta)\n+    assert updated_game.stage_meta.drawn_card in CARDS_MAP\n+    assert updated_game.stage == CARD_DRAW  # Still in card draw stage\n+\n+\n+def test_card_draw_action_not_active_player():\n+    \"\"\"Test drawing card when not active player raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\n+            \"player1\": Player(name=\"player1\", characters=characters),\n+            \"player2\": Player(name=\"player2\", characters=init_characters()),\n+        },\n+    )\n+\n+    action = CardDrawAction(\"player2\", game)\n+\n+    with pytest.raises(ReportedException, match=\"It's not your turn\"):\n+        action.run()\n+\n+\n+def test_card_draw_action_wrong_stage():\n+    \"\"\"Test drawing card in wrong stage raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardDrawAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n+        action.run()\n+\n+\n+def test_card_select_action_applies_effects():\n+    \"\"\"Test selecting a card applies its effects to the character\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    # Check game state\n+    assert updated_game.stage == ABILITY_SELECTION\n+    assert updated_game.card == METAL_ARMOR\n+    assert updated_game.stage_meta is not None  # Auto-selected ability\n+\n+    # Check character has defense effect\n+    player = updated_game.players[\"player1\"]\n+    knight = player.characters[KNIGHT]\n+    assert len(knight.effects) == 1\n+    assert isinstance(knight.effects[0], DefenseBonusEffect)\n+    assert knight.effects[0].defense_bonus == 2\n+    assert knight.effects[0].source == METAL_ARMOR\n+    assert knight.effects[0].dispose_actions == []  # Persistent effect\n+\n+    # Check card added to player's card list\n+    assert METAL_ARMOR in player.cards\n+\n+\n+def test_card_select_action_not_active_player():\n+    \"\"\"Test selecting card when not active player raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\n+            \"player1\": Player(name=\"player1\", characters=characters),\n+            \"player2\": Player(name=\"player2\", characters=init_characters()),\n+        },\n+    )\n+\n+    action = CardSelectAction(\"player2\", game)\n+\n+    with pytest.raises(ReportedException, match=\"It's not your turn\"):\n+        action.run()\n+\n+\n+def test_card_select_action_no_card_drawn():\n+    \"\"\"Test selecting card when no card was drawn raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"No card was drawn\"):\n+        action.run()\n+\n+\n+def test_card_select_action_wrong_stage():\n+    \"\"\"Test selecting card in wrong stage raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n+        action.run()\n+\n+\n+def test_metal_armor_defense_persists():\n+    \"\"\"Test metal_armor defense effect persists across battles using preset\"\"\"\n+    from ..presets import get_debug_preset, BATTLE_METAL_ARMOR\n+    from .battle_end import BattleEndAction\n+\n+    # Get preset with knight having metal_armor and losing battle\n+    game = get_debug_preset(BATTLE_METAL_ARMOR, player1_name=\"player1\", player2_name=\"player2\")\n+\n+    # Knight should have defense effect before battle ends\n+    player1 = game.players[\"player1\"]\n+    knight = player1.characters[KNIGHT]\n+    assert len(knight.effects) == 1\n+    assert isinstance(knight.effects[0], DefenseBonusEffect)\n+    assert knight.effects[0].defense_bonus == 2\n+\n+    # Knight's initial health\n+    knight_health_before = knight.health\n+\n+    # End battle (knight loses but has +2 defense)\n+    action = BattleEndAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    # Knight should take 0 damage (1 - 2 defense = 0)\n+    knight_after = updated_game.players[\"player1\"].characters[KNIGHT]\n+    assert knight_after.health == knight_health_before  # No damage taken\n+\n+    # Defense effect should still be present (persistent, not disposed)\n+    assert len(knight_after.effects) == 1\n+    assert isinstance(knight_after.effects[0], DefenseBonusEffect)\n+    assert knight_after.effects[0].defense_bonus == 2\ndiff --git a/server/gameplay/actions_names.py b/server/gameplay/actions_names.py\nindex 0d4eafc..9c48bba 100644\n--- a/server/gameplay/actions_names.py\n+++ b/server/gameplay/actions_names.py\n@@ -11,6 +11,8 @@ LEAVE = \"leave\"\n DISCONNECT = \"disconnect\"\n CHARACTER_PRESS = \"character_press\"\n CHARACTER_SELECT_ACTION = \"character_select\"\n+CARD_DRAW_ACTION = \"card_draw\"\n+CARD_SELECT_ACTION = \"card_select\"\n ABILITY_PRESS = \"ability_press\"\n ABILITY_SELECT = \"ability_select\"\n ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n@@ -30,6 +32,8 @@ ACTION_NAMES = [\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\ndiff --git a/server/gameplay/cards.py b/server/gameplay/cards.py\nnew file mode 100644\nindex 0000000..d37eeb0\n--- /dev/null\n+++ b/server/gameplay/cards.py\n@@ -0,0 +1,50 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_CARD_MAP\n+    DEFENSE_BONUS,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+)\n+\n+########################################################\n+# Card names - defined before imports from effects to avoid circular dependency\n+########################################################\n+METAL_ARMOR = \"metal_armor\"\n+CARDS_NAMES: list[str] = [METAL_ARMOR]\n+CardName = Literal[*CARDS_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which cards can create which effects\n+# This is used for validation to ensure effects have valid source cards\n+EFFECTS_SOURCE_CARD_MAP: dict[str, set[str]] = {\n+    DEFENSE_BONUS: {METAL_ARMOR},  # DefenseBonusEffect can come from METAL_ARMOR\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    DefenseBonusEffect,\n+)\n+\n+\n+class Card(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+\n+CARDS_MAP: dict[CardName, Card] = {\n+    METAL_ARMOR: Card(\n+        name=METAL_ARMOR,\n+        effects=[\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nindex 6eb879e..5a59b55 100644\n--- a/server/gameplay/effects.py\n+++ b/server/gameplay/effects.py\n@@ -18,6 +18,7 @@ from .actions_names import (\n ########################################################\n ATTACK_BONUS = \"attack_bonus\"\n ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+DEFENSE_BONUS = \"defense_bonus\"\n REROLL_DICE = \"reroll_dice\"\n SKIP_TURN = \"skip_turn\"\n DRAW_CARD = \"draw_card\"\n@@ -48,10 +49,13 @@ class Effect(StrictModel):\n     @model_validator(mode=\"after\")\n     def validate_source(self) -> Self:\n         \"\"\"Validate that source is valid for this effect type\"\"\"\n-        # Lazy import to avoid circular dependency\n         from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n+        from .cards import EFFECTS_SOURCE_CARD_MAP\n+\n+        ability_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        card_sources = EFFECTS_SOURCE_CARD_MAP.get(self.name, set())\n+        valid_sources = ability_sources | card_sources\n \n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n         if self.source not in valid_sources and len(valid_sources) > 0:\n             raise ValueError(\n                 f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n@@ -86,6 +90,19 @@ class AttackBonusEffect(Effect):\n     attack_bonus: int\n \n \n+class DefenseBonusEffect(Effect):\n+    \"\"\"\n+    Character's defense is increased, reducing incoming attack damage.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DEFENSE_BONUS] = DEFENSE_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    defense_bonus: int\n+\n+\n class RerollDiceEffect(Effect):\n     \"\"\"\n     Character's dice are rerolled if lost the battle.\n@@ -127,7 +144,7 @@ class DrawCardEffect(Effect):\n \n # Define EffectUnion for discriminated union of all effect types (without base classes)\n EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Union[AttackBonusEffect, AttackNegBonusEffect, DefenseBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n     Field(discriminator=\"name\"),\n ]\n \n@@ -140,6 +157,7 @@ class EffectTotal(StrictModel):\n \n     attack_bonus: int = 0\n     attack_neg_bonus: int = 0\n+    defense_bonus: int = 0\n     skip_next_turn: bool = False\n     reroll_dice_available: bool = False\n     draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nindex 937d1f7..7cc6b3a 100644\n--- a/server/gameplay/gameplay.py\n+++ b/server/gameplay/gameplay.py\n@@ -18,6 +18,7 @@ from .common import (\n # Stages\n ########################################################\n CHARACTER_SELECT = \"character_select\"\n+CARD_DRAW = \"card_draw\"\n ABILITY_SELECTION = \"ability_selection\"\n ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n OPPONENT_SELECTION = \"opponent_selection\"\n@@ -25,6 +26,7 @@ BATTLE_DICE_ROLL = \"battle_dice_roll\"\n BATTLE_END = \"battle_end\"\n STAGES_NAMES = [\n     CHARACTER_SELECT,\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n@@ -46,6 +48,7 @@ from .effects import (\n     EffectTotal,\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -79,6 +82,8 @@ class Character(StrictModel):\n                 total.attack_bonus += eff.attack_bonus\n             elif isinstance(eff, AttackNegBonusEffect):\n                 total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, DefenseBonusEffect):\n+                total.defense_bonus += eff.defense_bonus\n             elif isinstance(eff, SkipTurnEffect):\n                 total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n             elif isinstance(eff, RerollDiceEffect):\n@@ -98,6 +103,12 @@ class CharacterSelectMeta(StrictModel):\n     selected: str  # Currently highlighted character\n \n \n+class CardDrawMeta(StrictModel):\n+    \"\"\"Stage metadata for card draw stage\"\"\"\n+\n+    drawn_card: str  # The card that was randomly drawn\n+\n+\n class AbilitySelectMeta(StrictModel):\n     \"\"\"Stage metadata for ability selection stage\"\"\"\n \n@@ -171,10 +182,11 @@ class GamePlay(StrictModel):\n     stage: StageName = CHARACTER_SELECT\n     players: dict[str, Player] = Field(default_factory=dict)\n     active: Optional[ActivePlayer] = None  # The active player and its selections\n+    card: Optional[str] = None  # Selected card from card_draw stage\n     ability: Optional[Ability] = None  # Selected ability\n     ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n     opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+    stage_meta: Optional[Ability | CharacterSelectMeta | CardDrawMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n \n     def reorder_players(self, username: str):\n         \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\ndiff --git a/server/gameplay/presets.py b/server/gameplay/presets.py\nindex cc9a0ab..d1f6ab0 100644\n--- a/server/gameplay/presets.py\n+++ b/server/gameplay/presets.py\n@@ -5,6 +5,7 @@ from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -38,6 +39,7 @@ BATTLE_DRAW = \"battle_draw\"\n BATTLE_PLAYER_1_WIN = \"battle_player_1_win\"\n BATTLE_PLAYER_2_WIN = \"battle_player_2_win\"\n BATTLE_WITH_EFFECTS = \"battle_with_effects\"\n+BATTLE_METAL_ARMOR = \"battle_metal_armor\"\n HEALTH_1 = \"health_1\"\n KNIGHT_NOT_ALIVE = \"knight_not_alive\"\n EFFECT_ATTACK_BONUS = \"effect_attack_bonus\"\n@@ -55,6 +57,7 @@ DEBUG_PRESETS = Literal[\n     \"battle_player_1_win\",\n     \"battle_player_2_win\",\n     \"battle_with_effects\",\n+    \"battle_metal_armor\",\n     \"effect_attack_bonus\",\n     \"effect_reroll\",\n     \"effect_skip_turn\",\n@@ -316,6 +319,33 @@ def get_debug_preset(\n                 p2_name: Player(name=p2_name, characters=characters_p2),\n             },\n         )\n+    elif preset == \"battle_metal_armor\":\n+        # Knight with metal_armor loses to mage but takes 0 damage due to +2 defense\n+        # Player 1: knight (dice=[3], attack=1) with metal_armor (+2 defense) = 4\n+        # Player 2: mage (dice=[5], attack=0) = 5\n+        # Result: knight loses (4 < 5) but takes 0 damage (1 - 2 defense = 0)\n+        from .cards import METAL_ARMOR\n+\n+        characters_p1 = init_characters()\n+        characters_p1[KNIGHT].effects = [\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ]\n+\n+        characters_p2 = init_characters()\n+\n+        ret = GamePlay(\n+            stage=BATTLE_END,\n+            active=ActivePlayer4(\n+                player=p1_name, character=KNIGHT, dice_roll=[3], result=BattleResult(winner=False, score=4)\n+            ),\n+            opponent=Opponent4(\n+                player=p2_name, character=MAGE, dice_roll=[5], result=BattleResult(winner=True, score=5)\n+            ),\n+            players={\n+                p1_name: Player(name=p1_name, characters=characters_p1),\n+                p2_name: Player(name=p2_name, characters=characters_p2),\n+            },\n+        )\n     else:\n         raise ValueError(f\"Invalid preset: {preset}\")\n \ndiff --git a/src/constants/stages.js b/src/constants/stages.js\nindex 176cc8f..08ca49d 100644\n--- a/src/constants/stages.js\n+++ b/src/constants/stages.js\n@@ -1,5 +1,6 @@\n // Stage constants - must match backend stage names in server/gameplay/models.py\n export const CHARACTER_SELECT = \"character_select\";\n+export const CARD_DRAW = \"card_draw\";\n export const ABILITY_SELECTION = \"ability_selection\";\n export const ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\";\n export const OPPONENT_SELECTION = \"opponent_selection\";"
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      },
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
            "commitHash": "00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/33",
            "prTitle": "Add card_draw stage with metal_armor card",
            "prBaseHash": "6db5943692b40caef32caa8c6c7bf54848f4403e",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21158449323"
          },
          "gitCommit": {
            "shortHash": "00a7473",
            "hash": "00a747339ac1c3714e7d1d252ebcdb7ff76a66d1",
            "subject": "Merge 0016712d60a0d9b60f0c0d66dd3175c6c509616c into 6db5943692b40caef32caa8c6c7bf54848f4403e",
            "body": "Merge 0016712d60a0d9b60f0c0d66dd3175c6c509616c into 6db5943692b40caef32caa8c6c7bf54848f4403e\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768879768000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768879768000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 2c1329f..1827087 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -6,6 +6,8 @@ from ..common import (\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\n@@ -22,6 +24,7 @@ from ..common import (\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n@@ -35,6 +38,8 @@ ACTION_MAP: Dict[str, type[Action]] = {\n     DISCONNECT: DisconnectAction,\n     CHARACTER_PRESS: CharacterPressAction,\n     CHARACTER_SELECT_ACTION: CharacterSelectAction,\n+    CARD_DRAW_ACTION: CardDrawAction,\n+    CARD_SELECT_ACTION: CardSelectAction,\n     ABILITY_PRESS: AbilityPressAction,\n     ABILITY_SELECT: AbilitySelectAction,\n     ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex 0d9861f..f9bc5a1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -46,17 +46,22 @@ class BattleEndAction(Action):\n         active_character = self.active_character\n         opponent_character = self.opponent_character\n \n-        # Calculate scores\n-        active_score = sum(self.game.active.dice_roll) + active_character.attack\n-        opponent_score = sum(self.game.opponent.dice_roll) + opponent_character.attack\n+        # Calculate scores (including effects)\n+        active_total_attack = active_character.attack + active_character.effect.attack_bonus + active_character.effect.attack_neg_bonus\n+        opponent_total_attack = opponent_character.attack + opponent_character.effect.attack_bonus + opponent_character.effect.attack_neg_bonus\n \n-        # Determine loser and reduce health\n+        active_score = sum(self.game.active.dice_roll) + active_total_attack\n+        opponent_score = sum(self.game.opponent.dice_roll) + opponent_total_attack\n+\n+        # Determine loser and reduce health (defense reduces incoming damage)\n         if active_score > opponent_score:\n             # Active player wins, opponent loses health\n-            opponent_character.health = max(0, opponent_character.health - 1)\n+            damage = max(0, 1 - opponent_character.effect.defense_bonus)\n+            opponent_character.health = max(0, opponent_character.health - damage)\n         elif opponent_score > active_score:\n             # Opponent wins, active player loses health\n-            active_character.health = max(0, active_character.health - 1)\n+            damage = max(0, 1 - active_character.effect.defense_bonus)\n+            active_character.health = max(0, active_character.health - damage)\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n@@ -84,6 +89,8 @@ class BattleEndAction(Action):\n         # Clear battle state and transition to next turn\n         self.game.active = ActivePlayer1(player=next_player_name)\n         self.game.opponent = None\n+        self.game.card = None\n+        self.game.ability = None\n         self.game.stage = CHARACTER_SELECT\n         self.game.stage_meta = None\n \ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nnew file mode 100644\nindex 0000000..a9e196c\n--- /dev/null\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -0,0 +1,113 @@\n+\"\"\"\n+Card Draw Stage Actions\n+\n+This module implements actions for the card draw stage:\n+- CardDrawAction: Automatically draws a random card and stores it in stage_meta\n+- CardSelectAction: Applies the drawn card's effects and transitions to ability_selection\n+\"\"\"\n+\n+import random\n+import copy\n+from .action import Action\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n+from ..cards import CardName, CARDS_MAP, CARDS_NAMES\n+from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n+\n+\n+class CardDrawAction(Action):\n+    \"\"\"\n+    Action invoked when entering the card draw stage.\n+\n+    Draws a random card from the available cards and stores it in stage_meta.\n+    This action should be called automatically when the stage starts.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Draw a random card\n+        drawn_card = random.choice(CARDS_NAMES)\n+\n+        # Store the drawn card in stage metadata\n+        self.game.stage_meta = CardDrawMeta(drawn_card=drawn_card)\n+\n+        return self.game\n+\n+\n+class CardSelectAction(Action):\n+    \"\"\"\n+    Action invoked when the player confirms to use the drawn card.\n+\n+    Applies the card's effects to the active player's character and transitions\n+    to the ability_selection stage.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Get the active character\n+        if not hasattr(self.game.active, \"character\"):\n+            raise GameException(\"No character selected\")\n+\n+        # Validate that a card was drawn\n+        if not self.game.stage_meta or not isinstance(self.game.stage_meta, CardDrawMeta):\n+            raise GameException(\"No card was drawn\")\n+\n+        player = self.game.players[self.user]\n+        character = player.characters[self.game.active.character]\n+\n+        # Get the drawn card\n+        drawn_card_name = self.game.stage_meta.drawn_card\n+        card_obj = CARDS_MAP.get(drawn_card_name)\n+\n+        if not card_obj:\n+            raise GameException(f\"Card {drawn_card_name} not found\")\n+\n+        # Store the selected card in GamePlay.card\n+        self.game.card = drawn_card_name\n+\n+        # Apply \"self\" effects to the active player's character\n+        for effect in card_obj.effects:\n+            if effect.apply_to == APPLY_TO_SELF:\n+                # Deep copy the effect to avoid modifying the original card definition\n+                effect_copy = copy.deepcopy(effect)\n+                character.effects.append(effect_copy)\n+\n+        # Add the card to the player's card list (for display purposes)\n+        player.cards.append(drawn_card_name)\n+\n+        # Clear stage_meta after selection\n+        self.game.stage_meta = None\n+\n+        # Transition to ability_selection stage\n+        self.game.stage = ABILITY_SELECTION\n+\n+        # Auto-select if character has only one ability\n+        if len(character.abilities) == 1:\n+            self.game.stage_meta = AbilitySelectMeta(\n+                selected=character.abilities[0].name\n+            )\n+\n+        return self.game\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 474748e..cd8ba75 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -3,7 +3,7 @@ Character Select Stage Actions\n \n This module implements actions for the character selection stage:\n - CharacterPressAction: Highlights selected character by setting stage_meta\n-- CharacterSelectAction: Confirms selection, disposes effects, and transitions to ability_selection\n+- CharacterSelectAction: Confirms selection, disposes effects, and transitions to card_draw\n \"\"\"\n \n from .action import Action\n@@ -13,10 +13,12 @@ from ..common import (\n     CHARACTER_SELECT_ACTION,\n )\n from ..gameplay import (\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n+    CardDrawMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n )\n@@ -63,7 +65,7 @@ class CharacterSelectAction(Action):\n     Action invoked when the Select button is pressed to confirm character choice.\n \n     Populates selected_character in game metadata, disposes effects with\n-    'character_select' in dispose_actions, and transitions the game stage to 'ability_selection'.\n+    'character_select' in dispose_actions, and transitions the game stage to 'card_draw'.\n     \"\"\"\n \n     @property\n@@ -98,16 +100,10 @@ class CharacterSelectAction(Action):\n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n-        # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n-\n-        # Auto-select if character has only one ability\n-        selected_character = player.characters[character]\n-        if len(selected_character.abilities) == 1:\n-            self.game.stage_meta = AbilitySelectMeta(\n-                selected=selected_character.abilities[0].name\n-            )\n-        else:\n-            self.game.stage_meta = None\n+        # Transition to card_draw stage\n+        self.game.stage = CARD_DRAW\n+\n+        # Clear stage_meta - will be populated by CardDrawAction\n+        self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex ff48b63..0195959 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -3,7 +3,7 @@ Opponent Selection Stage Actions\n \n This module implements actions for the opponent selection stage:\n - OpponentPressAction: Highlights selected opponent by setting stage_meta\n-- OpponentSelectAction: Confirms opponent selection and transitions to battle stage\n+- OpponentSelectAction: Confirms opponent selection, applies card and ability effects to opponent, and transitions to battle stage\n \"\"\"\n \n import copy\n@@ -100,7 +100,18 @@ class OpponentSelectAction(Action):\n         # Set opponent in game metadata\n         self.game.opponent = selected_opponent\n \n-        # Apply \"battle_opponent\" effects to the opponent's character\n+        # Apply \"battle_opponent\" effects from card to the opponent's character\n+        if self.game.card:\n+            from ..cards import CARDS_MAP\n+            card_obj = CARDS_MAP.get(self.game.card)\n+            if card_obj:\n+                for effect in card_obj.effects:\n+                    if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\n+                        # Deep copy the effect to avoid modifying the original card definition\n+                        effect_copy = copy.deepcopy(effect)\n+                        opponent_character.effects.append(effect_copy)\n+\n+        # Apply \"battle_opponent\" effects from ability to the opponent's character\n         if self.game.ability:\n             for effect in self.game.ability.effects:\n                 if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\ndiff --git a/server/gameplay/actions/test_stage_card_draw.py b/server/gameplay/actions/test_stage_card_draw.py\nnew file mode 100644\nindex 0000000..0c75197\n--- /dev/null\n+++ b/server/gameplay/actions/test_stage_card_draw.py\n@@ -0,0 +1,187 @@\n+\"\"\"\n+Tests for Card Draw Stage Actions.\n+\n+These tests verify card draw behavior including drawing a random card\n+and applying card effects to the character.\n+\"\"\"\n+\n+import pytest\n+\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n+from ..common import GameException, ReportedException, KNIGHT, MAGE\n+from ..cards import METAL_ARMOR, CARDS_MAP\n+from ..effects import DefenseBonusEffect\n+from ..gameplay import (\n+    CARD_DRAW,\n+    ABILITY_SELECTION,\n+    CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    ActivePlayer2,\n+    CardDrawMeta,\n+    init_characters,\n+)\n+\n+\n+def test_card_draw_action_valid():\n+    \"\"\"Test drawing a card stores it in stage_meta\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardDrawAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    assert updated_game.stage_meta is not None\n+    assert isinstance(updated_game.stage_meta, CardDrawMeta)\n+    assert updated_game.stage_meta.drawn_card in CARDS_MAP\n+    assert updated_game.stage == CARD_DRAW  # Still in card draw stage\n+\n+\n+def test_card_draw_action_not_active_player():\n+    \"\"\"Test drawing card when not active player raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\n+            \"player1\": Player(name=\"player1\", characters=characters),\n+            \"player2\": Player(name=\"player2\", characters=init_characters()),\n+        },\n+    )\n+\n+    action = CardDrawAction(\"player2\", game)\n+\n+    with pytest.raises(ReportedException, match=\"It's not your turn\"):\n+        action.run()\n+\n+\n+def test_card_draw_action_wrong_stage():\n+    \"\"\"Test drawing card in wrong stage raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardDrawAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n+        action.run()\n+\n+\n+def test_card_select_action_applies_effects():\n+    \"\"\"Test selecting a card applies its effects to the character\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    # Check game state\n+    assert updated_game.stage == ABILITY_SELECTION\n+    assert updated_game.card == METAL_ARMOR\n+    assert updated_game.stage_meta is not None  # Auto-selected ability\n+\n+    # Check character has defense effect\n+    player = updated_game.players[\"player1\"]\n+    knight = player.characters[KNIGHT]\n+    assert len(knight.effects) == 1\n+    assert isinstance(knight.effects[0], DefenseBonusEffect)\n+    assert knight.effects[0].defense_bonus == 2\n+    assert knight.effects[0].source == METAL_ARMOR\n+    assert knight.effects[0].dispose_actions == []  # Persistent effect\n+\n+    # Check card added to player's card list\n+    assert METAL_ARMOR in player.cards\n+\n+\n+def test_card_select_action_not_active_player():\n+    \"\"\"Test selecting card when not active player raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\n+            \"player1\": Player(name=\"player1\", characters=characters),\n+            \"player2\": Player(name=\"player2\", characters=init_characters()),\n+        },\n+    )\n+\n+    action = CardSelectAction(\"player2\", game)\n+\n+    with pytest.raises(ReportedException, match=\"It's not your turn\"):\n+        action.run()\n+\n+\n+def test_card_select_action_no_card_drawn():\n+    \"\"\"Test selecting card when no card was drawn raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CARD_DRAW,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"No card was drawn\"):\n+        action.run()\n+\n+\n+def test_card_select_action_wrong_stage():\n+    \"\"\"Test selecting card in wrong stage raises error\"\"\"\n+    characters = init_characters()\n+    game = GamePlay(\n+        stage=CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage_meta=CardDrawMeta(drawn_card=METAL_ARMOR),\n+        players={\"player1\": Player(name=\"player1\", characters=characters)},\n+    )\n+\n+    action = CardSelectAction(\"player1\", game)\n+\n+    with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n+        action.run()\n+\n+\n+def test_metal_armor_defense_persists():\n+    \"\"\"Test metal_armor defense effect persists across battles using preset\"\"\"\n+    from ..presets import get_debug_preset, BATTLE_METAL_ARMOR\n+    from .battle_end import BattleEndAction\n+\n+    # Get preset with knight having metal_armor and losing battle\n+    game = get_debug_preset(BATTLE_METAL_ARMOR, player1_name=\"player1\", player2_name=\"player2\")\n+\n+    # Knight should have defense effect before battle ends\n+    player1 = game.players[\"player1\"]\n+    knight = player1.characters[KNIGHT]\n+    assert len(knight.effects) == 1\n+    assert isinstance(knight.effects[0], DefenseBonusEffect)\n+    assert knight.effects[0].defense_bonus == 2\n+\n+    # Knight's initial health\n+    knight_health_before = knight.health\n+\n+    # End battle (knight loses but has +2 defense)\n+    action = BattleEndAction(\"player1\", game)\n+    updated_game = action.run()\n+\n+    # Knight should take 0 damage (1 - 2 defense = 0)\n+    knight_after = updated_game.players[\"player1\"].characters[KNIGHT]\n+    assert knight_after.health == knight_health_before  # No damage taken\n+\n+    # Defense effect should still be present (persistent, not disposed)\n+    assert len(knight_after.effects) == 1\n+    assert isinstance(knight_after.effects[0], DefenseBonusEffect)\n+    assert knight_after.effects[0].defense_bonus == 2\ndiff --git a/server/gameplay/actions_names.py b/server/gameplay/actions_names.py\nindex 0d4eafc..9c48bba 100644\n--- a/server/gameplay/actions_names.py\n+++ b/server/gameplay/actions_names.py\n@@ -11,6 +11,8 @@ LEAVE = \"leave\"\n DISCONNECT = \"disconnect\"\n CHARACTER_PRESS = \"character_press\"\n CHARACTER_SELECT_ACTION = \"character_select\"\n+CARD_DRAW_ACTION = \"card_draw\"\n+CARD_SELECT_ACTION = \"card_select\"\n ABILITY_PRESS = \"ability_press\"\n ABILITY_SELECT = \"ability_select\"\n ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n@@ -30,6 +32,8 @@ ACTION_NAMES = [\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\ndiff --git a/server/gameplay/cards.py b/server/gameplay/cards.py\nnew file mode 100644\nindex 0000000..d37eeb0\n--- /dev/null\n+++ b/server/gameplay/cards.py\n@@ -0,0 +1,50 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_CARD_MAP\n+    DEFENSE_BONUS,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+)\n+\n+########################################################\n+# Card names - defined before imports from effects to avoid circular dependency\n+########################################################\n+METAL_ARMOR = \"metal_armor\"\n+CARDS_NAMES: list[str] = [METAL_ARMOR]\n+CardName = Literal[*CARDS_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which cards can create which effects\n+# This is used for validation to ensure effects have valid source cards\n+EFFECTS_SOURCE_CARD_MAP: dict[str, set[str]] = {\n+    DEFENSE_BONUS: {METAL_ARMOR},  # DefenseBonusEffect can come from METAL_ARMOR\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    DefenseBonusEffect,\n+)\n+\n+\n+class Card(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+\n+CARDS_MAP: dict[CardName, Card] = {\n+    METAL_ARMOR: Card(\n+        name=METAL_ARMOR,\n+        effects=[\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nindex 6eb879e..5a59b55 100644\n--- a/server/gameplay/effects.py\n+++ b/server/gameplay/effects.py\n@@ -18,6 +18,7 @@ from .actions_names import (\n ########################################################\n ATTACK_BONUS = \"attack_bonus\"\n ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+DEFENSE_BONUS = \"defense_bonus\"\n REROLL_DICE = \"reroll_dice\"\n SKIP_TURN = \"skip_turn\"\n DRAW_CARD = \"draw_card\"\n@@ -48,10 +49,13 @@ class Effect(StrictModel):\n     @model_validator(mode=\"after\")\n     def validate_source(self) -> Self:\n         \"\"\"Validate that source is valid for this effect type\"\"\"\n-        # Lazy import to avoid circular dependency\n         from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n+        from .cards import EFFECTS_SOURCE_CARD_MAP\n+\n+        ability_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        card_sources = EFFECTS_SOURCE_CARD_MAP.get(self.name, set())\n+        valid_sources = ability_sources | card_sources\n \n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n         if self.source not in valid_sources and len(valid_sources) > 0:\n             raise ValueError(\n                 f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n@@ -86,6 +90,19 @@ class AttackBonusEffect(Effect):\n     attack_bonus: int\n \n \n+class DefenseBonusEffect(Effect):\n+    \"\"\"\n+    Character's defense is increased, reducing incoming attack damage.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DEFENSE_BONUS] = DEFENSE_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    defense_bonus: int\n+\n+\n class RerollDiceEffect(Effect):\n     \"\"\"\n     Character's dice are rerolled if lost the battle.\n@@ -127,7 +144,7 @@ class DrawCardEffect(Effect):\n \n # Define EffectUnion for discriminated union of all effect types (without base classes)\n EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Union[AttackBonusEffect, AttackNegBonusEffect, DefenseBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n     Field(discriminator=\"name\"),\n ]\n \n@@ -140,6 +157,7 @@ class EffectTotal(StrictModel):\n \n     attack_bonus: int = 0\n     attack_neg_bonus: int = 0\n+    defense_bonus: int = 0\n     skip_next_turn: bool = False\n     reroll_dice_available: bool = False\n     draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nindex 937d1f7..7cc6b3a 100644\n--- a/server/gameplay/gameplay.py\n+++ b/server/gameplay/gameplay.py\n@@ -18,6 +18,7 @@ from .common import (\n # Stages\n ########################################################\n CHARACTER_SELECT = \"character_select\"\n+CARD_DRAW = \"card_draw\"\n ABILITY_SELECTION = \"ability_selection\"\n ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n OPPONENT_SELECTION = \"opponent_selection\"\n@@ -25,6 +26,7 @@ BATTLE_DICE_ROLL = \"battle_dice_roll\"\n BATTLE_END = \"battle_end\"\n STAGES_NAMES = [\n     CHARACTER_SELECT,\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n@@ -46,6 +48,7 @@ from .effects import (\n     EffectTotal,\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -79,6 +82,8 @@ class Character(StrictModel):\n                 total.attack_bonus += eff.attack_bonus\n             elif isinstance(eff, AttackNegBonusEffect):\n                 total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, DefenseBonusEffect):\n+                total.defense_bonus += eff.defense_bonus\n             elif isinstance(eff, SkipTurnEffect):\n                 total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n             elif isinstance(eff, RerollDiceEffect):\n@@ -98,6 +103,12 @@ class CharacterSelectMeta(StrictModel):\n     selected: str  # Currently highlighted character\n \n \n+class CardDrawMeta(StrictModel):\n+    \"\"\"Stage metadata for card draw stage\"\"\"\n+\n+    drawn_card: str  # The card that was randomly drawn\n+\n+\n class AbilitySelectMeta(StrictModel):\n     \"\"\"Stage metadata for ability selection stage\"\"\"\n \n@@ -171,10 +182,11 @@ class GamePlay(StrictModel):\n     stage: StageName = CHARACTER_SELECT\n     players: dict[str, Player] = Field(default_factory=dict)\n     active: Optional[ActivePlayer] = None  # The active player and its selections\n+    card: Optional[str] = None  # Selected card from card_draw stage\n     ability: Optional[Ability] = None  # Selected ability\n     ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n     opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+    stage_meta: Optional[Ability | CharacterSelectMeta | CardDrawMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n \n     def reorder_players(self, username: str):\n         \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\ndiff --git a/server/gameplay/presets.py b/server/gameplay/presets.py\nindex cc9a0ab..d1f6ab0 100644\n--- a/server/gameplay/presets.py\n+++ b/server/gameplay/presets.py\n@@ -5,6 +5,7 @@ from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -38,6 +39,7 @@ BATTLE_DRAW = \"battle_draw\"\n BATTLE_PLAYER_1_WIN = \"battle_player_1_win\"\n BATTLE_PLAYER_2_WIN = \"battle_player_2_win\"\n BATTLE_WITH_EFFECTS = \"battle_with_effects\"\n+BATTLE_METAL_ARMOR = \"battle_metal_armor\"\n HEALTH_1 = \"health_1\"\n KNIGHT_NOT_ALIVE = \"knight_not_alive\"\n EFFECT_ATTACK_BONUS = \"effect_attack_bonus\"\n@@ -55,6 +57,7 @@ DEBUG_PRESETS = Literal[\n     \"battle_player_1_win\",\n     \"battle_player_2_win\",\n     \"battle_with_effects\",\n+    \"battle_metal_armor\",\n     \"effect_attack_bonus\",\n     \"effect_reroll\",\n     \"effect_skip_turn\",\n@@ -316,6 +319,33 @@ def get_debug_preset(\n                 p2_name: Player(name=p2_name, characters=characters_p2),\n             },\n         )\n+    elif preset == \"battle_metal_armor\":\n+        # Knight with metal_armor loses to mage but takes 0 damage due to +2 defense\n+        # Player 1: knight (dice=[3], attack=1) with metal_armor (+2 defense) = 4\n+        # Player 2: mage (dice=[5], attack=0) = 5\n+        # Result: knight loses (4 < 5) but takes 0 damage (1 - 2 defense = 0)\n+        from .cards import METAL_ARMOR\n+\n+        characters_p1 = init_characters()\n+        characters_p1[KNIGHT].effects = [\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ]\n+\n+        characters_p2 = init_characters()\n+\n+        ret = GamePlay(\n+            stage=BATTLE_END,\n+            active=ActivePlayer4(\n+                player=p1_name, character=KNIGHT, dice_roll=[3], result=BattleResult(winner=False, score=4)\n+            ),\n+            opponent=Opponent4(\n+                player=p2_name, character=MAGE, dice_roll=[5], result=BattleResult(winner=True, score=5)\n+            ),\n+            players={\n+                p1_name: Player(name=p1_name, characters=characters_p1),\n+                p2_name: Player(name=p2_name, characters=characters_p2),\n+            },\n+        )\n     else:\n         raise ValueError(f\"Invalid preset: {preset}\")\n \ndiff --git a/src/constants/stages.js b/src/constants/stages.js\nindex 176cc8f..08ca49d 100644\n--- a/src/constants/stages.js\n+++ b/src/constants/stages.js\n@@ -1,5 +1,6 @@\n // Stage constants - must match backend stage names in server/gameplay/models.py\n export const CHARACTER_SELECT = \"character_select\";\n+export const CARD_DRAW = \"card_draw\";\n export const ABILITY_SELECTION = \"ability_selection\";\n export const ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\";\n export const OPPONENT_SELECTION = \"opponent_selection\";"
        },
        "id": "mobile-landscape",
        "name": "mobile-landscape",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "shard": null,
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.55.1",
    "workers": 1,
    "webServer": null
  },
  "suites": [],
  "errors": [
    {
      "message": "Error: Process from config.webServer was not able to start. Exit code: 1",
      "stack": "Error: Process from config.webServer was not able to start. Exit code: 1"
    }
  ],
  "stats": {
    "startTime": "2026-01-20T03:31:14.148Z",
    "duration": 4624.273999999999,
    "expected": 0,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}