{
  "config": {
    "configFile": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/playwright.config.js",
    "rootDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
    "forbidOnly": false,
    "fullyParallel": true,
    "globalSetup": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-setup.js",
    "globalTeardown": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-teardown.js",
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/6373b30c4b3d7606c77e4c49c54a17fcb823f989",
        "commitHash": "6373b30c4b3d7606c77e4c49c54a17fcb823f989",
        "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/32",
        "prTitle": "claude/refactor-models-split-x1B0p",
        "prBaseHash": "bc60de7d36702477e5f0572e55a805bcb1aaf0d5",
        "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21114978943"
      },
      "gitCommit": {
        "shortHash": "6373b30",
        "hash": "6373b30c4b3d7606c77e4c49c54a17fcb823f989",
        "subject": "Merge c0faeb4893b7c34afa5fce22e2b80ffd444a0c53 into bc60de7d36702477e5f0572e55a805bcb1aaf0d5",
        "body": "Merge c0faeb4893b7c34afa5fce22e2b80ffd444a0c53 into bc60de7d36702477e5f0572e55a805bcb1aaf0d5\n",
        "author": {
          "name": "mark kolodkin",
          "email": "mark.kolodkin@gmail.com",
          "time": 1768753826000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1768753826000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/server/game_engine.py b/server/game_engine.py\nindex 0239156..6bcc9ba 100644\n--- a/server/game_engine.py\n+++ b/server/game_engine.py\n@@ -1,8 +1,5 @@\n-from .gameplay.models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-)\n+from .gameplay.models import GameException, ReportedException\n+from .gameplay.gameplay import GamePlay\n from .gameplay.actions import (\n     ACTION_MAP,\n )\ndiff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nnew file mode 100644\nindex 0000000..423dea5\n--- /dev/null\n+++ b/server/gameplay/abilities.py\n@@ -0,0 +1,79 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_ABILITY_MAP\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Apply to constants\n+    APPLY_TO_SELECTED_OPPONENT,\n+)\n+\n+########################################################\n+# Ability names - defined before imports from effects to avoid circular dependency\n+########################################################\n+BATTLE_HOWL = \"battle_howl\"\n+BOUNCING_ARROW = \"bouncing_arrow\"\n+FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+AbilityName = Literal[*ABILITIES_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which abilities can create which effects\n+# This is used for validation to ensure effects have valid source abilities\n+EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n+    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n+    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n+    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n+    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    SkipTurnEffect,\n+)\n+\n+\n+class Ability(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n+\n+    @property\n+    def requires_opponent_selection(self) -> bool:\n+        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n+        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n+\n+\n+ABILITIES_MAP: dict[AbilityName, Ability] = {\n+    BATTLE_HOWL: Ability(\n+        name=BATTLE_HOWL,\n+        effects=[\n+            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+        ],\n+    ),\n+    BOUNCING_ARROW: Ability(\n+        name=BOUNCING_ARROW,\n+        effects=[\n+            RerollDiceEffect(source=BOUNCING_ARROW),\n+        ],\n+    ),\n+    FREEZE: Ability(\n+        name=FREEZE,\n+        effects=[\n+            SkipTurnEffect(source=FREEZE),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 30001f1..2c1329f 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -1,6 +1,6 @@\n from typing import Dict\n \n-from ..models import (\n+from ..common import (\n     CONNECT,\n     LEAVE,\n     DISCONNECT,\n@@ -18,7 +18,7 @@ from ..models import (\n     ACTION_REROLL_EFFECT,\n     BATTLE_END_ACTION,\n     DEBUG_SET_BATTLE_DICE_ROLLS,\n-)\n+)  # Action constants stay in models.py\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\ndiff --git a/server/gameplay/actions/action.py b/server/gameplay/actions/action.py\nindex ed31d2e..5a045d4 100644\n--- a/server/gameplay/actions/action.py\n+++ b/server/gameplay/actions/action.py\n@@ -1,12 +1,12 @@\n from abc import ABC, abstractmethod\n from typing import Any, Dict, Optional\n \n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..gameplay import (\n+    StageName,\n     GamePlay,\n     Player,\n     Character,\n-    GameException,\n-    ReportedException,\n     ActivePlayer1,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -14,7 +14,6 @@ from ..models import (\n     Opponent2,\n     Opponent3,\n     Opponent4,\n-    StageName,\n )\n \n \ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex a3a8703..0d9861f 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -5,17 +5,16 @@ Ends the battle, calculates winner, and reduces loser's health by 1.\n \"\"\"\n \n from .action import Action\n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..gameplay import (\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n     GamePlay,\n-    GameException,\n-    ReportedException,\n     ActivePlayer1,\n     ActivePlayer3,\n     ActivePlayer4,\n     Opponent3,\n     Opponent4,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n )\n \n \n@@ -61,7 +60,7 @@ class BattleEndAction(Action):\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n-        from ..models import BATTLE_END_ACTION\n+        from ..common import BATTLE_END_ACTION\n \n         def should_keep_effect(effect):\n             \"\"\"Returns True if effect should be kept after battle\"\"\"\ndiff --git a/server/gameplay/actions/connection.py b/server/gameplay/actions/connection.py\nindex 00d4729..43b082e 100644\n--- a/server/gameplay/actions/connection.py\n+++ b/server/gameplay/actions/connection.py\n@@ -1,20 +1,22 @@\n from typing import Dict\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    Player,\n-    Character,\n-    ActivePlayer1,\n-    CHARACTER_DEFAULT_STATS,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n+)\n+from ..gameplay import (\n     CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer1,\n+    CHARACTER_DEFAULT_STATS,\n )\n \n MAX_PLAYERS = 4\ndiff --git a/server/gameplay/actions/stage_ability_opponent_selection.py b/server/gameplay/actions/stage_ability_opponent_selection.py\nindex b880404..5985c08 100644\n--- a/server/gameplay/actions/stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/stage_ability_opponent_selection.py\n@@ -7,14 +7,8 @@ This module implements actions for the ability opponent selection stage:\n \"\"\"\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    Opponent2,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-)\n+from ..common import GameException, ReportedException\n+from ..gameplay import ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class AbilityOpponentPressAction(Action):\ndiff --git a/server/gameplay/actions/stage_ability_selection.py b/server/gameplay/actions/stage_ability_selection.py\nindex 4d5a556..af35bf2 100644\n--- a/server/gameplay/actions/stage_ability_selection.py\n+++ b/server/gameplay/actions/stage_ability_selection.py\n@@ -9,17 +9,11 @@ This module implements actions for the ability selection stage:\n \n import copy\n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    AbilitySelectMeta,\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    APPLY_TO_SELF,\n-    AbilityName,\n-)\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF\n+from ..abilities import AbilityName\n+from ..gameplay import ABILITY_SELECTION, ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION\n+from ..gameplay import GamePlay, AbilitySelectMeta\n \n \n class AbilityPressAction(Action):\ndiff --git a/server/gameplay/actions/stage_battle.py b/server/gameplay/actions/stage_battle.py\nindex 824d737..a8fe573 100644\n--- a/server/gameplay/actions/stage_battle.py\n+++ b/server/gameplay/actions/stage_battle.py\n@@ -10,20 +10,19 @@ This module implements actions for the battle stage:\n \n import random\n from .action import Action\n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..effects import RerollDiceEffect\n+from ..gameplay import (\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n     GamePlay,\n-    GameException,\n-    ReportedException,\n     ActivePlayer2,\n     ActivePlayer3,\n     ActivePlayer4,\n     Opponent2,\n     Opponent3,\n     Opponent4,\n-    RerollDiceEffect,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n )\n \n \n@@ -73,7 +72,7 @@ def set_winner_if_both_rolled(game: GamePlay) -> None:\n     opponent_is_winner = opponent_score > active_score\n \n     # Import BattleResult at top of function to avoid circular imports\n-    from ..models import BattleResult\n+    from ..gameplay import BattleResult\n \n     # Upgrade to ActivePlayer4 and Opponent4 with result fields\n     game.active = ActivePlayer4(\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 6687b83..474748e 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -7,16 +7,18 @@ This module implements actions for the character selection stage:\n \"\"\"\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n+from ..common import (\n     GameException,\n     ReportedException,\n+    CHARACTER_SELECT_ACTION,\n+)\n+from ..gameplay import (\n+    ABILITY_SELECTION,\n+    CHARACTER_SELECT,\n+    GamePlay,\n     CharacterSelectMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n-    ABILITY_SELECTION,\n-    CHARACTER_SELECT,\n-    CHARACTER_SELECT_ACTION,\n )\n \n \ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex 3404bb1..ff48b63 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -8,15 +8,9 @@ This module implements actions for the opponent selection stage:\n \n import copy\n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    Opponent2,\n-    BATTLE_DICE_ROLL,\n-    OPPONENT_SELECTION,\n-    APPLY_TO_BATTLE_OPPONENT,\n-)\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_BATTLE_OPPONENT\n+from ..gameplay import BATTLE_DICE_ROLL, OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class OpponentPressAction(Action):\ndiff --git a/server/gameplay/actions/test_action_properties.py b/server/gameplay/actions/test_action_properties.py\nindex f015215..858c847 100644\n--- a/server/gameplay/actions/test_action_properties.py\n+++ b/server/gameplay/actions/test_action_properties.py\n@@ -7,7 +7,10 @@ These tests verify that action properties work correctly across different game s\n import pytest\n \n from .action import Action\n-from ..models import (\n+from ..common import GameException, KNIGHT, MAGE, ARCHER\n+from ..gameplay import (\n+    BATTLE_DICE_ROLL,\n+    CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     ActivePlayer1,\n@@ -18,12 +21,6 @@ from ..models import (\n     Opponent3,\n     Opponent4,\n     BattleResult,\n-    GameException,\n-    BATTLE_DICE_ROLL,\n-    CHARACTER_SELECT,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n     init_characters,\n     KNIGHT_L1_DEFAULT_HEALTH,\n     KNIGHT_L1_DICE,\ndiff --git a/server/gameplay/actions/test_connect_action.py b/server/gameplay/actions/test_connect_action.py\nindex bd27db1..1629a64 100644\n--- a/server/gameplay/actions/test_connect_action.py\n+++ b/server/gameplay/actions/test_connect_action.py\n@@ -8,19 +8,21 @@ reconnections, game capacity limits, and character initialization.\n import pytest\n \n from .connection import ConnectAction, MAX_PLAYERS\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Character,\n-    ActivePlayer1,\n+from ..common import (\n     ReportedException,\n-    CHARACTER_DEFAULT_STATS,\n-    CHARACTER_SELECT,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n+)\n+from ..gameplay import (\n+    CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer1,\n+    CHARACTER_DEFAULT_STATS,\n     ARCHER_L1_ATTACK,\n     MAGE_L1_ATTACK,\n )\ndiff --git a/server/gameplay/actions/test_connection_integration.py b/server/gameplay/actions/test_connection_integration.py\nindex dd899ae..e63bdab 100644\n--- a/server/gameplay/actions/test_connection_integration.py\n+++ b/server/gameplay/actions/test_connection_integration.py\n@@ -9,12 +9,8 @@ and leaving actions.\n import pytest\n \n from .connection import ConnectAction, DisconnectAction, LeaveAction\n-from ..models import (\n-    GamePlay,\n-    CHARACTER_SELECT,\n-    CONNECTED,\n-    DISCONNECTED,\n-)\n+from ..common import CONNECTED, DISCONNECTED\n+from ..gameplay import CHARACTER_SELECT, GamePlay\n \n \n def test_connect_then_disconnect_then_reconnect():\ndiff --git a/server/gameplay/actions/test_disconnect_action.py b/server/gameplay/actions/test_disconnect_action.py\nindex aad505f..2337f53 100644\n--- a/server/gameplay/actions/test_disconnect_action.py\n+++ b/server/gameplay/actions/test_disconnect_action.py\n@@ -8,18 +8,20 @@ existing players, nonexistent players, and already disconnected players.\n import pytest\n \n from .connection import DisconnectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Character,\n+from ..common import (\n     GameException,\n-    CHARACTER_DEFAULT_STATS,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n )\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    Character,\n+    CHARACTER_DEFAULT_STATS,\n+)\n \n \n def test_disconnect_action_existing_player():\ndiff --git a/server/gameplay/actions/test_leave_action.py b/server/gameplay/actions/test_leave_action.py\nindex cdf2e8a..e67ef2e 100644\n--- a/server/gameplay/actions/test_leave_action.py\n+++ b/server/gameplay/actions/test_leave_action.py\n@@ -9,15 +9,12 @@ the only player leaving.\n import pytest\n \n from .connection import LeaveAction\n-from ..models import (\n+from ..common import GameException, KNIGHT, ARCHER, MAGE\n+from ..gameplay import (\n     GamePlay,\n     Player,\n     Character,\n-    GameException,\n     CHARACTER_DEFAULT_STATS,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n )\n \n \ndiff --git a/server/gameplay/actions/test_stage_ability_opponent_selection.py b/server/gameplay/actions/test_stage_ability_opponent_selection.py\nindex c25173c..75dfb7d 100644\n--- a/server/gameplay/actions/test_stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_opponent_selection.py\n@@ -8,20 +8,15 @@ selected opponents for ability targeting and confirming selections to apply effe\n import pytest\n \n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n-from ..models import (\n+from ..common import GameException, ReportedException, KNIGHT, MAGE\n+from ..abilities import BATTLE_HOWL, FREEZE, ABILITIES_MAP\n+from ..gameplay import (\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n     GamePlay,\n     Player,\n     ActivePlayer2,\n-    GameException,\n-    ReportedException,\n     Opponent2,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    KNIGHT,\n-    MAGE,\n-    BATTLE_HOWL,\n-    FREEZE,\n-    ABILITIES_MAP,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_ability_selection.py b/server/gameplay/actions/test_stage_ability_selection.py\nindex 9e3b7df..b3c0106 100644\n--- a/server/gameplay/actions/test_stage_ability_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_selection.py\n@@ -10,24 +10,26 @@ selected abilities and confirming selections to transition to:\n import pytest\n \n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer2,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    RerollDiceEffect,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..effects import REROLL_DICE\n+from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..gameplay import (\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n     CHARACTER_SELECT,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n-    REROLL_DICE,\n+)\n+from ..effects import RerollDiceEffect\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer2,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_battle_dice_roll.py b/server/gameplay/actions/test_stage_battle_dice_roll.py\nindex 08d71b9..bbc80fd 100644\n--- a/server/gameplay/actions/test_stage_battle_dice_roll.py\n+++ b/server/gameplay/actions/test_stage_battle_dice_roll.py\n@@ -16,32 +16,36 @@ from .stage_battle import (\n     calculate_winner,\n     set_winner_if_both_rolled,\n )\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer1,\n-    ActivePlayer2,\n-    ActivePlayer3,\n-    ActivePlayer4,\n-    Opponent2,\n-    Opponent3,\n-    Opponent4,\n+from ..common import (\n     GameException,\n     ReportedException,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n+)\n+from ..gameplay import (\n     BATTLE_DICE_ROLL,\n     BATTLE_END,\n     CHARACTER_SELECT,\n     OPPONENT_SELECTION,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n+)\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer1,\n+    ActivePlayer2,\n+    ActivePlayer3,\n+    ActivePlayer4,\n+    Opponent2,\n+    Opponent3,\n+    Opponent4,\n     init_characters,\n )\n from ..presets import get_debug_preset, EFFECT_REROLL\ndiff --git a/server/gameplay/actions/test_stage_battle_end.py b/server/gameplay/actions/test_stage_battle_end.py\nindex 7c0e543..996f74f 100644\n--- a/server/gameplay/actions/test_stage_battle_end.py\n+++ b/server/gameplay/actions/test_stage_battle_end.py\n@@ -13,25 +13,22 @@ Effect disposal rules:\n import pytest\n \n from .battle_end import BattleEndAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer4,\n-    Opponent4,\n-    BattleResult,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    AttackNegBonusEffect,\n-    SkipTurnEffect,\n-    RerollDiceEffect,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n     KNIGHT,\n     MAGE,\n     ARCHER,\n-    BATTLE_HOWL,\n-    FREEZE,\n-    BOUNCING_ARROW,\n+)\n+from ..abilities import BATTLE_HOWL, FREEZE, BOUNCING_ARROW\n+from ..gameplay import BATTLE_END, CHARACTER_SELECT\n+from ..effects import AttackNegBonusEffect, SkipTurnEffect, RerollDiceEffect\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer4,\n+    Opponent4,\n+    BattleResult,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_character_select.py b/server/gameplay/actions/test_stage_character_select.py\nindex 9c65b90..cd8722f 100644\n--- a/server/gameplay/actions/test_stage_character_select.py\n+++ b/server/gameplay/actions/test_stage_character_select.py\n@@ -8,24 +8,25 @@ selected characters and confirming selections to transition to battle.\n import pytest\n \n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n-from ..models import (\n+from ..common import (\n+    GameException,\n+    ReportedException,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..abilities import FREEZE, BATTLE_HOWL\n+from ..effects import SkipTurnEffect\n+from ..gameplay import (\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    BATTLE_DICE_ROLL,\n     GamePlay,\n     Player,\n     Character,\n     ActivePlayer1,\n     ActivePlayer2,\n-    GameException,\n-    ReportedException,\n-    SkipTurnEffect,\n     CHARACTER_DEFAULT_STATS,\n-    CHARACTER_SELECT,\n-    ABILITY_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    FREEZE,\n-    BATTLE_HOWL,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_opponent_selection.py b/server/gameplay/actions/test_stage_opponent_selection.py\nindex dae8343..9ee53b4 100644\n--- a/server/gameplay/actions/test_stage_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_opponent_selection.py\n@@ -8,25 +8,25 @@ selected opponents and confirming selections to transition to battle.\n import pytest\n \n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Ability,\n-    Character,\n-    ActivePlayer2,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    Opponent2,\n-    AttackNegBonusEffect,\n-    CHARACTER_DEFAULT_STATS,\n-    OPPONENT_SELECTION,\n-    BATTLE_DICE_ROLL,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n-    BATTLE_HOWL,\n     ATTACK_NEG_BONUS,\n-    ABILITIES_MAP,\n+)\n+from ..abilities import Ability, BATTLE_HOWL, ABILITIES_MAP\n+from ..effects import AttackNegBonusEffect\n+from ..gameplay import (\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer2,\n+    Opponent2,\n+    CHARACTER_DEFAULT_STATS,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/common.py b/server/gameplay/common.py\nnew file mode 100644\nindex 0000000..0f5d9c3\n--- /dev/null\n+++ b/server/gameplay/common.py\n@@ -0,0 +1,134 @@\n+\"\"\"\n+Base models and utilities - foundation for effects, abilities, and gameplay modules.\n+\"\"\"\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import BaseModel, ConfigDict\n+\n+\n+########################################################\n+# Connection statuses\n+########################################################\n+CONNECTED = \"connected\"\n+DISCONNECTED = \"disconnected\"\n+CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n+ConnectionStatus = Literal[*CONNECTION_STATUSES]\n+\n+########################################################\n+# Character types\n+########################################################\n+KNIGHT = \"knight\"\n+ARCHER = \"archer\"\n+MAGE = \"mage\"\n+CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n+ChatacterType = Literal[*CHARACTER_TYPES]\n+\n+########################################################\n+# Actions\n+########################################################\n+CONNECT = \"connect\"\n+LEAVE = \"leave\"\n+DISCONNECT = \"disconnect\"\n+CHARACTER_PRESS = \"character_press\"\n+CHARACTER_SELECT_ACTION = \"character_select\"\n+ABILITY_PRESS = \"ability_press\"\n+ABILITY_SELECT = \"ability_select\"\n+ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n+ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n+OPPONENT_PRESS = \"opponent_press\"\n+OPPONENT_SELECT = \"opponent_select\"\n+ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n+OPPONENT_ROLL = \"opponent_roll\"\n+ACTION_REROLL = \"action_reroll\"\n+ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n+BATTLE_END_ACTION = \"battle_end\"\n+DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n+\n+ACTION_NAMES = [\n+    CONNECT,\n+    LEAVE,\n+    DISCONNECT,\n+    CHARACTER_PRESS,\n+    CHARACTER_SELECT_ACTION,\n+    ABILITY_PRESS,\n+    ABILITY_SELECT,\n+    ABILITY_OPPONENT_PRESS,\n+    ABILITY_OPPONENT_SELECT,\n+    OPPONENT_PRESS,\n+    OPPONENT_SELECT,\n+    ACTIVE_PLAYER_ROLL,\n+    OPPONENT_ROLL,\n+    ACTION_REROLL,\n+    ACTION_REROLL_EFFECT,\n+    BATTLE_END_ACTION,\n+    DEBUG_SET_BATTLE_DICE_ROLLS,\n+]\n+ActionName = Literal[*ACTION_NAMES]\n+\n+\n+########################################################\n+# Exceptions\n+########################################################\n+class GameException(Exception):\n+    pass\n+\n+\n+class ReportedException(GameException):\n+    pass\n+\n+\n+########################################################\n+# Base model utilities\n+########################################################\n+def recursive_db_model_dump(model: BaseModel) -> dict:\n+    \"\"\"\n+    Recursively dump model for database storage.\n+    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n+    \"\"\"\n+    result = {}\n+\n+    # Iterate over all fields and their values\n+    for field_name, field_value in model:\n+        if isinstance(field_value, BaseModel):\n+            # Nested model - call its db_model_dump if it's a StrictModel\n+            if hasattr(field_value, \"db_model_dump\"):\n+                result[field_name] = field_value.db_model_dump()\n+            else:\n+                result[field_name] = field_value.model_dump()\n+        elif isinstance(field_value, dict):\n+            # Dict of values (possibly models)\n+            result[field_name] = {\n+                k: (\n+                    v.db_model_dump()\n+                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n+                    else v.model_dump() if isinstance(v, BaseModel) else v\n+                )\n+                for k, v in field_value.items()\n+            }\n+        elif isinstance(field_value, (list, tuple, set)):\n+            # Collection of values (possibly models) - preserve collection type\n+            processed_items = [\n+                (\n+                    item.db_model_dump()\n+                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n+                    else item.model_dump() if isinstance(item, BaseModel) else item\n+                )\n+                for item in field_value\n+            ]\n+            # Preserve the original collection type\n+            result[field_name] = type(field_value)(processed_items)\n+        else:\n+            # Primitive value\n+            result[field_name] = field_value\n+\n+    return result\n+\n+\n+class StrictModel(BaseModel):\n+    model_config = ConfigDict(extra=\"forbid\")\n+\n+    def db_model_dump(self) -> dict:\n+        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n+        return recursive_db_model_dump(self)\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nnew file mode 100644\nindex 0000000..c8526fa\n--- /dev/null\n+++ b/server/gameplay/effects.py\n@@ -0,0 +1,145 @@\n+from __future__ import annotations\n+\n+from typing import Literal, Annotated, Union, Self\n+\n+from pydantic import Field, model_validator\n+\n+from .common import (\n+    StrictModel,\n+    ActionName,\n+    # Action name constants for dispose_actions\n+    CHARACTER_SELECT_ACTION,\n+    BATTLE_END_ACTION,\n+    ACTION_REROLL_EFFECT,\n+)\n+\n+########################################################\n+# Effect names\n+########################################################\n+ATTACK_BONUS = \"attack_bonus\"\n+ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+REROLL_DICE = \"reroll_dice\"\n+SKIP_TURN = \"skip_turn\"\n+DRAW_CARD = \"draw_card\"\n+\n+########################################################\n+# Effect apply_to targets\n+########################################################\n+APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n+APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n+APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n+\n+APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n+ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n+\n+\n+class Effect(StrictModel):\n+    \"\"\"\n+    Base class for all effects.\n+    Each effect specifies when it should be disposed via dispose_actions field.\n+    Each effect specifies who receives the effect via apply_to field.\n+    \"\"\"\n+\n+    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n+    source: str  # AbilityName - using str to avoid circular import\n+    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n+    apply_to: ApplyToTarget  # Who receives this effect\n+\n+    @model_validator(mode=\"after\")\n+    def validate_source(self) -> Self:\n+        \"\"\"Validate that source is valid for this effect type\"\"\"\n+        # Lazy import to avoid circular dependency\n+        from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n+\n+        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        if self.source not in valid_sources and len(valid_sources) > 0:\n+            raise ValueError(\n+                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n+                f\"Valid sources: {valid_sources}\"\n+            )\n+        return self\n+\n+\n+class SkipTurnEffect(Effect):\n+    \"\"\"\n+    Character can't participate in the next turn.\n+    Disposed after character selection.\n+    Applied to selected opponent (requires ability_opponent_selection stage).\n+    \"\"\"\n+\n+    name: Literal[SKIP_TURN] = SKIP_TURN\n+    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n+    skip_next_turn: bool = True\n+\n+\n+class AttackBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is increased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    attack_bonus: int\n+\n+\n+class RerollDiceEffect(Effect):\n+    \"\"\"\n+    Character's dice are rerolled if lost the battle.\n+    Disposed at battle end or when the reroll effect action is used.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[REROLL_DICE] = REROLL_DICE\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    reroll_dice: bool = True\n+\n+\n+class AttackNegBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is decreased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to battle opponent (no separate selection required).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n+    attack_neg_bonus: int\n+\n+\n+class DrawCardEffect(Effect):\n+    \"\"\"\n+    Character draws cards at the start of battle.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DRAW_CARD] = DRAW_CARD\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    draw_count: int = 1\n+\n+\n+# Define EffectUnion for discriminated union of all effect types (without base classes)\n+EffectUnion = Annotated[\n+    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Field(discriminator=\"name\"),\n+]\n+\n+\n+class EffectTotal(StrictModel):\n+    \"\"\"\n+    Aggregated effect totals for a character.\n+    Combines all active effects into a single summary.\n+    \"\"\"\n+\n+    attack_bonus: int = 0\n+    attack_neg_bonus: int = 0\n+    skip_next_turn: bool = False\n+    reroll_dice_available: bool = False\n+    draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nnew file mode 100644\nindex 0000000..937d1f7\n--- /dev/null\n+++ b/server/gameplay/gameplay.py\n@@ -0,0 +1,254 @@\n+from __future__ import annotations\n+\n+from typing import Dict, Literal, Optional\n+\n+from pydantic import Field, computed_field\n+\n+from .common import (\n+    StrictModel,\n+    ConnectionStatus,\n+    ChatacterType,\n+    CONNECTED,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+\n+########################################################\n+# Stages\n+########################################################\n+CHARACTER_SELECT = \"character_select\"\n+ABILITY_SELECTION = \"ability_selection\"\n+ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n+OPPONENT_SELECTION = \"opponent_selection\"\n+BATTLE_DICE_ROLL = \"battle_dice_roll\"\n+BATTLE_END = \"battle_end\"\n+STAGES_NAMES = [\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+]\n+StageName = Literal[*STAGES_NAMES]\n+\n+from .abilities import (\n+    Ability,\n+    ABILITIES_MAP,\n+    AbilityName,\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+)\n+from .effects import (\n+    EffectUnion,\n+    EffectTotal,\n+    AttackBonusEffect,\n+    AttackNegBonusEffect,\n+    SkipTurnEffect,\n+    RerollDiceEffect,\n+    DrawCardEffect,\n+)\n+\n+\n+class Character(StrictModel):\n+\n+    level: int\n+    health: int\n+    max_health: int\n+    dice: int\n+    attack: int\n+    abilities: list[Ability] = Field(default_factory=list)\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+    @computed_field\n+    @property\n+    def is_alive(self) -> bool:\n+        \"\"\"Character is alive if health > 0\"\"\"\n+        return self.health > 0\n+\n+    @computed_field\n+    @property\n+    def effect(self) -> EffectTotal:\n+        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n+        total = EffectTotal()\n+\n+        for eff in self.effects:\n+            if isinstance(eff, AttackBonusEffect):\n+                total.attack_bonus += eff.attack_bonus\n+            elif isinstance(eff, AttackNegBonusEffect):\n+                total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, SkipTurnEffect):\n+                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n+            elif isinstance(eff, RerollDiceEffect):\n+                total.reroll_dice_available = True\n+            elif isinstance(eff, DrawCardEffect):\n+                total.draw_card_count += eff.draw_count\n+\n+        return total\n+\n+    def db_model_dump(self) -> dict:\n+        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n+\n+\n+class CharacterSelectMeta(StrictModel):\n+    \"\"\"Stage metadata for character selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted character\n+\n+\n+class AbilitySelectMeta(StrictModel):\n+    \"\"\"Stage metadata for ability selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted ability\n+\n+\n+class ActivePlayer1(StrictModel):\n+    \"\"\"Selected character for battle\"\"\"\n+\n+    player: str  # Character name\n+\n+\n+class BattleResult(StrictModel):\n+    winner: bool\n+    score: int  # result of the battle, sum of dice_roll and attack\n+\n+\n+class ActivePlayer2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class ActivePlayer3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class ActivePlayer4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n+\n+\n+class Opponent2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class Opponent3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class Opponent4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+Opponent = Opponent2 | Opponent3 | Opponent4\n+\n+\n+class Player(StrictModel):\n+    name: str\n+    status: ConnectionStatus = CONNECTED\n+    cards: list[str] = Field(default_factory=list)\n+    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n+\n+\n+########################################################\n+# GamePlay model\n+########################################################\n+class GamePlay(StrictModel):\n+    stage: StageName = CHARACTER_SELECT\n+    players: dict[str, Player] = Field(default_factory=dict)\n+    active: Optional[ActivePlayer] = None  # The active player and its selections\n+    ability: Optional[Ability] = None  # Selected ability\n+    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n+    opponent: Optional[Opponent] = None  # Selected opponent for battle\n+    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+\n+    def reorder_players(self, username: str):\n+        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n+        if username not in self.players:\n+            return\n+\n+        # Get all player keys\n+        player_keys = list(self.players.keys())\n+\n+        # Find the index of the username\n+        user_index = player_keys.index(username)\n+\n+        # Circular shift: username first, then the rest\n+        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n+\n+        # Build new dict with reordered keys\n+        reordered_dict = {key: self.players[key] for key in reordered_keys}\n+\n+        # Update in-place\n+        self.players.clear()\n+        self.players.update(reordered_dict)\n+\n+\n+DEFAULT_GAME = GamePlay()\n+\n+########################################################\n+# Character default stats\n+########################################################\n+KNIGHT_L1_DEFAULT_HEALTH = 2\n+KNIGHT_L1_MAX_HEALTH = 2\n+KNIGHT_L1_DICE = 1\n+KNIGHT_L1_ATTACK = 1\n+KNIGHT_L1_ABILITY = BATTLE_HOWL\n+\n+ARCHER_L1_DEFAULT_HEALTH = 3\n+ARCHER_L1_MAX_HEALTH = 3\n+ARCHER_L1_DICE = 1\n+ARCHER_L1_ATTACK = 0\n+ARCHER_L1_ABILITY = BOUNCING_ARROW\n+\n+MAGE_L1_DEFAULT_HEALTH = 2\n+MAGE_L1_MAX_HEALTH = 2\n+MAGE_L1_DICE = 1\n+MAGE_L1_ATTACK = 0\n+MAGE_L1_ABILITY = FREEZE\n+\n+CHARACTER_DEFAULT_STATS = {\n+    \"knight\": {\n+        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n+        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n+        \"dice\": KNIGHT_L1_DICE,\n+        \"attack\": KNIGHT_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n+    },\n+    \"archer\": {\n+        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n+        \"max_health\": ARCHER_L1_MAX_HEALTH,\n+        \"dice\": ARCHER_L1_DICE,\n+        \"attack\": ARCHER_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n+    },\n+    \"mage\": {\n+        \"health\": MAGE_L1_DEFAULT_HEALTH,\n+        \"max_health\": MAGE_L1_MAX_HEALTH,\n+        \"dice\": MAGE_L1_DICE,\n+        \"attack\": MAGE_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n+    },\n+}\n+\n+\n+def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n+    \"\"\"Initialize all character types with default stats\"\"\"\n+    return {\n+        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n+        for char_type in [KNIGHT, ARCHER, MAGE]\n+    }\ndiff --git a/server/gameplay/models.py b/server/gameplay/models.py\ndeleted file mode 100644\nindex d8a1106..0000000\n--- a/server/gameplay/models.py\n+++ /dev/null\n@@ -1,512 +0,0 @@\n-from typing import Dict, Optional, Literal, Annotated, Union, Self\n-\n-from pydantic import BaseModel, ConfigDict, Field, computed_field, Discriminator, model_validator\n-\n-########################################################\n-# Connection statuses\n-########################################################\n-CONNECTED = \"connected\"\n-DISCONNECTED = \"disconnected\"\n-CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n-ConnectionStatus = Literal[*CONNECTION_STATUSES]\n-\n-########################################################\n-# Stages\n-########################################################\n-CHARACTER_SELECT = \"character_select\"\n-ABILITY_SELECTION = \"ability_selection\"\n-ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n-OPPONENT_SELECTION = \"opponent_selection\"\n-BATTLE_DICE_ROLL = \"battle_dice_roll\"\n-BATTLE_END = \"battle_end\"\n-STAGES_NAMES = [\n-    CHARACTER_SELECT,\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-]\n-StageName = Literal[*STAGES_NAMES]\n-\n-########################################################\n-# Character types\n-########################################################\n-KNIGHT = \"knight\"\n-ARCHER = \"archer\"\n-MAGE = \"mage\"\n-CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n-ChatacterType = Literal[*CHARACTER_TYPES]\n-\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n-AbilityName = Literal[*ABILITIES_NAMES]\n-\n-# Effect names\n-ATTACK_BONUS = \"attack_bonus\"\n-ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n-REROLL_DICE = \"reroll_dice\"\n-SKIP_TURN = \"skip_turn\"\n-DRAW_CARD = \"draw_card\"\n-\n-# Effect apply_to targets - specifies who receives the effect\n-APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n-APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n-APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n-\n-APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n-ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n-\n-# Effect-to-Source mapping: defines which abilities can create which effects\n-# This is used for validation to ensure effects have valid source abilities\n-EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n-}\n-\n-########################################################\n-# Actions\n-########################################################\n-CONNECT = \"connect\"\n-LEAVE = \"leave\"\n-DISCONNECT = \"disconnect\"\n-CHARACTER_PRESS = \"character_press\"\n-CHARACTER_SELECT_ACTION = \"character_select\"\n-ABILITY_PRESS = \"ability_press\"\n-ABILITY_SELECT = \"ability_select\"\n-ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n-ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n-OPPONENT_PRESS = \"opponent_press\"\n-OPPONENT_SELECT = \"opponent_select\"\n-ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n-OPPONENT_ROLL = \"opponent_roll\"\n-ACTION_REROLL = \"action_reroll\"\n-ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n-BATTLE_END_ACTION = \"battle_end\"\n-DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n-\n-ACTION_NAMES = [\n-    CONNECT,\n-    LEAVE,\n-    DISCONNECT,\n-    CHARACTER_PRESS,\n-    CHARACTER_SELECT_ACTION,\n-    ABILITY_PRESS,\n-    ABILITY_SELECT,\n-    ABILITY_OPPONENT_PRESS,\n-    ABILITY_OPPONENT_SELECT,\n-    OPPONENT_PRESS,\n-    OPPONENT_SELECT,\n-    ACTIVE_PLAYER_ROLL,\n-    OPPONENT_ROLL,\n-    ACTION_REROLL,\n-    ACTION_REROLL_EFFECT,\n-    BATTLE_END_ACTION,\n-    DEBUG_SET_BATTLE_DICE_ROLLS,\n-]\n-ActionName = Literal[*ACTION_NAMES]\n-\n-\n-class GameException(Exception):\n-    pass\n-\n-\n-class ReportedException(GameException):\n-    pass\n-\n-\n-def recursive_db_model_dump(model: BaseModel) -> dict:\n-    \"\"\"\n-    Recursively dump model for database storage.\n-    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n-    \"\"\"\n-    result = {}\n-\n-    # Iterate over all fields and their values\n-    for field_name, field_value in model:\n-        if isinstance(field_value, BaseModel):\n-            # Nested model - call its db_model_dump if it's a StrictModel\n-            if hasattr(field_value, \"db_model_dump\"):\n-                result[field_name] = field_value.db_model_dump()\n-            else:\n-                result[field_name] = field_value.model_dump()\n-        elif isinstance(field_value, dict):\n-            # Dict of values (possibly models)\n-            result[field_name] = {\n-                k: (\n-                    v.db_model_dump()\n-                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n-                    else v.model_dump() if isinstance(v, BaseModel) else v\n-                )\n-                for k, v in field_value.items()\n-            }\n-        elif isinstance(field_value, (list, tuple, set)):\n-            # Collection of values (possibly models) - preserve collection type\n-            processed_items = [\n-                (\n-                    item.db_model_dump()\n-                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n-                    else item.model_dump() if isinstance(item, BaseModel) else item\n-                )\n-                for item in field_value\n-            ]\n-            # Preserve the original collection type\n-            result[field_name] = type(field_value)(processed_items)\n-        else:\n-            # Primitive value\n-            result[field_name] = field_value\n-\n-    return result\n-\n-\n-class StrictModel(BaseModel):\n-    model_config = ConfigDict(extra=\"forbid\")\n-\n-    def db_model_dump(self) -> dict:\n-        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n-        return recursive_db_model_dump(self)\n-\n-\n-class Effect(StrictModel):\n-    \"\"\"\n-    Base class for all effects.\n-    Each effect specifies when it should be disposed via dispose_actions field.\n-    Each effect specifies who receives the effect via apply_to field.\n-    \"\"\"\n-\n-    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n-    source: AbilityName\n-    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n-    apply_to: ApplyToTarget  # Who receives this effect\n-\n-    @model_validator(mode=\"after\")\n-    def validate_source(self) -> Self:\n-        \"\"\"Validate that source is valid for this effect type\"\"\"\n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n-        if self.source not in valid_sources and len(valid_sources) > 0:\n-            raise ValueError(\n-                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n-                f\"Valid sources: {valid_sources}\"\n-            )\n-        return self\n-\n-\n-class SkipTurnEffect(Effect):\n-    \"\"\"\n-    Character can't participate in the next turn.\n-    Disposed after character selection.\n-    Applied to selected opponent (requires ability_opponent_selection stage).\n-    \"\"\"\n-\n-    name: Literal[SKIP_TURN] = SKIP_TURN\n-    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n-    skip_next_turn: bool = True\n-\n-\n-class AttackBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is increased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    attack_bonus: int\n-\n-\n-class RerollDiceEffect(Effect):\n-    \"\"\"\n-    Character's dice are rerolled if lost the battle.\n-    Disposed at battle end or when the reroll effect action is used.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[REROLL_DICE] = REROLL_DICE\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    reroll_dice: bool = True\n-\n-\n-class AttackNegBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is decreased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to battle opponent (no separate selection required).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n-    attack_neg_bonus: int\n-\n-\n-class DrawCardEffect(Effect):\n-    \"\"\"\n-    Character draws cards at the start of battle.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[DRAW_CARD] = DRAW_CARD\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    draw_count: int = 1\n-\n-\n-# Define EffectUnion for discriminated union of all effect types (without base classes)\n-EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n-    Field(discriminator=\"name\"),\n-]\n-\n-\n-class Ability(StrictModel):\n-    name: str\n-    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n-\n-    @property\n-    def requires_opponent_selection(self) -> bool:\n-        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n-        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n-\n-\n-class EffectTotal(StrictModel):\n-    \"\"\"\n-    Aggregated effect totals for a character.\n-    Combines all active effects into a single summary.\n-    \"\"\"\n-\n-    attack_bonus: int = 0\n-    attack_neg_bonus: int = 0\n-    skip_next_turn: bool = False\n-    reroll_dice_available: bool = False\n-    draw_card_count: int = 0\n-\n-\n-ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n-        effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n-        ],\n-    ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n-        effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n-        ],\n-    ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n-        effects=[\n-            SkipTurnEffect(source=FREEZE),\n-        ],\n-    ),\n-}\n-\n-\n-class Character(StrictModel):\n-\n-    level: int\n-    health: int\n-    max_health: int\n-    dice: int\n-    attack: int\n-    abilities: list[Ability] = Field(default_factory=list)\n-    effects: list[EffectUnion] = Field(default_factory=list)\n-\n-    @computed_field\n-    @property\n-    def is_alive(self) -> bool:\n-        \"\"\"Character is alive if health > 0\"\"\"\n-        return self.health > 0\n-\n-    @computed_field\n-    @property\n-    def effect(self) -> EffectTotal:\n-        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n-        total = EffectTotal()\n-\n-        for eff in self.effects:\n-            if isinstance(eff, AttackBonusEffect):\n-                total.attack_bonus += eff.attack_bonus\n-            elif isinstance(eff, AttackNegBonusEffect):\n-                total.attack_neg_bonus += eff.attack_neg_bonus\n-            elif isinstance(eff, SkipTurnEffect):\n-                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n-            elif isinstance(eff, RerollDiceEffect):\n-                total.reroll_dice_available = True\n-            elif isinstance(eff, DrawCardEffect):\n-                total.draw_card_count += eff.draw_count\n-\n-        return total\n-\n-    def db_model_dump(self) -> dict:\n-        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n-\n-\n-class CharacterSelectMeta(StrictModel):\n-    \"\"\"Stage metadata for character selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted character\n-\n-\n-class AbilitySelectMeta(StrictModel):\n-    \"\"\"Stage metadata for ability selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted ability\n-\n-\n-class ActivePlayer1(StrictModel):\n-    \"\"\"Selected character for battle\"\"\"\n-\n-    player: str  # Character name\n-\n-\n-class BattleResult(StrictModel):\n-    winner: bool\n-    score: int  # result of the battle, sum of dice_roll and attack\n-\n-\n-class ActivePlayer2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class ActivePlayer3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class ActivePlayer4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n-\n-\n-class Opponent2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class Opponent3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class Opponent4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-Opponent = Opponent2 | Opponent3 | Opponent4\n-\n-\n-class Player(StrictModel):\n-    name: str\n-    status: ConnectionStatus = CONNECTED\n-    cards: list[str] = Field(default_factory=list)\n-    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n-\n-\n-########################################################\n-# GamePlay model\n-########################################################\n-class GamePlay(StrictModel):\n-    stage: StageName = CHARACTER_SELECT\n-    players: dict[str, Player] = Field(default_factory=dict)\n-    active: Optional[ActivePlayer] = None  # The active player and its selections\n-    ability: Optional[Ability] = None  # Selected ability\n-    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n-    opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n-\n-    def reorder_players(self, username: str):\n-        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n-        if username not in self.players:\n-            return\n-\n-        # Get all player keys\n-        player_keys = list(self.players.keys())\n-\n-        # Find the index of the username\n-        user_index = player_keys.index(username)\n-\n-        # Circular shift: username first, then the rest\n-        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n-\n-        # Build new dict with reordered keys\n-        reordered_dict = {key: self.players[key] for key in reordered_keys}\n-\n-        # Update in-place\n-        self.players.clear()\n-        self.players.update(reordered_dict)\n-\n-\n-DEFAULT_GAME = GamePlay()\n-\n-KNIGHT_L1_DEFAULT_HEALTH = 2\n-KNIGHT_L1_MAX_HEALTH = 2\n-KNIGHT_L1_DICE = 1\n-KNIGHT_L1_ATTACK = 1\n-KNIGHT_L1_ABILITY = BATTLE_HOWL\n-\n-ARCHER_L1_DEFAULT_HEALTH = 3\n-ARCHER_L1_MAX_HEALTH = 3\n-ARCHER_L1_DICE = 1\n-ARCHER_L1_ATTACK = 0\n-ARCHER_L1_ABILITY = BOUNCING_ARROW\n-\n-MAGE_L1_DEFAULT_HEALTH = 2\n-MAGE_L1_MAX_HEALTH = 2\n-MAGE_L1_DICE = 1\n-MAGE_L1_ATTACK = 0\n-MAGE_L1_ABILITY = FREEZE\n-\n-CHARACTER_DEFAULT_STATS = {\n-    \"knight\": {\n-        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n-        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n-        \"dice\": KNIGHT_L1_DICE,\n-        \"attack\": KNIGHT_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n-    },\n-    \"archer\": {\n-        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n-        \"max_health\": ARCHER_L1_MAX_HEALTH,\n-        \"dice\": ARCHER_L1_DICE,\n-        \"attack\": ARCHER_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n-    },\n-    \"mage\": {\n-        \"health\": MAGE_L1_DEFAULT_HEALTH,\n-        \"max_health\": MAGE_L1_MAX_HEALTH,\n-        \"dice\": MAGE_L1_DICE,\n-        \"attack\": MAGE_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n-    },\n-}\n-\n-\n-def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n-    \"\"\"Initialize all character types with default stats\"\"\"\n-    return {\n-        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n-        for char_type in [KNIGHT, ARCHER, MAGE]\n-    }\ndiff --git a/server/gameplay/presets.py b/server/gameplay/presets.py\nindex 8696c0a..cc9a0ab 100644\n--- a/server/gameplay/presets.py\n+++ b/server/gameplay/presets.py\n@@ -1,9 +1,23 @@\n from typing import Literal, Optional\n \n-from .models import (\n+from .common import KNIGHT, MAGE, ARCHER\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n+    AttackBonusEffect,\n+    AttackNegBonusEffect,\n+    SkipTurnEffect,\n+    RerollDiceEffect,\n+    DrawCardEffect,\n+)\n+from .gameplay import (\n+    StageName,\n+    ABILITY_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n+    OPPONENT_SELECTION,\n     GamePlay,\n     DEFAULT_GAME,\n-    StageName,\n     Player,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -12,23 +26,7 @@ from .models import (\n     Opponent4,\n     BattleResult,\n     AbilitySelectMeta,\n-    ABILITY_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n-    OPPONENT_SELECTION,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n     init_characters,\n-    AttackBonusEffect,\n-    AttackNegBonusEffect,\n-    SkipTurnEffect,\n-    RerollDiceEffect,\n-    DrawCardEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n ABILITY_SELECTION_KNIGHT = \"ability_selection_knight\"\ndiff --git a/server/gameplay/test_models.py b/server/gameplay/test_common.py\nsimilarity index 90%\nrename from server/gameplay/test_models.py\nrename to server/gameplay/test_common.py\nindex 2b0e8f7..8f2f89a 100644\n--- a/server/gameplay/test_models.py\n+++ b/server/gameplay/test_common.py\n@@ -6,16 +6,13 @@ These tests verify model behavior including computed properties.\n \n import pytest\n \n-from .models import (\n+from .common import KNIGHT\n+from .abilities import ABILITIES_MAP, BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .gameplay import (\n     Character,\n     CHARACTER_DEFAULT_STATS,\n-    KNIGHT,\n     init_characters,\n     KNIGHT_L1_DEFAULT_HEALTH,\n-    ABILITIES_MAP,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n \ndiff --git a/server/gameplay/test_effect_source_validation.py b/server/gameplay/test_effect_source_validation.py\nindex 31233f8..467f3ab 100644\n--- a/server/gameplay/test_effect_source_validation.py\n+++ b/server/gameplay/test_effect_source_validation.py\n@@ -5,14 +5,12 @@ Tests for effect source validation\n import pytest\n from pydantic import ValidationError\n \n-from server.gameplay.models import (\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n     RerollDiceEffect,\n     SkipTurnEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n \ndiff --git a/server/gameplay/test_effect_total.py b/server/gameplay/test_effect_total.py\nindex 8ee0851..b2a812b 100644\n--- a/server/gameplay/test_effect_total.py\n+++ b/server/gameplay/test_effect_total.py\n@@ -2,16 +2,14 @@\n Tests for EffectTotal aggregation in Character\n \"\"\"\n \n-from server.gameplay.models import (\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n-    Character,\n     RerollDiceEffect,\n     SkipTurnEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n+from .gameplay import Character\n \n \n def test_effect_total_empty():\ndiff --git a/server/gameplay/test_minimum_players.py b/server/gameplay/test_minimum_players.py\nindex 4478779..5949beb 100644\n--- a/server/gameplay/test_minimum_players.py\n+++ b/server/gameplay/test_minimum_players.py\n@@ -7,7 +7,7 @@ These tests verify that the game correctly handles scenarios with less than 2 pl\n import pytest\n \n from .presets import get_debug_preset, SINGLE_PLAYER\n-from .models import CHARACTER_SELECT\n+from .gameplay import CHARACTER_SELECT\n \n \n def test_single_player_preset():\ndiff --git a/server/main.py b/server/main.py\nindex 3f57ffe..165a1c6 100644\n--- a/server/main.py\n+++ b/server/main.py\n@@ -16,7 +16,7 @@ from sqlalchemy.ext.asyncio import AsyncSession\n \n from .env import REDIS_HOST, REDIS_PORT\n from .game_engine import GameEngine\n-from .gameplay.models import DEFAULT_GAME, GamePlay, StageName\n+from .gameplay.gameplay import StageName, DEFAULT_GAME, GamePlay\n from .gameplay.presets import get_debug_preset, DEBUG_PRESETS\n from .db_models import Game as GameTable\n from .database import get_db, AsyncSessionLocal\ndiff --git a/server/test_player_reordering.py b/server/test_player_reordering.py\nindex 937bcc0..0ac51fb 100644\n--- a/server/test_player_reordering.py\n+++ b/server/test_player_reordering.py\n@@ -1,6 +1,6 @@\n \"\"\"Test player reordering in GamePlay\"\"\"\n \n-from server.gameplay.models import GamePlay, Player\n+from server.gameplay.gameplay import GamePlay, Player\n \n \n def test_reorder_players_single_player():"
    },
    "preserveOutput": "always",
    "reporter": [
      [
        "html",
        {
          "open": "never"
        }
      ],
      [
        "json",
        {
          "outputFile": "playwright-report/results.json"
        }
      ],
      [
        "junit",
        {
          "outputFile": "playwright-report/results.xml"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "quiet": false,
    "projects": [
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/6373b30c4b3d7606c77e4c49c54a17fcb823f989",
            "commitHash": "6373b30c4b3d7606c77e4c49c54a17fcb823f989",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/32",
            "prTitle": "claude/refactor-models-split-x1B0p",
            "prBaseHash": "bc60de7d36702477e5f0572e55a805bcb1aaf0d5",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21114978943"
          },
          "gitCommit": {
            "shortHash": "6373b30",
            "hash": "6373b30c4b3d7606c77e4c49c54a17fcb823f989",
            "subject": "Merge c0faeb4893b7c34afa5fce22e2b80ffd444a0c53 into bc60de7d36702477e5f0572e55a805bcb1aaf0d5",
            "body": "Merge c0faeb4893b7c34afa5fce22e2b80ffd444a0c53 into bc60de7d36702477e5f0572e55a805bcb1aaf0d5\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768753826000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768753826000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/game_engine.py b/server/game_engine.py\nindex 0239156..6bcc9ba 100644\n--- a/server/game_engine.py\n+++ b/server/game_engine.py\n@@ -1,8 +1,5 @@\n-from .gameplay.models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-)\n+from .gameplay.models import GameException, ReportedException\n+from .gameplay.gameplay import GamePlay\n from .gameplay.actions import (\n     ACTION_MAP,\n )\ndiff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nnew file mode 100644\nindex 0000000..423dea5\n--- /dev/null\n+++ b/server/gameplay/abilities.py\n@@ -0,0 +1,79 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_ABILITY_MAP\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Apply to constants\n+    APPLY_TO_SELECTED_OPPONENT,\n+)\n+\n+########################################################\n+# Ability names - defined before imports from effects to avoid circular dependency\n+########################################################\n+BATTLE_HOWL = \"battle_howl\"\n+BOUNCING_ARROW = \"bouncing_arrow\"\n+FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+AbilityName = Literal[*ABILITIES_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which abilities can create which effects\n+# This is used for validation to ensure effects have valid source abilities\n+EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n+    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n+    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n+    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n+    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    SkipTurnEffect,\n+)\n+\n+\n+class Ability(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n+\n+    @property\n+    def requires_opponent_selection(self) -> bool:\n+        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n+        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n+\n+\n+ABILITIES_MAP: dict[AbilityName, Ability] = {\n+    BATTLE_HOWL: Ability(\n+        name=BATTLE_HOWL,\n+        effects=[\n+            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+        ],\n+    ),\n+    BOUNCING_ARROW: Ability(\n+        name=BOUNCING_ARROW,\n+        effects=[\n+            RerollDiceEffect(source=BOUNCING_ARROW),\n+        ],\n+    ),\n+    FREEZE: Ability(\n+        name=FREEZE,\n+        effects=[\n+            SkipTurnEffect(source=FREEZE),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 30001f1..2c1329f 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -1,6 +1,6 @@\n from typing import Dict\n \n-from ..models import (\n+from ..common import (\n     CONNECT,\n     LEAVE,\n     DISCONNECT,\n@@ -18,7 +18,7 @@ from ..models import (\n     ACTION_REROLL_EFFECT,\n     BATTLE_END_ACTION,\n     DEBUG_SET_BATTLE_DICE_ROLLS,\n-)\n+)  # Action constants stay in models.py\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\ndiff --git a/server/gameplay/actions/action.py b/server/gameplay/actions/action.py\nindex ed31d2e..5a045d4 100644\n--- a/server/gameplay/actions/action.py\n+++ b/server/gameplay/actions/action.py\n@@ -1,12 +1,12 @@\n from abc import ABC, abstractmethod\n from typing import Any, Dict, Optional\n \n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..gameplay import (\n+    StageName,\n     GamePlay,\n     Player,\n     Character,\n-    GameException,\n-    ReportedException,\n     ActivePlayer1,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -14,7 +14,6 @@ from ..models import (\n     Opponent2,\n     Opponent3,\n     Opponent4,\n-    StageName,\n )\n \n \ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex a3a8703..0d9861f 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -5,17 +5,16 @@ Ends the battle, calculates winner, and reduces loser's health by 1.\n \"\"\"\n \n from .action import Action\n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..gameplay import (\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n     GamePlay,\n-    GameException,\n-    ReportedException,\n     ActivePlayer1,\n     ActivePlayer3,\n     ActivePlayer4,\n     Opponent3,\n     Opponent4,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n )\n \n \n@@ -61,7 +60,7 @@ class BattleEndAction(Action):\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n-        from ..models import BATTLE_END_ACTION\n+        from ..common import BATTLE_END_ACTION\n \n         def should_keep_effect(effect):\n             \"\"\"Returns True if effect should be kept after battle\"\"\"\ndiff --git a/server/gameplay/actions/connection.py b/server/gameplay/actions/connection.py\nindex 00d4729..43b082e 100644\n--- a/server/gameplay/actions/connection.py\n+++ b/server/gameplay/actions/connection.py\n@@ -1,20 +1,22 @@\n from typing import Dict\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    Player,\n-    Character,\n-    ActivePlayer1,\n-    CHARACTER_DEFAULT_STATS,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n+)\n+from ..gameplay import (\n     CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer1,\n+    CHARACTER_DEFAULT_STATS,\n )\n \n MAX_PLAYERS = 4\ndiff --git a/server/gameplay/actions/stage_ability_opponent_selection.py b/server/gameplay/actions/stage_ability_opponent_selection.py\nindex b880404..5985c08 100644\n--- a/server/gameplay/actions/stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/stage_ability_opponent_selection.py\n@@ -7,14 +7,8 @@ This module implements actions for the ability opponent selection stage:\n \"\"\"\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    Opponent2,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-)\n+from ..common import GameException, ReportedException\n+from ..gameplay import ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class AbilityOpponentPressAction(Action):\ndiff --git a/server/gameplay/actions/stage_ability_selection.py b/server/gameplay/actions/stage_ability_selection.py\nindex 4d5a556..af35bf2 100644\n--- a/server/gameplay/actions/stage_ability_selection.py\n+++ b/server/gameplay/actions/stage_ability_selection.py\n@@ -9,17 +9,11 @@ This module implements actions for the ability selection stage:\n \n import copy\n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    AbilitySelectMeta,\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    APPLY_TO_SELF,\n-    AbilityName,\n-)\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF\n+from ..abilities import AbilityName\n+from ..gameplay import ABILITY_SELECTION, ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION\n+from ..gameplay import GamePlay, AbilitySelectMeta\n \n \n class AbilityPressAction(Action):\ndiff --git a/server/gameplay/actions/stage_battle.py b/server/gameplay/actions/stage_battle.py\nindex 824d737..a8fe573 100644\n--- a/server/gameplay/actions/stage_battle.py\n+++ b/server/gameplay/actions/stage_battle.py\n@@ -10,20 +10,19 @@ This module implements actions for the battle stage:\n \n import random\n from .action import Action\n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..effects import RerollDiceEffect\n+from ..gameplay import (\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n     GamePlay,\n-    GameException,\n-    ReportedException,\n     ActivePlayer2,\n     ActivePlayer3,\n     ActivePlayer4,\n     Opponent2,\n     Opponent3,\n     Opponent4,\n-    RerollDiceEffect,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n )\n \n \n@@ -73,7 +72,7 @@ def set_winner_if_both_rolled(game: GamePlay) -> None:\n     opponent_is_winner = opponent_score > active_score\n \n     # Import BattleResult at top of function to avoid circular imports\n-    from ..models import BattleResult\n+    from ..gameplay import BattleResult\n \n     # Upgrade to ActivePlayer4 and Opponent4 with result fields\n     game.active = ActivePlayer4(\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 6687b83..474748e 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -7,16 +7,18 @@ This module implements actions for the character selection stage:\n \"\"\"\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n+from ..common import (\n     GameException,\n     ReportedException,\n+    CHARACTER_SELECT_ACTION,\n+)\n+from ..gameplay import (\n+    ABILITY_SELECTION,\n+    CHARACTER_SELECT,\n+    GamePlay,\n     CharacterSelectMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n-    ABILITY_SELECTION,\n-    CHARACTER_SELECT,\n-    CHARACTER_SELECT_ACTION,\n )\n \n \ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex 3404bb1..ff48b63 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -8,15 +8,9 @@ This module implements actions for the opponent selection stage:\n \n import copy\n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    Opponent2,\n-    BATTLE_DICE_ROLL,\n-    OPPONENT_SELECTION,\n-    APPLY_TO_BATTLE_OPPONENT,\n-)\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_BATTLE_OPPONENT\n+from ..gameplay import BATTLE_DICE_ROLL, OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class OpponentPressAction(Action):\ndiff --git a/server/gameplay/actions/test_action_properties.py b/server/gameplay/actions/test_action_properties.py\nindex f015215..858c847 100644\n--- a/server/gameplay/actions/test_action_properties.py\n+++ b/server/gameplay/actions/test_action_properties.py\n@@ -7,7 +7,10 @@ These tests verify that action properties work correctly across different game s\n import pytest\n \n from .action import Action\n-from ..models import (\n+from ..common import GameException, KNIGHT, MAGE, ARCHER\n+from ..gameplay import (\n+    BATTLE_DICE_ROLL,\n+    CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     ActivePlayer1,\n@@ -18,12 +21,6 @@ from ..models import (\n     Opponent3,\n     Opponent4,\n     BattleResult,\n-    GameException,\n-    BATTLE_DICE_ROLL,\n-    CHARACTER_SELECT,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n     init_characters,\n     KNIGHT_L1_DEFAULT_HEALTH,\n     KNIGHT_L1_DICE,\ndiff --git a/server/gameplay/actions/test_connect_action.py b/server/gameplay/actions/test_connect_action.py\nindex bd27db1..1629a64 100644\n--- a/server/gameplay/actions/test_connect_action.py\n+++ b/server/gameplay/actions/test_connect_action.py\n@@ -8,19 +8,21 @@ reconnections, game capacity limits, and character initialization.\n import pytest\n \n from .connection import ConnectAction, MAX_PLAYERS\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Character,\n-    ActivePlayer1,\n+from ..common import (\n     ReportedException,\n-    CHARACTER_DEFAULT_STATS,\n-    CHARACTER_SELECT,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n+)\n+from ..gameplay import (\n+    CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer1,\n+    CHARACTER_DEFAULT_STATS,\n     ARCHER_L1_ATTACK,\n     MAGE_L1_ATTACK,\n )\ndiff --git a/server/gameplay/actions/test_connection_integration.py b/server/gameplay/actions/test_connection_integration.py\nindex dd899ae..e63bdab 100644\n--- a/server/gameplay/actions/test_connection_integration.py\n+++ b/server/gameplay/actions/test_connection_integration.py\n@@ -9,12 +9,8 @@ and leaving actions.\n import pytest\n \n from .connection import ConnectAction, DisconnectAction, LeaveAction\n-from ..models import (\n-    GamePlay,\n-    CHARACTER_SELECT,\n-    CONNECTED,\n-    DISCONNECTED,\n-)\n+from ..common import CONNECTED, DISCONNECTED\n+from ..gameplay import CHARACTER_SELECT, GamePlay\n \n \n def test_connect_then_disconnect_then_reconnect():\ndiff --git a/server/gameplay/actions/test_disconnect_action.py b/server/gameplay/actions/test_disconnect_action.py\nindex aad505f..2337f53 100644\n--- a/server/gameplay/actions/test_disconnect_action.py\n+++ b/server/gameplay/actions/test_disconnect_action.py\n@@ -8,18 +8,20 @@ existing players, nonexistent players, and already disconnected players.\n import pytest\n \n from .connection import DisconnectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Character,\n+from ..common import (\n     GameException,\n-    CHARACTER_DEFAULT_STATS,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n )\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    Character,\n+    CHARACTER_DEFAULT_STATS,\n+)\n \n \n def test_disconnect_action_existing_player():\ndiff --git a/server/gameplay/actions/test_leave_action.py b/server/gameplay/actions/test_leave_action.py\nindex cdf2e8a..e67ef2e 100644\n--- a/server/gameplay/actions/test_leave_action.py\n+++ b/server/gameplay/actions/test_leave_action.py\n@@ -9,15 +9,12 @@ the only player leaving.\n import pytest\n \n from .connection import LeaveAction\n-from ..models import (\n+from ..common import GameException, KNIGHT, ARCHER, MAGE\n+from ..gameplay import (\n     GamePlay,\n     Player,\n     Character,\n-    GameException,\n     CHARACTER_DEFAULT_STATS,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n )\n \n \ndiff --git a/server/gameplay/actions/test_stage_ability_opponent_selection.py b/server/gameplay/actions/test_stage_ability_opponent_selection.py\nindex c25173c..75dfb7d 100644\n--- a/server/gameplay/actions/test_stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_opponent_selection.py\n@@ -8,20 +8,15 @@ selected opponents for ability targeting and confirming selections to apply effe\n import pytest\n \n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n-from ..models import (\n+from ..common import GameException, ReportedException, KNIGHT, MAGE\n+from ..abilities import BATTLE_HOWL, FREEZE, ABILITIES_MAP\n+from ..gameplay import (\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n     GamePlay,\n     Player,\n     ActivePlayer2,\n-    GameException,\n-    ReportedException,\n     Opponent2,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    KNIGHT,\n-    MAGE,\n-    BATTLE_HOWL,\n-    FREEZE,\n-    ABILITIES_MAP,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_ability_selection.py b/server/gameplay/actions/test_stage_ability_selection.py\nindex 9e3b7df..b3c0106 100644\n--- a/server/gameplay/actions/test_stage_ability_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_selection.py\n@@ -10,24 +10,26 @@ selected abilities and confirming selections to transition to:\n import pytest\n \n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer2,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    RerollDiceEffect,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..effects import REROLL_DICE\n+from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..gameplay import (\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n     CHARACTER_SELECT,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n-    REROLL_DICE,\n+)\n+from ..effects import RerollDiceEffect\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer2,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_battle_dice_roll.py b/server/gameplay/actions/test_stage_battle_dice_roll.py\nindex 08d71b9..bbc80fd 100644\n--- a/server/gameplay/actions/test_stage_battle_dice_roll.py\n+++ b/server/gameplay/actions/test_stage_battle_dice_roll.py\n@@ -16,32 +16,36 @@ from .stage_battle import (\n     calculate_winner,\n     set_winner_if_both_rolled,\n )\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer1,\n-    ActivePlayer2,\n-    ActivePlayer3,\n-    ActivePlayer4,\n-    Opponent2,\n-    Opponent3,\n-    Opponent4,\n+from ..common import (\n     GameException,\n     ReportedException,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n+)\n+from ..gameplay import (\n     BATTLE_DICE_ROLL,\n     BATTLE_END,\n     CHARACTER_SELECT,\n     OPPONENT_SELECTION,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n+)\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer1,\n+    ActivePlayer2,\n+    ActivePlayer3,\n+    ActivePlayer4,\n+    Opponent2,\n+    Opponent3,\n+    Opponent4,\n     init_characters,\n )\n from ..presets import get_debug_preset, EFFECT_REROLL\ndiff --git a/server/gameplay/actions/test_stage_battle_end.py b/server/gameplay/actions/test_stage_battle_end.py\nindex 7c0e543..996f74f 100644\n--- a/server/gameplay/actions/test_stage_battle_end.py\n+++ b/server/gameplay/actions/test_stage_battle_end.py\n@@ -13,25 +13,22 @@ Effect disposal rules:\n import pytest\n \n from .battle_end import BattleEndAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer4,\n-    Opponent4,\n-    BattleResult,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    AttackNegBonusEffect,\n-    SkipTurnEffect,\n-    RerollDiceEffect,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n     KNIGHT,\n     MAGE,\n     ARCHER,\n-    BATTLE_HOWL,\n-    FREEZE,\n-    BOUNCING_ARROW,\n+)\n+from ..abilities import BATTLE_HOWL, FREEZE, BOUNCING_ARROW\n+from ..gameplay import BATTLE_END, CHARACTER_SELECT\n+from ..effects import AttackNegBonusEffect, SkipTurnEffect, RerollDiceEffect\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer4,\n+    Opponent4,\n+    BattleResult,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_character_select.py b/server/gameplay/actions/test_stage_character_select.py\nindex 9c65b90..cd8722f 100644\n--- a/server/gameplay/actions/test_stage_character_select.py\n+++ b/server/gameplay/actions/test_stage_character_select.py\n@@ -8,24 +8,25 @@ selected characters and confirming selections to transition to battle.\n import pytest\n \n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n-from ..models import (\n+from ..common import (\n+    GameException,\n+    ReportedException,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..abilities import FREEZE, BATTLE_HOWL\n+from ..effects import SkipTurnEffect\n+from ..gameplay import (\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    BATTLE_DICE_ROLL,\n     GamePlay,\n     Player,\n     Character,\n     ActivePlayer1,\n     ActivePlayer2,\n-    GameException,\n-    ReportedException,\n-    SkipTurnEffect,\n     CHARACTER_DEFAULT_STATS,\n-    CHARACTER_SELECT,\n-    ABILITY_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    FREEZE,\n-    BATTLE_HOWL,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_opponent_selection.py b/server/gameplay/actions/test_stage_opponent_selection.py\nindex dae8343..9ee53b4 100644\n--- a/server/gameplay/actions/test_stage_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_opponent_selection.py\n@@ -8,25 +8,25 @@ selected opponents and confirming selections to transition to battle.\n import pytest\n \n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Ability,\n-    Character,\n-    ActivePlayer2,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    Opponent2,\n-    AttackNegBonusEffect,\n-    CHARACTER_DEFAULT_STATS,\n-    OPPONENT_SELECTION,\n-    BATTLE_DICE_ROLL,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n-    BATTLE_HOWL,\n     ATTACK_NEG_BONUS,\n-    ABILITIES_MAP,\n+)\n+from ..abilities import Ability, BATTLE_HOWL, ABILITIES_MAP\n+from ..effects import AttackNegBonusEffect\n+from ..gameplay import (\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer2,\n+    Opponent2,\n+    CHARACTER_DEFAULT_STATS,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/common.py b/server/gameplay/common.py\nnew file mode 100644\nindex 0000000..0f5d9c3\n--- /dev/null\n+++ b/server/gameplay/common.py\n@@ -0,0 +1,134 @@\n+\"\"\"\n+Base models and utilities - foundation for effects, abilities, and gameplay modules.\n+\"\"\"\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import BaseModel, ConfigDict\n+\n+\n+########################################################\n+# Connection statuses\n+########################################################\n+CONNECTED = \"connected\"\n+DISCONNECTED = \"disconnected\"\n+CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n+ConnectionStatus = Literal[*CONNECTION_STATUSES]\n+\n+########################################################\n+# Character types\n+########################################################\n+KNIGHT = \"knight\"\n+ARCHER = \"archer\"\n+MAGE = \"mage\"\n+CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n+ChatacterType = Literal[*CHARACTER_TYPES]\n+\n+########################################################\n+# Actions\n+########################################################\n+CONNECT = \"connect\"\n+LEAVE = \"leave\"\n+DISCONNECT = \"disconnect\"\n+CHARACTER_PRESS = \"character_press\"\n+CHARACTER_SELECT_ACTION = \"character_select\"\n+ABILITY_PRESS = \"ability_press\"\n+ABILITY_SELECT = \"ability_select\"\n+ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n+ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n+OPPONENT_PRESS = \"opponent_press\"\n+OPPONENT_SELECT = \"opponent_select\"\n+ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n+OPPONENT_ROLL = \"opponent_roll\"\n+ACTION_REROLL = \"action_reroll\"\n+ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n+BATTLE_END_ACTION = \"battle_end\"\n+DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n+\n+ACTION_NAMES = [\n+    CONNECT,\n+    LEAVE,\n+    DISCONNECT,\n+    CHARACTER_PRESS,\n+    CHARACTER_SELECT_ACTION,\n+    ABILITY_PRESS,\n+    ABILITY_SELECT,\n+    ABILITY_OPPONENT_PRESS,\n+    ABILITY_OPPONENT_SELECT,\n+    OPPONENT_PRESS,\n+    OPPONENT_SELECT,\n+    ACTIVE_PLAYER_ROLL,\n+    OPPONENT_ROLL,\n+    ACTION_REROLL,\n+    ACTION_REROLL_EFFECT,\n+    BATTLE_END_ACTION,\n+    DEBUG_SET_BATTLE_DICE_ROLLS,\n+]\n+ActionName = Literal[*ACTION_NAMES]\n+\n+\n+########################################################\n+# Exceptions\n+########################################################\n+class GameException(Exception):\n+    pass\n+\n+\n+class ReportedException(GameException):\n+    pass\n+\n+\n+########################################################\n+# Base model utilities\n+########################################################\n+def recursive_db_model_dump(model: BaseModel) -> dict:\n+    \"\"\"\n+    Recursively dump model for database storage.\n+    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n+    \"\"\"\n+    result = {}\n+\n+    # Iterate over all fields and their values\n+    for field_name, field_value in model:\n+        if isinstance(field_value, BaseModel):\n+            # Nested model - call its db_model_dump if it's a StrictModel\n+            if hasattr(field_value, \"db_model_dump\"):\n+                result[field_name] = field_value.db_model_dump()\n+            else:\n+                result[field_name] = field_value.model_dump()\n+        elif isinstance(field_value, dict):\n+            # Dict of values (possibly models)\n+            result[field_name] = {\n+                k: (\n+                    v.db_model_dump()\n+                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n+                    else v.model_dump() if isinstance(v, BaseModel) else v\n+                )\n+                for k, v in field_value.items()\n+            }\n+        elif isinstance(field_value, (list, tuple, set)):\n+            # Collection of values (possibly models) - preserve collection type\n+            processed_items = [\n+                (\n+                    item.db_model_dump()\n+                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n+                    else item.model_dump() if isinstance(item, BaseModel) else item\n+                )\n+                for item in field_value\n+            ]\n+            # Preserve the original collection type\n+            result[field_name] = type(field_value)(processed_items)\n+        else:\n+            # Primitive value\n+            result[field_name] = field_value\n+\n+    return result\n+\n+\n+class StrictModel(BaseModel):\n+    model_config = ConfigDict(extra=\"forbid\")\n+\n+    def db_model_dump(self) -> dict:\n+        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n+        return recursive_db_model_dump(self)\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nnew file mode 100644\nindex 0000000..c8526fa\n--- /dev/null\n+++ b/server/gameplay/effects.py\n@@ -0,0 +1,145 @@\n+from __future__ import annotations\n+\n+from typing import Literal, Annotated, Union, Self\n+\n+from pydantic import Field, model_validator\n+\n+from .common import (\n+    StrictModel,\n+    ActionName,\n+    # Action name constants for dispose_actions\n+    CHARACTER_SELECT_ACTION,\n+    BATTLE_END_ACTION,\n+    ACTION_REROLL_EFFECT,\n+)\n+\n+########################################################\n+# Effect names\n+########################################################\n+ATTACK_BONUS = \"attack_bonus\"\n+ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+REROLL_DICE = \"reroll_dice\"\n+SKIP_TURN = \"skip_turn\"\n+DRAW_CARD = \"draw_card\"\n+\n+########################################################\n+# Effect apply_to targets\n+########################################################\n+APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n+APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n+APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n+\n+APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n+ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n+\n+\n+class Effect(StrictModel):\n+    \"\"\"\n+    Base class for all effects.\n+    Each effect specifies when it should be disposed via dispose_actions field.\n+    Each effect specifies who receives the effect via apply_to field.\n+    \"\"\"\n+\n+    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n+    source: str  # AbilityName - using str to avoid circular import\n+    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n+    apply_to: ApplyToTarget  # Who receives this effect\n+\n+    @model_validator(mode=\"after\")\n+    def validate_source(self) -> Self:\n+        \"\"\"Validate that source is valid for this effect type\"\"\"\n+        # Lazy import to avoid circular dependency\n+        from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n+\n+        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        if self.source not in valid_sources and len(valid_sources) > 0:\n+            raise ValueError(\n+                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n+                f\"Valid sources: {valid_sources}\"\n+            )\n+        return self\n+\n+\n+class SkipTurnEffect(Effect):\n+    \"\"\"\n+    Character can't participate in the next turn.\n+    Disposed after character selection.\n+    Applied to selected opponent (requires ability_opponent_selection stage).\n+    \"\"\"\n+\n+    name: Literal[SKIP_TURN] = SKIP_TURN\n+    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n+    skip_next_turn: bool = True\n+\n+\n+class AttackBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is increased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    attack_bonus: int\n+\n+\n+class RerollDiceEffect(Effect):\n+    \"\"\"\n+    Character's dice are rerolled if lost the battle.\n+    Disposed at battle end or when the reroll effect action is used.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[REROLL_DICE] = REROLL_DICE\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    reroll_dice: bool = True\n+\n+\n+class AttackNegBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is decreased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to battle opponent (no separate selection required).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n+    attack_neg_bonus: int\n+\n+\n+class DrawCardEffect(Effect):\n+    \"\"\"\n+    Character draws cards at the start of battle.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DRAW_CARD] = DRAW_CARD\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    draw_count: int = 1\n+\n+\n+# Define EffectUnion for discriminated union of all effect types (without base classes)\n+EffectUnion = Annotated[\n+    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Field(discriminator=\"name\"),\n+]\n+\n+\n+class EffectTotal(StrictModel):\n+    \"\"\"\n+    Aggregated effect totals for a character.\n+    Combines all active effects into a single summary.\n+    \"\"\"\n+\n+    attack_bonus: int = 0\n+    attack_neg_bonus: int = 0\n+    skip_next_turn: bool = False\n+    reroll_dice_available: bool = False\n+    draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nnew file mode 100644\nindex 0000000..937d1f7\n--- /dev/null\n+++ b/server/gameplay/gameplay.py\n@@ -0,0 +1,254 @@\n+from __future__ import annotations\n+\n+from typing import Dict, Literal, Optional\n+\n+from pydantic import Field, computed_field\n+\n+from .common import (\n+    StrictModel,\n+    ConnectionStatus,\n+    ChatacterType,\n+    CONNECTED,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+\n+########################################################\n+# Stages\n+########################################################\n+CHARACTER_SELECT = \"character_select\"\n+ABILITY_SELECTION = \"ability_selection\"\n+ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n+OPPONENT_SELECTION = \"opponent_selection\"\n+BATTLE_DICE_ROLL = \"battle_dice_roll\"\n+BATTLE_END = \"battle_end\"\n+STAGES_NAMES = [\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+]\n+StageName = Literal[*STAGES_NAMES]\n+\n+from .abilities import (\n+    Ability,\n+    ABILITIES_MAP,\n+    AbilityName,\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+)\n+from .effects import (\n+    EffectUnion,\n+    EffectTotal,\n+    AttackBonusEffect,\n+    AttackNegBonusEffect,\n+    SkipTurnEffect,\n+    RerollDiceEffect,\n+    DrawCardEffect,\n+)\n+\n+\n+class Character(StrictModel):\n+\n+    level: int\n+    health: int\n+    max_health: int\n+    dice: int\n+    attack: int\n+    abilities: list[Ability] = Field(default_factory=list)\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+    @computed_field\n+    @property\n+    def is_alive(self) -> bool:\n+        \"\"\"Character is alive if health > 0\"\"\"\n+        return self.health > 0\n+\n+    @computed_field\n+    @property\n+    def effect(self) -> EffectTotal:\n+        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n+        total = EffectTotal()\n+\n+        for eff in self.effects:\n+            if isinstance(eff, AttackBonusEffect):\n+                total.attack_bonus += eff.attack_bonus\n+            elif isinstance(eff, AttackNegBonusEffect):\n+                total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, SkipTurnEffect):\n+                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n+            elif isinstance(eff, RerollDiceEffect):\n+                total.reroll_dice_available = True\n+            elif isinstance(eff, DrawCardEffect):\n+                total.draw_card_count += eff.draw_count\n+\n+        return total\n+\n+    def db_model_dump(self) -> dict:\n+        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n+\n+\n+class CharacterSelectMeta(StrictModel):\n+    \"\"\"Stage metadata for character selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted character\n+\n+\n+class AbilitySelectMeta(StrictModel):\n+    \"\"\"Stage metadata for ability selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted ability\n+\n+\n+class ActivePlayer1(StrictModel):\n+    \"\"\"Selected character for battle\"\"\"\n+\n+    player: str  # Character name\n+\n+\n+class BattleResult(StrictModel):\n+    winner: bool\n+    score: int  # result of the battle, sum of dice_roll and attack\n+\n+\n+class ActivePlayer2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class ActivePlayer3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class ActivePlayer4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n+\n+\n+class Opponent2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class Opponent3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class Opponent4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+Opponent = Opponent2 | Opponent3 | Opponent4\n+\n+\n+class Player(StrictModel):\n+    name: str\n+    status: ConnectionStatus = CONNECTED\n+    cards: list[str] = Field(default_factory=list)\n+    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n+\n+\n+########################################################\n+# GamePlay model\n+########################################################\n+class GamePlay(StrictModel):\n+    stage: StageName = CHARACTER_SELECT\n+    players: dict[str, Player] = Field(default_factory=dict)\n+    active: Optional[ActivePlayer] = None  # The active player and its selections\n+    ability: Optional[Ability] = None  # Selected ability\n+    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n+    opponent: Optional[Opponent] = None  # Selected opponent for battle\n+    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+\n+    def reorder_players(self, username: str):\n+        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n+        if username not in self.players:\n+            return\n+\n+        # Get all player keys\n+        player_keys = list(self.players.keys())\n+\n+        # Find the index of the username\n+        user_index = player_keys.index(username)\n+\n+        # Circular shift: username first, then the rest\n+        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n+\n+        # Build new dict with reordered keys\n+        reordered_dict = {key: self.players[key] for key in reordered_keys}\n+\n+        # Update in-place\n+        self.players.clear()\n+        self.players.update(reordered_dict)\n+\n+\n+DEFAULT_GAME = GamePlay()\n+\n+########################################################\n+# Character default stats\n+########################################################\n+KNIGHT_L1_DEFAULT_HEALTH = 2\n+KNIGHT_L1_MAX_HEALTH = 2\n+KNIGHT_L1_DICE = 1\n+KNIGHT_L1_ATTACK = 1\n+KNIGHT_L1_ABILITY = BATTLE_HOWL\n+\n+ARCHER_L1_DEFAULT_HEALTH = 3\n+ARCHER_L1_MAX_HEALTH = 3\n+ARCHER_L1_DICE = 1\n+ARCHER_L1_ATTACK = 0\n+ARCHER_L1_ABILITY = BOUNCING_ARROW\n+\n+MAGE_L1_DEFAULT_HEALTH = 2\n+MAGE_L1_MAX_HEALTH = 2\n+MAGE_L1_DICE = 1\n+MAGE_L1_ATTACK = 0\n+MAGE_L1_ABILITY = FREEZE\n+\n+CHARACTER_DEFAULT_STATS = {\n+    \"knight\": {\n+        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n+        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n+        \"dice\": KNIGHT_L1_DICE,\n+        \"attack\": KNIGHT_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n+    },\n+    \"archer\": {\n+        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n+        \"max_health\": ARCHER_L1_MAX_HEALTH,\n+        \"dice\": ARCHER_L1_DICE,\n+        \"attack\": ARCHER_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n+    },\n+    \"mage\": {\n+        \"health\": MAGE_L1_DEFAULT_HEALTH,\n+        \"max_health\": MAGE_L1_MAX_HEALTH,\n+        \"dice\": MAGE_L1_DICE,\n+        \"attack\": MAGE_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n+    },\n+}\n+\n+\n+def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n+    \"\"\"Initialize all character types with default stats\"\"\"\n+    return {\n+        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n+        for char_type in [KNIGHT, ARCHER, MAGE]\n+    }\ndiff --git a/server/gameplay/models.py b/server/gameplay/models.py\ndeleted file mode 100644\nindex d8a1106..0000000\n--- a/server/gameplay/models.py\n+++ /dev/null\n@@ -1,512 +0,0 @@\n-from typing import Dict, Optional, Literal, Annotated, Union, Self\n-\n-from pydantic import BaseModel, ConfigDict, Field, computed_field, Discriminator, model_validator\n-\n-########################################################\n-# Connection statuses\n-########################################################\n-CONNECTED = \"connected\"\n-DISCONNECTED = \"disconnected\"\n-CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n-ConnectionStatus = Literal[*CONNECTION_STATUSES]\n-\n-########################################################\n-# Stages\n-########################################################\n-CHARACTER_SELECT = \"character_select\"\n-ABILITY_SELECTION = \"ability_selection\"\n-ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n-OPPONENT_SELECTION = \"opponent_selection\"\n-BATTLE_DICE_ROLL = \"battle_dice_roll\"\n-BATTLE_END = \"battle_end\"\n-STAGES_NAMES = [\n-    CHARACTER_SELECT,\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-]\n-StageName = Literal[*STAGES_NAMES]\n-\n-########################################################\n-# Character types\n-########################################################\n-KNIGHT = \"knight\"\n-ARCHER = \"archer\"\n-MAGE = \"mage\"\n-CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n-ChatacterType = Literal[*CHARACTER_TYPES]\n-\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n-AbilityName = Literal[*ABILITIES_NAMES]\n-\n-# Effect names\n-ATTACK_BONUS = \"attack_bonus\"\n-ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n-REROLL_DICE = \"reroll_dice\"\n-SKIP_TURN = \"skip_turn\"\n-DRAW_CARD = \"draw_card\"\n-\n-# Effect apply_to targets - specifies who receives the effect\n-APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n-APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n-APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n-\n-APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n-ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n-\n-# Effect-to-Source mapping: defines which abilities can create which effects\n-# This is used for validation to ensure effects have valid source abilities\n-EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n-}\n-\n-########################################################\n-# Actions\n-########################################################\n-CONNECT = \"connect\"\n-LEAVE = \"leave\"\n-DISCONNECT = \"disconnect\"\n-CHARACTER_PRESS = \"character_press\"\n-CHARACTER_SELECT_ACTION = \"character_select\"\n-ABILITY_PRESS = \"ability_press\"\n-ABILITY_SELECT = \"ability_select\"\n-ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n-ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n-OPPONENT_PRESS = \"opponent_press\"\n-OPPONENT_SELECT = \"opponent_select\"\n-ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n-OPPONENT_ROLL = \"opponent_roll\"\n-ACTION_REROLL = \"action_reroll\"\n-ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n-BATTLE_END_ACTION = \"battle_end\"\n-DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n-\n-ACTION_NAMES = [\n-    CONNECT,\n-    LEAVE,\n-    DISCONNECT,\n-    CHARACTER_PRESS,\n-    CHARACTER_SELECT_ACTION,\n-    ABILITY_PRESS,\n-    ABILITY_SELECT,\n-    ABILITY_OPPONENT_PRESS,\n-    ABILITY_OPPONENT_SELECT,\n-    OPPONENT_PRESS,\n-    OPPONENT_SELECT,\n-    ACTIVE_PLAYER_ROLL,\n-    OPPONENT_ROLL,\n-    ACTION_REROLL,\n-    ACTION_REROLL_EFFECT,\n-    BATTLE_END_ACTION,\n-    DEBUG_SET_BATTLE_DICE_ROLLS,\n-]\n-ActionName = Literal[*ACTION_NAMES]\n-\n-\n-class GameException(Exception):\n-    pass\n-\n-\n-class ReportedException(GameException):\n-    pass\n-\n-\n-def recursive_db_model_dump(model: BaseModel) -> dict:\n-    \"\"\"\n-    Recursively dump model for database storage.\n-    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n-    \"\"\"\n-    result = {}\n-\n-    # Iterate over all fields and their values\n-    for field_name, field_value in model:\n-        if isinstance(field_value, BaseModel):\n-            # Nested model - call its db_model_dump if it's a StrictModel\n-            if hasattr(field_value, \"db_model_dump\"):\n-                result[field_name] = field_value.db_model_dump()\n-            else:\n-                result[field_name] = field_value.model_dump()\n-        elif isinstance(field_value, dict):\n-            # Dict of values (possibly models)\n-            result[field_name] = {\n-                k: (\n-                    v.db_model_dump()\n-                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n-                    else v.model_dump() if isinstance(v, BaseModel) else v\n-                )\n-                for k, v in field_value.items()\n-            }\n-        elif isinstance(field_value, (list, tuple, set)):\n-            # Collection of values (possibly models) - preserve collection type\n-            processed_items = [\n-                (\n-                    item.db_model_dump()\n-                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n-                    else item.model_dump() if isinstance(item, BaseModel) else item\n-                )\n-                for item in field_value\n-            ]\n-            # Preserve the original collection type\n-            result[field_name] = type(field_value)(processed_items)\n-        else:\n-            # Primitive value\n-            result[field_name] = field_value\n-\n-    return result\n-\n-\n-class StrictModel(BaseModel):\n-    model_config = ConfigDict(extra=\"forbid\")\n-\n-    def db_model_dump(self) -> dict:\n-        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n-        return recursive_db_model_dump(self)\n-\n-\n-class Effect(StrictModel):\n-    \"\"\"\n-    Base class for all effects.\n-    Each effect specifies when it should be disposed via dispose_actions field.\n-    Each effect specifies who receives the effect via apply_to field.\n-    \"\"\"\n-\n-    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n-    source: AbilityName\n-    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n-    apply_to: ApplyToTarget  # Who receives this effect\n-\n-    @model_validator(mode=\"after\")\n-    def validate_source(self) -> Self:\n-        \"\"\"Validate that source is valid for this effect type\"\"\"\n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n-        if self.source not in valid_sources and len(valid_sources) > 0:\n-            raise ValueError(\n-                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n-                f\"Valid sources: {valid_sources}\"\n-            )\n-        return self\n-\n-\n-class SkipTurnEffect(Effect):\n-    \"\"\"\n-    Character can't participate in the next turn.\n-    Disposed after character selection.\n-    Applied to selected opponent (requires ability_opponent_selection stage).\n-    \"\"\"\n-\n-    name: Literal[SKIP_TURN] = SKIP_TURN\n-    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n-    skip_next_turn: bool = True\n-\n-\n-class AttackBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is increased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    attack_bonus: int\n-\n-\n-class RerollDiceEffect(Effect):\n-    \"\"\"\n-    Character's dice are rerolled if lost the battle.\n-    Disposed at battle end or when the reroll effect action is used.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[REROLL_DICE] = REROLL_DICE\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    reroll_dice: bool = True\n-\n-\n-class AttackNegBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is decreased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to battle opponent (no separate selection required).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n-    attack_neg_bonus: int\n-\n-\n-class DrawCardEffect(Effect):\n-    \"\"\"\n-    Character draws cards at the start of battle.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[DRAW_CARD] = DRAW_CARD\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    draw_count: int = 1\n-\n-\n-# Define EffectUnion for discriminated union of all effect types (without base classes)\n-EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n-    Field(discriminator=\"name\"),\n-]\n-\n-\n-class Ability(StrictModel):\n-    name: str\n-    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n-\n-    @property\n-    def requires_opponent_selection(self) -> bool:\n-        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n-        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n-\n-\n-class EffectTotal(StrictModel):\n-    \"\"\"\n-    Aggregated effect totals for a character.\n-    Combines all active effects into a single summary.\n-    \"\"\"\n-\n-    attack_bonus: int = 0\n-    attack_neg_bonus: int = 0\n-    skip_next_turn: bool = False\n-    reroll_dice_available: bool = False\n-    draw_card_count: int = 0\n-\n-\n-ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n-        effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n-        ],\n-    ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n-        effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n-        ],\n-    ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n-        effects=[\n-            SkipTurnEffect(source=FREEZE),\n-        ],\n-    ),\n-}\n-\n-\n-class Character(StrictModel):\n-\n-    level: int\n-    health: int\n-    max_health: int\n-    dice: int\n-    attack: int\n-    abilities: list[Ability] = Field(default_factory=list)\n-    effects: list[EffectUnion] = Field(default_factory=list)\n-\n-    @computed_field\n-    @property\n-    def is_alive(self) -> bool:\n-        \"\"\"Character is alive if health > 0\"\"\"\n-        return self.health > 0\n-\n-    @computed_field\n-    @property\n-    def effect(self) -> EffectTotal:\n-        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n-        total = EffectTotal()\n-\n-        for eff in self.effects:\n-            if isinstance(eff, AttackBonusEffect):\n-                total.attack_bonus += eff.attack_bonus\n-            elif isinstance(eff, AttackNegBonusEffect):\n-                total.attack_neg_bonus += eff.attack_neg_bonus\n-            elif isinstance(eff, SkipTurnEffect):\n-                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n-            elif isinstance(eff, RerollDiceEffect):\n-                total.reroll_dice_available = True\n-            elif isinstance(eff, DrawCardEffect):\n-                total.draw_card_count += eff.draw_count\n-\n-        return total\n-\n-    def db_model_dump(self) -> dict:\n-        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n-\n-\n-class CharacterSelectMeta(StrictModel):\n-    \"\"\"Stage metadata for character selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted character\n-\n-\n-class AbilitySelectMeta(StrictModel):\n-    \"\"\"Stage metadata for ability selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted ability\n-\n-\n-class ActivePlayer1(StrictModel):\n-    \"\"\"Selected character for battle\"\"\"\n-\n-    player: str  # Character name\n-\n-\n-class BattleResult(StrictModel):\n-    winner: bool\n-    score: int  # result of the battle, sum of dice_roll and attack\n-\n-\n-class ActivePlayer2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class ActivePlayer3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class ActivePlayer4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n-\n-\n-class Opponent2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class Opponent3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class Opponent4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-Opponent = Opponent2 | Opponent3 | Opponent4\n-\n-\n-class Player(StrictModel):\n-    name: str\n-    status: ConnectionStatus = CONNECTED\n-    cards: list[str] = Field(default_factory=list)\n-    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n-\n-\n-########################################################\n-# GamePlay model\n-########################################################\n-class GamePlay(StrictModel):\n-    stage: StageName = CHARACTER_SELECT\n-    players: dict[str, Player] = Field(default_factory=dict)\n-    active: Optional[ActivePlayer] = None  # The active player and its selections\n-    ability: Optional[Ability] = None  # Selected ability\n-    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n-    opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n-\n-    def reorder_players(self, username: str):\n-        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n-        if username not in self.players:\n-            return\n-\n-        # Get all player keys\n-        player_keys = list(self.players.keys())\n-\n-        # Find the index of the username\n-        user_index = player_keys.index(username)\n-\n-        # Circular shift: username first, then the rest\n-        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n-\n-        # Build new dict with reordered keys\n-        reordered_dict = {key: self.players[key] for key in reordered_keys}\n-\n-        # Update in-place\n-        self.players.clear()\n-        self.players.update(reordered_dict)\n-\n-\n-DEFAULT_GAME = GamePlay()\n-\n-KNIGHT_L1_DEFAULT_HEALTH = 2\n-KNIGHT_L1_MAX_HEALTH = 2\n-KNIGHT_L1_DICE = 1\n-KNIGHT_L1_ATTACK = 1\n-KNIGHT_L1_ABILITY = BATTLE_HOWL\n-\n-ARCHER_L1_DEFAULT_HEALTH = 3\n-ARCHER_L1_MAX_HEALTH = 3\n-ARCHER_L1_DICE = 1\n-ARCHER_L1_ATTACK = 0\n-ARCHER_L1_ABILITY = BOUNCING_ARROW\n-\n-MAGE_L1_DEFAULT_HEALTH = 2\n-MAGE_L1_MAX_HEALTH = 2\n-MAGE_L1_DICE = 1\n-MAGE_L1_ATTACK = 0\n-MAGE_L1_ABILITY = FREEZE\n-\n-CHARACTER_DEFAULT_STATS = {\n-    \"knight\": {\n-        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n-        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n-        \"dice\": KNIGHT_L1_DICE,\n-        \"attack\": KNIGHT_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n-    },\n-    \"archer\": {\n-        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n-        \"max_health\": ARCHER_L1_MAX_HEALTH,\n-        \"dice\": ARCHER_L1_DICE,\n-        \"attack\": ARCHER_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n-    },\n-    \"mage\": {\n-        \"health\": MAGE_L1_DEFAULT_HEALTH,\n-        \"max_health\": MAGE_L1_MAX_HEALTH,\n-        \"dice\": MAGE_L1_DICE,\n-        \"attack\": MAGE_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n-    },\n-}\n-\n-\n-def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n-    \"\"\"Initialize all character types with default stats\"\"\"\n-    return {\n-        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n-        for char_type in [KNIGHT, ARCHER, MAGE]\n-    }\ndiff --git a/server/gameplay/presets.py b/server/gameplay/presets.py\nindex 8696c0a..cc9a0ab 100644\n--- a/server/gameplay/presets.py\n+++ b/server/gameplay/presets.py\n@@ -1,9 +1,23 @@\n from typing import Literal, Optional\n \n-from .models import (\n+from .common import KNIGHT, MAGE, ARCHER\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n+    AttackBonusEffect,\n+    AttackNegBonusEffect,\n+    SkipTurnEffect,\n+    RerollDiceEffect,\n+    DrawCardEffect,\n+)\n+from .gameplay import (\n+    StageName,\n+    ABILITY_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n+    OPPONENT_SELECTION,\n     GamePlay,\n     DEFAULT_GAME,\n-    StageName,\n     Player,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -12,23 +26,7 @@ from .models import (\n     Opponent4,\n     BattleResult,\n     AbilitySelectMeta,\n-    ABILITY_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n-    OPPONENT_SELECTION,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n     init_characters,\n-    AttackBonusEffect,\n-    AttackNegBonusEffect,\n-    SkipTurnEffect,\n-    RerollDiceEffect,\n-    DrawCardEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n ABILITY_SELECTION_KNIGHT = \"ability_selection_knight\"\ndiff --git a/server/gameplay/test_models.py b/server/gameplay/test_common.py\nsimilarity index 90%\nrename from server/gameplay/test_models.py\nrename to server/gameplay/test_common.py\nindex 2b0e8f7..8f2f89a 100644\n--- a/server/gameplay/test_models.py\n+++ b/server/gameplay/test_common.py\n@@ -6,16 +6,13 @@ These tests verify model behavior including computed properties.\n \n import pytest\n \n-from .models import (\n+from .common import KNIGHT\n+from .abilities import ABILITIES_MAP, BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .gameplay import (\n     Character,\n     CHARACTER_DEFAULT_STATS,\n-    KNIGHT,\n     init_characters,\n     KNIGHT_L1_DEFAULT_HEALTH,\n-    ABILITIES_MAP,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n \ndiff --git a/server/gameplay/test_effect_source_validation.py b/server/gameplay/test_effect_source_validation.py\nindex 31233f8..467f3ab 100644\n--- a/server/gameplay/test_effect_source_validation.py\n+++ b/server/gameplay/test_effect_source_validation.py\n@@ -5,14 +5,12 @@ Tests for effect source validation\n import pytest\n from pydantic import ValidationError\n \n-from server.gameplay.models import (\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n     RerollDiceEffect,\n     SkipTurnEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n \ndiff --git a/server/gameplay/test_effect_total.py b/server/gameplay/test_effect_total.py\nindex 8ee0851..b2a812b 100644\n--- a/server/gameplay/test_effect_total.py\n+++ b/server/gameplay/test_effect_total.py\n@@ -2,16 +2,14 @@\n Tests for EffectTotal aggregation in Character\n \"\"\"\n \n-from server.gameplay.models import (\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n-    Character,\n     RerollDiceEffect,\n     SkipTurnEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n+from .gameplay import Character\n \n \n def test_effect_total_empty():\ndiff --git a/server/gameplay/test_minimum_players.py b/server/gameplay/test_minimum_players.py\nindex 4478779..5949beb 100644\n--- a/server/gameplay/test_minimum_players.py\n+++ b/server/gameplay/test_minimum_players.py\n@@ -7,7 +7,7 @@ These tests verify that the game correctly handles scenarios with less than 2 pl\n import pytest\n \n from .presets import get_debug_preset, SINGLE_PLAYER\n-from .models import CHARACTER_SELECT\n+from .gameplay import CHARACTER_SELECT\n \n \n def test_single_player_preset():\ndiff --git a/server/main.py b/server/main.py\nindex 3f57ffe..165a1c6 100644\n--- a/server/main.py\n+++ b/server/main.py\n@@ -16,7 +16,7 @@ from sqlalchemy.ext.asyncio import AsyncSession\n \n from .env import REDIS_HOST, REDIS_PORT\n from .game_engine import GameEngine\n-from .gameplay.models import DEFAULT_GAME, GamePlay, StageName\n+from .gameplay.gameplay import StageName, DEFAULT_GAME, GamePlay\n from .gameplay.presets import get_debug_preset, DEBUG_PRESETS\n from .db_models import Game as GameTable\n from .database import get_db, AsyncSessionLocal\ndiff --git a/server/test_player_reordering.py b/server/test_player_reordering.py\nindex 937bcc0..0ac51fb 100644\n--- a/server/test_player_reordering.py\n+++ b/server/test_player_reordering.py\n@@ -1,6 +1,6 @@\n \"\"\"Test player reordering in GamePlay\"\"\"\n \n-from server.gameplay.models import GamePlay, Player\n+from server.gameplay.gameplay import GamePlay, Player\n \n \n def test_reorder_players_single_player():"
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      },
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/6373b30c4b3d7606c77e4c49c54a17fcb823f989",
            "commitHash": "6373b30c4b3d7606c77e4c49c54a17fcb823f989",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/32",
            "prTitle": "claude/refactor-models-split-x1B0p",
            "prBaseHash": "bc60de7d36702477e5f0572e55a805bcb1aaf0d5",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21114978943"
          },
          "gitCommit": {
            "shortHash": "6373b30",
            "hash": "6373b30c4b3d7606c77e4c49c54a17fcb823f989",
            "subject": "Merge c0faeb4893b7c34afa5fce22e2b80ffd444a0c53 into bc60de7d36702477e5f0572e55a805bcb1aaf0d5",
            "body": "Merge c0faeb4893b7c34afa5fce22e2b80ffd444a0c53 into bc60de7d36702477e5f0572e55a805bcb1aaf0d5\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768753826000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768753826000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/game_engine.py b/server/game_engine.py\nindex 0239156..6bcc9ba 100644\n--- a/server/game_engine.py\n+++ b/server/game_engine.py\n@@ -1,8 +1,5 @@\n-from .gameplay.models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-)\n+from .gameplay.models import GameException, ReportedException\n+from .gameplay.gameplay import GamePlay\n from .gameplay.actions import (\n     ACTION_MAP,\n )\ndiff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nnew file mode 100644\nindex 0000000..423dea5\n--- /dev/null\n+++ b/server/gameplay/abilities.py\n@@ -0,0 +1,79 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_ABILITY_MAP\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Apply to constants\n+    APPLY_TO_SELECTED_OPPONENT,\n+)\n+\n+########################################################\n+# Ability names - defined before imports from effects to avoid circular dependency\n+########################################################\n+BATTLE_HOWL = \"battle_howl\"\n+BOUNCING_ARROW = \"bouncing_arrow\"\n+FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+AbilityName = Literal[*ABILITIES_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which abilities can create which effects\n+# This is used for validation to ensure effects have valid source abilities\n+EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n+    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n+    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n+    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n+    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    SkipTurnEffect,\n+)\n+\n+\n+class Ability(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n+\n+    @property\n+    def requires_opponent_selection(self) -> bool:\n+        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n+        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n+\n+\n+ABILITIES_MAP: dict[AbilityName, Ability] = {\n+    BATTLE_HOWL: Ability(\n+        name=BATTLE_HOWL,\n+        effects=[\n+            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+        ],\n+    ),\n+    BOUNCING_ARROW: Ability(\n+        name=BOUNCING_ARROW,\n+        effects=[\n+            RerollDiceEffect(source=BOUNCING_ARROW),\n+        ],\n+    ),\n+    FREEZE: Ability(\n+        name=FREEZE,\n+        effects=[\n+            SkipTurnEffect(source=FREEZE),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 30001f1..2c1329f 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -1,6 +1,6 @@\n from typing import Dict\n \n-from ..models import (\n+from ..common import (\n     CONNECT,\n     LEAVE,\n     DISCONNECT,\n@@ -18,7 +18,7 @@ from ..models import (\n     ACTION_REROLL_EFFECT,\n     BATTLE_END_ACTION,\n     DEBUG_SET_BATTLE_DICE_ROLLS,\n-)\n+)  # Action constants stay in models.py\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\ndiff --git a/server/gameplay/actions/action.py b/server/gameplay/actions/action.py\nindex ed31d2e..5a045d4 100644\n--- a/server/gameplay/actions/action.py\n+++ b/server/gameplay/actions/action.py\n@@ -1,12 +1,12 @@\n from abc import ABC, abstractmethod\n from typing import Any, Dict, Optional\n \n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..gameplay import (\n+    StageName,\n     GamePlay,\n     Player,\n     Character,\n-    GameException,\n-    ReportedException,\n     ActivePlayer1,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -14,7 +14,6 @@ from ..models import (\n     Opponent2,\n     Opponent3,\n     Opponent4,\n-    StageName,\n )\n \n \ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex a3a8703..0d9861f 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -5,17 +5,16 @@ Ends the battle, calculates winner, and reduces loser's health by 1.\n \"\"\"\n \n from .action import Action\n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..gameplay import (\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n     GamePlay,\n-    GameException,\n-    ReportedException,\n     ActivePlayer1,\n     ActivePlayer3,\n     ActivePlayer4,\n     Opponent3,\n     Opponent4,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n )\n \n \n@@ -61,7 +60,7 @@ class BattleEndAction(Action):\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n-        from ..models import BATTLE_END_ACTION\n+        from ..common import BATTLE_END_ACTION\n \n         def should_keep_effect(effect):\n             \"\"\"Returns True if effect should be kept after battle\"\"\"\ndiff --git a/server/gameplay/actions/connection.py b/server/gameplay/actions/connection.py\nindex 00d4729..43b082e 100644\n--- a/server/gameplay/actions/connection.py\n+++ b/server/gameplay/actions/connection.py\n@@ -1,20 +1,22 @@\n from typing import Dict\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    Player,\n-    Character,\n-    ActivePlayer1,\n-    CHARACTER_DEFAULT_STATS,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n+)\n+from ..gameplay import (\n     CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer1,\n+    CHARACTER_DEFAULT_STATS,\n )\n \n MAX_PLAYERS = 4\ndiff --git a/server/gameplay/actions/stage_ability_opponent_selection.py b/server/gameplay/actions/stage_ability_opponent_selection.py\nindex b880404..5985c08 100644\n--- a/server/gameplay/actions/stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/stage_ability_opponent_selection.py\n@@ -7,14 +7,8 @@ This module implements actions for the ability opponent selection stage:\n \"\"\"\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    Opponent2,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-)\n+from ..common import GameException, ReportedException\n+from ..gameplay import ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class AbilityOpponentPressAction(Action):\ndiff --git a/server/gameplay/actions/stage_ability_selection.py b/server/gameplay/actions/stage_ability_selection.py\nindex 4d5a556..af35bf2 100644\n--- a/server/gameplay/actions/stage_ability_selection.py\n+++ b/server/gameplay/actions/stage_ability_selection.py\n@@ -9,17 +9,11 @@ This module implements actions for the ability selection stage:\n \n import copy\n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    AbilitySelectMeta,\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    APPLY_TO_SELF,\n-    AbilityName,\n-)\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF\n+from ..abilities import AbilityName\n+from ..gameplay import ABILITY_SELECTION, ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION\n+from ..gameplay import GamePlay, AbilitySelectMeta\n \n \n class AbilityPressAction(Action):\ndiff --git a/server/gameplay/actions/stage_battle.py b/server/gameplay/actions/stage_battle.py\nindex 824d737..a8fe573 100644\n--- a/server/gameplay/actions/stage_battle.py\n+++ b/server/gameplay/actions/stage_battle.py\n@@ -10,20 +10,19 @@ This module implements actions for the battle stage:\n \n import random\n from .action import Action\n-from ..models import (\n+from ..common import GameException, ReportedException\n+from ..effects import RerollDiceEffect\n+from ..gameplay import (\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n     GamePlay,\n-    GameException,\n-    ReportedException,\n     ActivePlayer2,\n     ActivePlayer3,\n     ActivePlayer4,\n     Opponent2,\n     Opponent3,\n     Opponent4,\n-    RerollDiceEffect,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n )\n \n \n@@ -73,7 +72,7 @@ def set_winner_if_both_rolled(game: GamePlay) -> None:\n     opponent_is_winner = opponent_score > active_score\n \n     # Import BattleResult at top of function to avoid circular imports\n-    from ..models import BattleResult\n+    from ..gameplay import BattleResult\n \n     # Upgrade to ActivePlayer4 and Opponent4 with result fields\n     game.active = ActivePlayer4(\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 6687b83..474748e 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -7,16 +7,18 @@ This module implements actions for the character selection stage:\n \"\"\"\n \n from .action import Action\n-from ..models import (\n-    GamePlay,\n+from ..common import (\n     GameException,\n     ReportedException,\n+    CHARACTER_SELECT_ACTION,\n+)\n+from ..gameplay import (\n+    ABILITY_SELECTION,\n+    CHARACTER_SELECT,\n+    GamePlay,\n     CharacterSelectMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n-    ABILITY_SELECTION,\n-    CHARACTER_SELECT,\n-    CHARACTER_SELECT_ACTION,\n )\n \n \ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex 3404bb1..ff48b63 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -8,15 +8,9 @@ This module implements actions for the opponent selection stage:\n \n import copy\n from .action import Action\n-from ..models import (\n-    GamePlay,\n-    GameException,\n-    ReportedException,\n-    Opponent2,\n-    BATTLE_DICE_ROLL,\n-    OPPONENT_SELECTION,\n-    APPLY_TO_BATTLE_OPPONENT,\n-)\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_BATTLE_OPPONENT\n+from ..gameplay import BATTLE_DICE_ROLL, OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class OpponentPressAction(Action):\ndiff --git a/server/gameplay/actions/test_action_properties.py b/server/gameplay/actions/test_action_properties.py\nindex f015215..858c847 100644\n--- a/server/gameplay/actions/test_action_properties.py\n+++ b/server/gameplay/actions/test_action_properties.py\n@@ -7,7 +7,10 @@ These tests verify that action properties work correctly across different game s\n import pytest\n \n from .action import Action\n-from ..models import (\n+from ..common import GameException, KNIGHT, MAGE, ARCHER\n+from ..gameplay import (\n+    BATTLE_DICE_ROLL,\n+    CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     ActivePlayer1,\n@@ -18,12 +21,6 @@ from ..models import (\n     Opponent3,\n     Opponent4,\n     BattleResult,\n-    GameException,\n-    BATTLE_DICE_ROLL,\n-    CHARACTER_SELECT,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n     init_characters,\n     KNIGHT_L1_DEFAULT_HEALTH,\n     KNIGHT_L1_DICE,\ndiff --git a/server/gameplay/actions/test_connect_action.py b/server/gameplay/actions/test_connect_action.py\nindex bd27db1..1629a64 100644\n--- a/server/gameplay/actions/test_connect_action.py\n+++ b/server/gameplay/actions/test_connect_action.py\n@@ -8,19 +8,21 @@ reconnections, game capacity limits, and character initialization.\n import pytest\n \n from .connection import ConnectAction, MAX_PLAYERS\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Character,\n-    ActivePlayer1,\n+from ..common import (\n     ReportedException,\n-    CHARACTER_DEFAULT_STATS,\n-    CHARACTER_SELECT,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n+)\n+from ..gameplay import (\n+    CHARACTER_SELECT,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer1,\n+    CHARACTER_DEFAULT_STATS,\n     ARCHER_L1_ATTACK,\n     MAGE_L1_ATTACK,\n )\ndiff --git a/server/gameplay/actions/test_connection_integration.py b/server/gameplay/actions/test_connection_integration.py\nindex dd899ae..e63bdab 100644\n--- a/server/gameplay/actions/test_connection_integration.py\n+++ b/server/gameplay/actions/test_connection_integration.py\n@@ -9,12 +9,8 @@ and leaving actions.\n import pytest\n \n from .connection import ConnectAction, DisconnectAction, LeaveAction\n-from ..models import (\n-    GamePlay,\n-    CHARACTER_SELECT,\n-    CONNECTED,\n-    DISCONNECTED,\n-)\n+from ..common import CONNECTED, DISCONNECTED\n+from ..gameplay import CHARACTER_SELECT, GamePlay\n \n \n def test_connect_then_disconnect_then_reconnect():\ndiff --git a/server/gameplay/actions/test_disconnect_action.py b/server/gameplay/actions/test_disconnect_action.py\nindex aad505f..2337f53 100644\n--- a/server/gameplay/actions/test_disconnect_action.py\n+++ b/server/gameplay/actions/test_disconnect_action.py\n@@ -8,18 +8,20 @@ existing players, nonexistent players, and already disconnected players.\n import pytest\n \n from .connection import DisconnectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Character,\n+from ..common import (\n     GameException,\n-    CHARACTER_DEFAULT_STATS,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n     CONNECTED,\n     DISCONNECTED,\n )\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    Character,\n+    CHARACTER_DEFAULT_STATS,\n+)\n \n \n def test_disconnect_action_existing_player():\ndiff --git a/server/gameplay/actions/test_leave_action.py b/server/gameplay/actions/test_leave_action.py\nindex cdf2e8a..e67ef2e 100644\n--- a/server/gameplay/actions/test_leave_action.py\n+++ b/server/gameplay/actions/test_leave_action.py\n@@ -9,15 +9,12 @@ the only player leaving.\n import pytest\n \n from .connection import LeaveAction\n-from ..models import (\n+from ..common import GameException, KNIGHT, ARCHER, MAGE\n+from ..gameplay import (\n     GamePlay,\n     Player,\n     Character,\n-    GameException,\n     CHARACTER_DEFAULT_STATS,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n )\n \n \ndiff --git a/server/gameplay/actions/test_stage_ability_opponent_selection.py b/server/gameplay/actions/test_stage_ability_opponent_selection.py\nindex c25173c..75dfb7d 100644\n--- a/server/gameplay/actions/test_stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_opponent_selection.py\n@@ -8,20 +8,15 @@ selected opponents for ability targeting and confirming selections to apply effe\n import pytest\n \n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n-from ..models import (\n+from ..common import GameException, ReportedException, KNIGHT, MAGE\n+from ..abilities import BATTLE_HOWL, FREEZE, ABILITIES_MAP\n+from ..gameplay import (\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n     GamePlay,\n     Player,\n     ActivePlayer2,\n-    GameException,\n-    ReportedException,\n     Opponent2,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    KNIGHT,\n-    MAGE,\n-    BATTLE_HOWL,\n-    FREEZE,\n-    ABILITIES_MAP,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_ability_selection.py b/server/gameplay/actions/test_stage_ability_selection.py\nindex 9e3b7df..b3c0106 100644\n--- a/server/gameplay/actions/test_stage_ability_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_selection.py\n@@ -10,24 +10,26 @@ selected abilities and confirming selections to transition to:\n import pytest\n \n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer2,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    RerollDiceEffect,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..effects import REROLL_DICE\n+from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..gameplay import (\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n     CHARACTER_SELECT,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n-    REROLL_DICE,\n+)\n+from ..effects import RerollDiceEffect\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer2,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_battle_dice_roll.py b/server/gameplay/actions/test_stage_battle_dice_roll.py\nindex 08d71b9..bbc80fd 100644\n--- a/server/gameplay/actions/test_stage_battle_dice_roll.py\n+++ b/server/gameplay/actions/test_stage_battle_dice_roll.py\n@@ -16,32 +16,36 @@ from .stage_battle import (\n     calculate_winner,\n     set_winner_if_both_rolled,\n )\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer1,\n-    ActivePlayer2,\n-    ActivePlayer3,\n-    ActivePlayer4,\n-    Opponent2,\n-    Opponent3,\n-    Opponent4,\n+from ..common import (\n     GameException,\n     ReportedException,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n+)\n+from ..gameplay import (\n     BATTLE_DICE_ROLL,\n     BATTLE_END,\n     CHARACTER_SELECT,\n     OPPONENT_SELECTION,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n+)\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer1,\n+    ActivePlayer2,\n+    ActivePlayer3,\n+    ActivePlayer4,\n+    Opponent2,\n+    Opponent3,\n+    Opponent4,\n     init_characters,\n )\n from ..presets import get_debug_preset, EFFECT_REROLL\ndiff --git a/server/gameplay/actions/test_stage_battle_end.py b/server/gameplay/actions/test_stage_battle_end.py\nindex 7c0e543..996f74f 100644\n--- a/server/gameplay/actions/test_stage_battle_end.py\n+++ b/server/gameplay/actions/test_stage_battle_end.py\n@@ -13,25 +13,22 @@ Effect disposal rules:\n import pytest\n \n from .battle_end import BattleEndAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    ActivePlayer4,\n-    Opponent4,\n-    BattleResult,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    AttackNegBonusEffect,\n-    SkipTurnEffect,\n-    RerollDiceEffect,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n     KNIGHT,\n     MAGE,\n     ARCHER,\n-    BATTLE_HOWL,\n-    FREEZE,\n-    BOUNCING_ARROW,\n+)\n+from ..abilities import BATTLE_HOWL, FREEZE, BOUNCING_ARROW\n+from ..gameplay import BATTLE_END, CHARACTER_SELECT\n+from ..effects import AttackNegBonusEffect, SkipTurnEffect, RerollDiceEffect\n+from ..gameplay import (\n+    GamePlay,\n+    Player,\n+    ActivePlayer4,\n+    Opponent4,\n+    BattleResult,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_character_select.py b/server/gameplay/actions/test_stage_character_select.py\nindex 9c65b90..cd8722f 100644\n--- a/server/gameplay/actions/test_stage_character_select.py\n+++ b/server/gameplay/actions/test_stage_character_select.py\n@@ -8,24 +8,25 @@ selected characters and confirming selections to transition to battle.\n import pytest\n \n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n-from ..models import (\n+from ..common import (\n+    GameException,\n+    ReportedException,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+from ..abilities import FREEZE, BATTLE_HOWL\n+from ..effects import SkipTurnEffect\n+from ..gameplay import (\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    BATTLE_DICE_ROLL,\n     GamePlay,\n     Player,\n     Character,\n     ActivePlayer1,\n     ActivePlayer2,\n-    GameException,\n-    ReportedException,\n-    SkipTurnEffect,\n     CHARACTER_DEFAULT_STATS,\n-    CHARACTER_SELECT,\n-    ABILITY_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    FREEZE,\n-    BATTLE_HOWL,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/actions/test_stage_opponent_selection.py b/server/gameplay/actions/test_stage_opponent_selection.py\nindex dae8343..9ee53b4 100644\n--- a/server/gameplay/actions/test_stage_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_opponent_selection.py\n@@ -8,25 +8,25 @@ selected opponents and confirming selections to transition to battle.\n import pytest\n \n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n-from ..models import (\n-    GamePlay,\n-    Player,\n-    Ability,\n-    Character,\n-    ActivePlayer2,\n+from ..common import (\n     GameException,\n     ReportedException,\n-    Opponent2,\n-    AttackNegBonusEffect,\n-    CHARACTER_DEFAULT_STATS,\n-    OPPONENT_SELECTION,\n-    BATTLE_DICE_ROLL,\n     KNIGHT,\n     ARCHER,\n     MAGE,\n-    BATTLE_HOWL,\n     ATTACK_NEG_BONUS,\n-    ABILITIES_MAP,\n+)\n+from ..abilities import Ability, BATTLE_HOWL, ABILITIES_MAP\n+from ..effects import AttackNegBonusEffect\n+from ..gameplay import (\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    GamePlay,\n+    Player,\n+    Character,\n+    ActivePlayer2,\n+    Opponent2,\n+    CHARACTER_DEFAULT_STATS,\n     init_characters,\n )\n \ndiff --git a/server/gameplay/common.py b/server/gameplay/common.py\nnew file mode 100644\nindex 0000000..0f5d9c3\n--- /dev/null\n+++ b/server/gameplay/common.py\n@@ -0,0 +1,134 @@\n+\"\"\"\n+Base models and utilities - foundation for effects, abilities, and gameplay modules.\n+\"\"\"\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import BaseModel, ConfigDict\n+\n+\n+########################################################\n+# Connection statuses\n+########################################################\n+CONNECTED = \"connected\"\n+DISCONNECTED = \"disconnected\"\n+CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n+ConnectionStatus = Literal[*CONNECTION_STATUSES]\n+\n+########################################################\n+# Character types\n+########################################################\n+KNIGHT = \"knight\"\n+ARCHER = \"archer\"\n+MAGE = \"mage\"\n+CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n+ChatacterType = Literal[*CHARACTER_TYPES]\n+\n+########################################################\n+# Actions\n+########################################################\n+CONNECT = \"connect\"\n+LEAVE = \"leave\"\n+DISCONNECT = \"disconnect\"\n+CHARACTER_PRESS = \"character_press\"\n+CHARACTER_SELECT_ACTION = \"character_select\"\n+ABILITY_PRESS = \"ability_press\"\n+ABILITY_SELECT = \"ability_select\"\n+ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n+ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n+OPPONENT_PRESS = \"opponent_press\"\n+OPPONENT_SELECT = \"opponent_select\"\n+ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n+OPPONENT_ROLL = \"opponent_roll\"\n+ACTION_REROLL = \"action_reroll\"\n+ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n+BATTLE_END_ACTION = \"battle_end\"\n+DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n+\n+ACTION_NAMES = [\n+    CONNECT,\n+    LEAVE,\n+    DISCONNECT,\n+    CHARACTER_PRESS,\n+    CHARACTER_SELECT_ACTION,\n+    ABILITY_PRESS,\n+    ABILITY_SELECT,\n+    ABILITY_OPPONENT_PRESS,\n+    ABILITY_OPPONENT_SELECT,\n+    OPPONENT_PRESS,\n+    OPPONENT_SELECT,\n+    ACTIVE_PLAYER_ROLL,\n+    OPPONENT_ROLL,\n+    ACTION_REROLL,\n+    ACTION_REROLL_EFFECT,\n+    BATTLE_END_ACTION,\n+    DEBUG_SET_BATTLE_DICE_ROLLS,\n+]\n+ActionName = Literal[*ACTION_NAMES]\n+\n+\n+########################################################\n+# Exceptions\n+########################################################\n+class GameException(Exception):\n+    pass\n+\n+\n+class ReportedException(GameException):\n+    pass\n+\n+\n+########################################################\n+# Base model utilities\n+########################################################\n+def recursive_db_model_dump(model: BaseModel) -> dict:\n+    \"\"\"\n+    Recursively dump model for database storage.\n+    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n+    \"\"\"\n+    result = {}\n+\n+    # Iterate over all fields and their values\n+    for field_name, field_value in model:\n+        if isinstance(field_value, BaseModel):\n+            # Nested model - call its db_model_dump if it's a StrictModel\n+            if hasattr(field_value, \"db_model_dump\"):\n+                result[field_name] = field_value.db_model_dump()\n+            else:\n+                result[field_name] = field_value.model_dump()\n+        elif isinstance(field_value, dict):\n+            # Dict of values (possibly models)\n+            result[field_name] = {\n+                k: (\n+                    v.db_model_dump()\n+                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n+                    else v.model_dump() if isinstance(v, BaseModel) else v\n+                )\n+                for k, v in field_value.items()\n+            }\n+        elif isinstance(field_value, (list, tuple, set)):\n+            # Collection of values (possibly models) - preserve collection type\n+            processed_items = [\n+                (\n+                    item.db_model_dump()\n+                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n+                    else item.model_dump() if isinstance(item, BaseModel) else item\n+                )\n+                for item in field_value\n+            ]\n+            # Preserve the original collection type\n+            result[field_name] = type(field_value)(processed_items)\n+        else:\n+            # Primitive value\n+            result[field_name] = field_value\n+\n+    return result\n+\n+\n+class StrictModel(BaseModel):\n+    model_config = ConfigDict(extra=\"forbid\")\n+\n+    def db_model_dump(self) -> dict:\n+        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n+        return recursive_db_model_dump(self)\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nnew file mode 100644\nindex 0000000..c8526fa\n--- /dev/null\n+++ b/server/gameplay/effects.py\n@@ -0,0 +1,145 @@\n+from __future__ import annotations\n+\n+from typing import Literal, Annotated, Union, Self\n+\n+from pydantic import Field, model_validator\n+\n+from .common import (\n+    StrictModel,\n+    ActionName,\n+    # Action name constants for dispose_actions\n+    CHARACTER_SELECT_ACTION,\n+    BATTLE_END_ACTION,\n+    ACTION_REROLL_EFFECT,\n+)\n+\n+########################################################\n+# Effect names\n+########################################################\n+ATTACK_BONUS = \"attack_bonus\"\n+ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+REROLL_DICE = \"reroll_dice\"\n+SKIP_TURN = \"skip_turn\"\n+DRAW_CARD = \"draw_card\"\n+\n+########################################################\n+# Effect apply_to targets\n+########################################################\n+APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n+APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n+APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n+\n+APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n+ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n+\n+\n+class Effect(StrictModel):\n+    \"\"\"\n+    Base class for all effects.\n+    Each effect specifies when it should be disposed via dispose_actions field.\n+    Each effect specifies who receives the effect via apply_to field.\n+    \"\"\"\n+\n+    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n+    source: str  # AbilityName - using str to avoid circular import\n+    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n+    apply_to: ApplyToTarget  # Who receives this effect\n+\n+    @model_validator(mode=\"after\")\n+    def validate_source(self) -> Self:\n+        \"\"\"Validate that source is valid for this effect type\"\"\"\n+        # Lazy import to avoid circular dependency\n+        from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n+\n+        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        if self.source not in valid_sources and len(valid_sources) > 0:\n+            raise ValueError(\n+                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n+                f\"Valid sources: {valid_sources}\"\n+            )\n+        return self\n+\n+\n+class SkipTurnEffect(Effect):\n+    \"\"\"\n+    Character can't participate in the next turn.\n+    Disposed after character selection.\n+    Applied to selected opponent (requires ability_opponent_selection stage).\n+    \"\"\"\n+\n+    name: Literal[SKIP_TURN] = SKIP_TURN\n+    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n+    skip_next_turn: bool = True\n+\n+\n+class AttackBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is increased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    attack_bonus: int\n+\n+\n+class RerollDiceEffect(Effect):\n+    \"\"\"\n+    Character's dice are rerolled if lost the battle.\n+    Disposed at battle end or when the reroll effect action is used.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[REROLL_DICE] = REROLL_DICE\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    reroll_dice: bool = True\n+\n+\n+class AttackNegBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is decreased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to battle opponent (no separate selection required).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n+    attack_neg_bonus: int\n+\n+\n+class DrawCardEffect(Effect):\n+    \"\"\"\n+    Character draws cards at the start of battle.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DRAW_CARD] = DRAW_CARD\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    draw_count: int = 1\n+\n+\n+# Define EffectUnion for discriminated union of all effect types (without base classes)\n+EffectUnion = Annotated[\n+    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Field(discriminator=\"name\"),\n+]\n+\n+\n+class EffectTotal(StrictModel):\n+    \"\"\"\n+    Aggregated effect totals for a character.\n+    Combines all active effects into a single summary.\n+    \"\"\"\n+\n+    attack_bonus: int = 0\n+    attack_neg_bonus: int = 0\n+    skip_next_turn: bool = False\n+    reroll_dice_available: bool = False\n+    draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nnew file mode 100644\nindex 0000000..937d1f7\n--- /dev/null\n+++ b/server/gameplay/gameplay.py\n@@ -0,0 +1,254 @@\n+from __future__ import annotations\n+\n+from typing import Dict, Literal, Optional\n+\n+from pydantic import Field, computed_field\n+\n+from .common import (\n+    StrictModel,\n+    ConnectionStatus,\n+    ChatacterType,\n+    CONNECTED,\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+)\n+\n+########################################################\n+# Stages\n+########################################################\n+CHARACTER_SELECT = \"character_select\"\n+ABILITY_SELECTION = \"ability_selection\"\n+ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n+OPPONENT_SELECTION = \"opponent_selection\"\n+BATTLE_DICE_ROLL = \"battle_dice_roll\"\n+BATTLE_END = \"battle_end\"\n+STAGES_NAMES = [\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+]\n+StageName = Literal[*STAGES_NAMES]\n+\n+from .abilities import (\n+    Ability,\n+    ABILITIES_MAP,\n+    AbilityName,\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+)\n+from .effects import (\n+    EffectUnion,\n+    EffectTotal,\n+    AttackBonusEffect,\n+    AttackNegBonusEffect,\n+    SkipTurnEffect,\n+    RerollDiceEffect,\n+    DrawCardEffect,\n+)\n+\n+\n+class Character(StrictModel):\n+\n+    level: int\n+    health: int\n+    max_health: int\n+    dice: int\n+    attack: int\n+    abilities: list[Ability] = Field(default_factory=list)\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+    @computed_field\n+    @property\n+    def is_alive(self) -> bool:\n+        \"\"\"Character is alive if health > 0\"\"\"\n+        return self.health > 0\n+\n+    @computed_field\n+    @property\n+    def effect(self) -> EffectTotal:\n+        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n+        total = EffectTotal()\n+\n+        for eff in self.effects:\n+            if isinstance(eff, AttackBonusEffect):\n+                total.attack_bonus += eff.attack_bonus\n+            elif isinstance(eff, AttackNegBonusEffect):\n+                total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, SkipTurnEffect):\n+                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n+            elif isinstance(eff, RerollDiceEffect):\n+                total.reroll_dice_available = True\n+            elif isinstance(eff, DrawCardEffect):\n+                total.draw_card_count += eff.draw_count\n+\n+        return total\n+\n+    def db_model_dump(self) -> dict:\n+        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n+\n+\n+class CharacterSelectMeta(StrictModel):\n+    \"\"\"Stage metadata for character selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted character\n+\n+\n+class AbilitySelectMeta(StrictModel):\n+    \"\"\"Stage metadata for ability selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted ability\n+\n+\n+class ActivePlayer1(StrictModel):\n+    \"\"\"Selected character for battle\"\"\"\n+\n+    player: str  # Character name\n+\n+\n+class BattleResult(StrictModel):\n+    winner: bool\n+    score: int  # result of the battle, sum of dice_roll and attack\n+\n+\n+class ActivePlayer2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class ActivePlayer3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class ActivePlayer4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n+\n+\n+class Opponent2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class Opponent3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class Opponent4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+Opponent = Opponent2 | Opponent3 | Opponent4\n+\n+\n+class Player(StrictModel):\n+    name: str\n+    status: ConnectionStatus = CONNECTED\n+    cards: list[str] = Field(default_factory=list)\n+    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n+\n+\n+########################################################\n+# GamePlay model\n+########################################################\n+class GamePlay(StrictModel):\n+    stage: StageName = CHARACTER_SELECT\n+    players: dict[str, Player] = Field(default_factory=dict)\n+    active: Optional[ActivePlayer] = None  # The active player and its selections\n+    ability: Optional[Ability] = None  # Selected ability\n+    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n+    opponent: Optional[Opponent] = None  # Selected opponent for battle\n+    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+\n+    def reorder_players(self, username: str):\n+        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n+        if username not in self.players:\n+            return\n+\n+        # Get all player keys\n+        player_keys = list(self.players.keys())\n+\n+        # Find the index of the username\n+        user_index = player_keys.index(username)\n+\n+        # Circular shift: username first, then the rest\n+        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n+\n+        # Build new dict with reordered keys\n+        reordered_dict = {key: self.players[key] for key in reordered_keys}\n+\n+        # Update in-place\n+        self.players.clear()\n+        self.players.update(reordered_dict)\n+\n+\n+DEFAULT_GAME = GamePlay()\n+\n+########################################################\n+# Character default stats\n+########################################################\n+KNIGHT_L1_DEFAULT_HEALTH = 2\n+KNIGHT_L1_MAX_HEALTH = 2\n+KNIGHT_L1_DICE = 1\n+KNIGHT_L1_ATTACK = 1\n+KNIGHT_L1_ABILITY = BATTLE_HOWL\n+\n+ARCHER_L1_DEFAULT_HEALTH = 3\n+ARCHER_L1_MAX_HEALTH = 3\n+ARCHER_L1_DICE = 1\n+ARCHER_L1_ATTACK = 0\n+ARCHER_L1_ABILITY = BOUNCING_ARROW\n+\n+MAGE_L1_DEFAULT_HEALTH = 2\n+MAGE_L1_MAX_HEALTH = 2\n+MAGE_L1_DICE = 1\n+MAGE_L1_ATTACK = 0\n+MAGE_L1_ABILITY = FREEZE\n+\n+CHARACTER_DEFAULT_STATS = {\n+    \"knight\": {\n+        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n+        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n+        \"dice\": KNIGHT_L1_DICE,\n+        \"attack\": KNIGHT_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n+    },\n+    \"archer\": {\n+        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n+        \"max_health\": ARCHER_L1_MAX_HEALTH,\n+        \"dice\": ARCHER_L1_DICE,\n+        \"attack\": ARCHER_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n+    },\n+    \"mage\": {\n+        \"health\": MAGE_L1_DEFAULT_HEALTH,\n+        \"max_health\": MAGE_L1_MAX_HEALTH,\n+        \"dice\": MAGE_L1_DICE,\n+        \"attack\": MAGE_L1_ATTACK,\n+        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n+    },\n+}\n+\n+\n+def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n+    \"\"\"Initialize all character types with default stats\"\"\"\n+    return {\n+        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n+        for char_type in [KNIGHT, ARCHER, MAGE]\n+    }\ndiff --git a/server/gameplay/models.py b/server/gameplay/models.py\ndeleted file mode 100644\nindex d8a1106..0000000\n--- a/server/gameplay/models.py\n+++ /dev/null\n@@ -1,512 +0,0 @@\n-from typing import Dict, Optional, Literal, Annotated, Union, Self\n-\n-from pydantic import BaseModel, ConfigDict, Field, computed_field, Discriminator, model_validator\n-\n-########################################################\n-# Connection statuses\n-########################################################\n-CONNECTED = \"connected\"\n-DISCONNECTED = \"disconnected\"\n-CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n-ConnectionStatus = Literal[*CONNECTION_STATUSES]\n-\n-########################################################\n-# Stages\n-########################################################\n-CHARACTER_SELECT = \"character_select\"\n-ABILITY_SELECTION = \"ability_selection\"\n-ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n-OPPONENT_SELECTION = \"opponent_selection\"\n-BATTLE_DICE_ROLL = \"battle_dice_roll\"\n-BATTLE_END = \"battle_end\"\n-STAGES_NAMES = [\n-    CHARACTER_SELECT,\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-]\n-StageName = Literal[*STAGES_NAMES]\n-\n-########################################################\n-# Character types\n-########################################################\n-KNIGHT = \"knight\"\n-ARCHER = \"archer\"\n-MAGE = \"mage\"\n-CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n-ChatacterType = Literal[*CHARACTER_TYPES]\n-\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n-AbilityName = Literal[*ABILITIES_NAMES]\n-\n-# Effect names\n-ATTACK_BONUS = \"attack_bonus\"\n-ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n-REROLL_DICE = \"reroll_dice\"\n-SKIP_TURN = \"skip_turn\"\n-DRAW_CARD = \"draw_card\"\n-\n-# Effect apply_to targets - specifies who receives the effect\n-APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n-APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n-APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n-\n-APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n-ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n-\n-# Effect-to-Source mapping: defines which abilities can create which effects\n-# This is used for validation to ensure effects have valid source abilities\n-EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n-}\n-\n-########################################################\n-# Actions\n-########################################################\n-CONNECT = \"connect\"\n-LEAVE = \"leave\"\n-DISCONNECT = \"disconnect\"\n-CHARACTER_PRESS = \"character_press\"\n-CHARACTER_SELECT_ACTION = \"character_select\"\n-ABILITY_PRESS = \"ability_press\"\n-ABILITY_SELECT = \"ability_select\"\n-ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n-ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n-OPPONENT_PRESS = \"opponent_press\"\n-OPPONENT_SELECT = \"opponent_select\"\n-ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n-OPPONENT_ROLL = \"opponent_roll\"\n-ACTION_REROLL = \"action_reroll\"\n-ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n-BATTLE_END_ACTION = \"battle_end\"\n-DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n-\n-ACTION_NAMES = [\n-    CONNECT,\n-    LEAVE,\n-    DISCONNECT,\n-    CHARACTER_PRESS,\n-    CHARACTER_SELECT_ACTION,\n-    ABILITY_PRESS,\n-    ABILITY_SELECT,\n-    ABILITY_OPPONENT_PRESS,\n-    ABILITY_OPPONENT_SELECT,\n-    OPPONENT_PRESS,\n-    OPPONENT_SELECT,\n-    ACTIVE_PLAYER_ROLL,\n-    OPPONENT_ROLL,\n-    ACTION_REROLL,\n-    ACTION_REROLL_EFFECT,\n-    BATTLE_END_ACTION,\n-    DEBUG_SET_BATTLE_DICE_ROLLS,\n-]\n-ActionName = Literal[*ACTION_NAMES]\n-\n-\n-class GameException(Exception):\n-    pass\n-\n-\n-class ReportedException(GameException):\n-    pass\n-\n-\n-def recursive_db_model_dump(model: BaseModel) -> dict:\n-    \"\"\"\n-    Recursively dump model for database storage.\n-    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n-    \"\"\"\n-    result = {}\n-\n-    # Iterate over all fields and their values\n-    for field_name, field_value in model:\n-        if isinstance(field_value, BaseModel):\n-            # Nested model - call its db_model_dump if it's a StrictModel\n-            if hasattr(field_value, \"db_model_dump\"):\n-                result[field_name] = field_value.db_model_dump()\n-            else:\n-                result[field_name] = field_value.model_dump()\n-        elif isinstance(field_value, dict):\n-            # Dict of values (possibly models)\n-            result[field_name] = {\n-                k: (\n-                    v.db_model_dump()\n-                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n-                    else v.model_dump() if isinstance(v, BaseModel) else v\n-                )\n-                for k, v in field_value.items()\n-            }\n-        elif isinstance(field_value, (list, tuple, set)):\n-            # Collection of values (possibly models) - preserve collection type\n-            processed_items = [\n-                (\n-                    item.db_model_dump()\n-                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n-                    else item.model_dump() if isinstance(item, BaseModel) else item\n-                )\n-                for item in field_value\n-            ]\n-            # Preserve the original collection type\n-            result[field_name] = type(field_value)(processed_items)\n-        else:\n-            # Primitive value\n-            result[field_name] = field_value\n-\n-    return result\n-\n-\n-class StrictModel(BaseModel):\n-    model_config = ConfigDict(extra=\"forbid\")\n-\n-    def db_model_dump(self) -> dict:\n-        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n-        return recursive_db_model_dump(self)\n-\n-\n-class Effect(StrictModel):\n-    \"\"\"\n-    Base class for all effects.\n-    Each effect specifies when it should be disposed via dispose_actions field.\n-    Each effect specifies who receives the effect via apply_to field.\n-    \"\"\"\n-\n-    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n-    source: AbilityName\n-    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n-    apply_to: ApplyToTarget  # Who receives this effect\n-\n-    @model_validator(mode=\"after\")\n-    def validate_source(self) -> Self:\n-        \"\"\"Validate that source is valid for this effect type\"\"\"\n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n-        if self.source not in valid_sources and len(valid_sources) > 0:\n-            raise ValueError(\n-                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n-                f\"Valid sources: {valid_sources}\"\n-            )\n-        return self\n-\n-\n-class SkipTurnEffect(Effect):\n-    \"\"\"\n-    Character can't participate in the next turn.\n-    Disposed after character selection.\n-    Applied to selected opponent (requires ability_opponent_selection stage).\n-    \"\"\"\n-\n-    name: Literal[SKIP_TURN] = SKIP_TURN\n-    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n-    skip_next_turn: bool = True\n-\n-\n-class AttackBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is increased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    attack_bonus: int\n-\n-\n-class RerollDiceEffect(Effect):\n-    \"\"\"\n-    Character's dice are rerolled if lost the battle.\n-    Disposed at battle end or when the reroll effect action is used.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[REROLL_DICE] = REROLL_DICE\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    reroll_dice: bool = True\n-\n-\n-class AttackNegBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is decreased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to battle opponent (no separate selection required).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n-    attack_neg_bonus: int\n-\n-\n-class DrawCardEffect(Effect):\n-    \"\"\"\n-    Character draws cards at the start of battle.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[DRAW_CARD] = DRAW_CARD\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    draw_count: int = 1\n-\n-\n-# Define EffectUnion for discriminated union of all effect types (without base classes)\n-EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n-    Field(discriminator=\"name\"),\n-]\n-\n-\n-class Ability(StrictModel):\n-    name: str\n-    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n-\n-    @property\n-    def requires_opponent_selection(self) -> bool:\n-        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n-        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n-\n-\n-class EffectTotal(StrictModel):\n-    \"\"\"\n-    Aggregated effect totals for a character.\n-    Combines all active effects into a single summary.\n-    \"\"\"\n-\n-    attack_bonus: int = 0\n-    attack_neg_bonus: int = 0\n-    skip_next_turn: bool = False\n-    reroll_dice_available: bool = False\n-    draw_card_count: int = 0\n-\n-\n-ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n-        effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n-        ],\n-    ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n-        effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n-        ],\n-    ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n-        effects=[\n-            SkipTurnEffect(source=FREEZE),\n-        ],\n-    ),\n-}\n-\n-\n-class Character(StrictModel):\n-\n-    level: int\n-    health: int\n-    max_health: int\n-    dice: int\n-    attack: int\n-    abilities: list[Ability] = Field(default_factory=list)\n-    effects: list[EffectUnion] = Field(default_factory=list)\n-\n-    @computed_field\n-    @property\n-    def is_alive(self) -> bool:\n-        \"\"\"Character is alive if health > 0\"\"\"\n-        return self.health > 0\n-\n-    @computed_field\n-    @property\n-    def effect(self) -> EffectTotal:\n-        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n-        total = EffectTotal()\n-\n-        for eff in self.effects:\n-            if isinstance(eff, AttackBonusEffect):\n-                total.attack_bonus += eff.attack_bonus\n-            elif isinstance(eff, AttackNegBonusEffect):\n-                total.attack_neg_bonus += eff.attack_neg_bonus\n-            elif isinstance(eff, SkipTurnEffect):\n-                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n-            elif isinstance(eff, RerollDiceEffect):\n-                total.reroll_dice_available = True\n-            elif isinstance(eff, DrawCardEffect):\n-                total.draw_card_count += eff.draw_count\n-\n-        return total\n-\n-    def db_model_dump(self) -> dict:\n-        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n-\n-\n-class CharacterSelectMeta(StrictModel):\n-    \"\"\"Stage metadata for character selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted character\n-\n-\n-class AbilitySelectMeta(StrictModel):\n-    \"\"\"Stage metadata for ability selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted ability\n-\n-\n-class ActivePlayer1(StrictModel):\n-    \"\"\"Selected character for battle\"\"\"\n-\n-    player: str  # Character name\n-\n-\n-class BattleResult(StrictModel):\n-    winner: bool\n-    score: int  # result of the battle, sum of dice_roll and attack\n-\n-\n-class ActivePlayer2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class ActivePlayer3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class ActivePlayer4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n-\n-\n-class Opponent2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class Opponent3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class Opponent4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-Opponent = Opponent2 | Opponent3 | Opponent4\n-\n-\n-class Player(StrictModel):\n-    name: str\n-    status: ConnectionStatus = CONNECTED\n-    cards: list[str] = Field(default_factory=list)\n-    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n-\n-\n-########################################################\n-# GamePlay model\n-########################################################\n-class GamePlay(StrictModel):\n-    stage: StageName = CHARACTER_SELECT\n-    players: dict[str, Player] = Field(default_factory=dict)\n-    active: Optional[ActivePlayer] = None  # The active player and its selections\n-    ability: Optional[Ability] = None  # Selected ability\n-    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n-    opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n-\n-    def reorder_players(self, username: str):\n-        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n-        if username not in self.players:\n-            return\n-\n-        # Get all player keys\n-        player_keys = list(self.players.keys())\n-\n-        # Find the index of the username\n-        user_index = player_keys.index(username)\n-\n-        # Circular shift: username first, then the rest\n-        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n-\n-        # Build new dict with reordered keys\n-        reordered_dict = {key: self.players[key] for key in reordered_keys}\n-\n-        # Update in-place\n-        self.players.clear()\n-        self.players.update(reordered_dict)\n-\n-\n-DEFAULT_GAME = GamePlay()\n-\n-KNIGHT_L1_DEFAULT_HEALTH = 2\n-KNIGHT_L1_MAX_HEALTH = 2\n-KNIGHT_L1_DICE = 1\n-KNIGHT_L1_ATTACK = 1\n-KNIGHT_L1_ABILITY = BATTLE_HOWL\n-\n-ARCHER_L1_DEFAULT_HEALTH = 3\n-ARCHER_L1_MAX_HEALTH = 3\n-ARCHER_L1_DICE = 1\n-ARCHER_L1_ATTACK = 0\n-ARCHER_L1_ABILITY = BOUNCING_ARROW\n-\n-MAGE_L1_DEFAULT_HEALTH = 2\n-MAGE_L1_MAX_HEALTH = 2\n-MAGE_L1_DICE = 1\n-MAGE_L1_ATTACK = 0\n-MAGE_L1_ABILITY = FREEZE\n-\n-CHARACTER_DEFAULT_STATS = {\n-    \"knight\": {\n-        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n-        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n-        \"dice\": KNIGHT_L1_DICE,\n-        \"attack\": KNIGHT_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n-    },\n-    \"archer\": {\n-        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n-        \"max_health\": ARCHER_L1_MAX_HEALTH,\n-        \"dice\": ARCHER_L1_DICE,\n-        \"attack\": ARCHER_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n-    },\n-    \"mage\": {\n-        \"health\": MAGE_L1_DEFAULT_HEALTH,\n-        \"max_health\": MAGE_L1_MAX_HEALTH,\n-        \"dice\": MAGE_L1_DICE,\n-        \"attack\": MAGE_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n-    },\n-}\n-\n-\n-def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n-    \"\"\"Initialize all character types with default stats\"\"\"\n-    return {\n-        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n-        for char_type in [KNIGHT, ARCHER, MAGE]\n-    }\ndiff --git a/server/gameplay/presets.py b/server/gameplay/presets.py\nindex 8696c0a..cc9a0ab 100644\n--- a/server/gameplay/presets.py\n+++ b/server/gameplay/presets.py\n@@ -1,9 +1,23 @@\n from typing import Literal, Optional\n \n-from .models import (\n+from .common import KNIGHT, MAGE, ARCHER\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n+    AttackBonusEffect,\n+    AttackNegBonusEffect,\n+    SkipTurnEffect,\n+    RerollDiceEffect,\n+    DrawCardEffect,\n+)\n+from .gameplay import (\n+    StageName,\n+    ABILITY_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+    CHARACTER_SELECT,\n+    OPPONENT_SELECTION,\n     GamePlay,\n     DEFAULT_GAME,\n-    StageName,\n     Player,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -12,23 +26,7 @@ from .models import (\n     Opponent4,\n     BattleResult,\n     AbilitySelectMeta,\n-    ABILITY_SELECTION,\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n-    OPPONENT_SELECTION,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n     init_characters,\n-    AttackBonusEffect,\n-    AttackNegBonusEffect,\n-    SkipTurnEffect,\n-    RerollDiceEffect,\n-    DrawCardEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n ABILITY_SELECTION_KNIGHT = \"ability_selection_knight\"\ndiff --git a/server/gameplay/test_models.py b/server/gameplay/test_common.py\nsimilarity index 90%\nrename from server/gameplay/test_models.py\nrename to server/gameplay/test_common.py\nindex 2b0e8f7..8f2f89a 100644\n--- a/server/gameplay/test_models.py\n+++ b/server/gameplay/test_common.py\n@@ -6,16 +6,13 @@ These tests verify model behavior including computed properties.\n \n import pytest\n \n-from .models import (\n+from .common import KNIGHT\n+from .abilities import ABILITIES_MAP, BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .gameplay import (\n     Character,\n     CHARACTER_DEFAULT_STATS,\n-    KNIGHT,\n     init_characters,\n     KNIGHT_L1_DEFAULT_HEALTH,\n-    ABILITIES_MAP,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n \ndiff --git a/server/gameplay/test_effect_source_validation.py b/server/gameplay/test_effect_source_validation.py\nindex 31233f8..467f3ab 100644\n--- a/server/gameplay/test_effect_source_validation.py\n+++ b/server/gameplay/test_effect_source_validation.py\n@@ -5,14 +5,12 @@ Tests for effect source validation\n import pytest\n from pydantic import ValidationError\n \n-from server.gameplay.models import (\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n     RerollDiceEffect,\n     SkipTurnEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n \n \ndiff --git a/server/gameplay/test_effect_total.py b/server/gameplay/test_effect_total.py\nindex 8ee0851..b2a812b 100644\n--- a/server/gameplay/test_effect_total.py\n+++ b/server/gameplay/test_effect_total.py\n@@ -2,16 +2,14 @@\n Tests for EffectTotal aggregation in Character\n \"\"\"\n \n-from server.gameplay.models import (\n+from .abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from .effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n-    Character,\n     RerollDiceEffect,\n     SkipTurnEffect,\n-    BATTLE_HOWL,\n-    BOUNCING_ARROW,\n-    FREEZE,\n )\n+from .gameplay import Character\n \n \n def test_effect_total_empty():\ndiff --git a/server/gameplay/test_minimum_players.py b/server/gameplay/test_minimum_players.py\nindex 4478779..5949beb 100644\n--- a/server/gameplay/test_minimum_players.py\n+++ b/server/gameplay/test_minimum_players.py\n@@ -7,7 +7,7 @@ These tests verify that the game correctly handles scenarios with less than 2 pl\n import pytest\n \n from .presets import get_debug_preset, SINGLE_PLAYER\n-from .models import CHARACTER_SELECT\n+from .gameplay import CHARACTER_SELECT\n \n \n def test_single_player_preset():\ndiff --git a/server/main.py b/server/main.py\nindex 3f57ffe..165a1c6 100644\n--- a/server/main.py\n+++ b/server/main.py\n@@ -16,7 +16,7 @@ from sqlalchemy.ext.asyncio import AsyncSession\n \n from .env import REDIS_HOST, REDIS_PORT\n from .game_engine import GameEngine\n-from .gameplay.models import DEFAULT_GAME, GamePlay, StageName\n+from .gameplay.gameplay import StageName, DEFAULT_GAME, GamePlay\n from .gameplay.presets import get_debug_preset, DEBUG_PRESETS\n from .db_models import Game as GameTable\n from .database import get_db, AsyncSessionLocal\ndiff --git a/server/test_player_reordering.py b/server/test_player_reordering.py\nindex 937bcc0..0ac51fb 100644\n--- a/server/test_player_reordering.py\n+++ b/server/test_player_reordering.py\n@@ -1,6 +1,6 @@\n \"\"\"Test player reordering in GamePlay\"\"\"\n \n-from server.gameplay.models import GamePlay, Player\n+from server.gameplay.gameplay import GamePlay, Player\n \n \n def test_reorder_players_single_player():"
        },
        "id": "mobile-landscape",
        "name": "mobile-landscape",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "shard": null,
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.55.1",
    "workers": 1,
    "webServer": null
  },
  "suites": [],
  "errors": [
    {
      "message": "Error: Process from config.webServer was not able to start. Exit code: 1",
      "stack": "Error: Process from config.webServer was not able to start. Exit code: 1"
    }
  ],
  "stats": {
    "startTime": "2026-01-18T16:32:15.078Z",
    "duration": 4718.027,
    "expected": 0,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}