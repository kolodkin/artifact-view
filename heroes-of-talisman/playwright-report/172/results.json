{
  "config": {
    "configFile": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/playwright.config.js",
    "rootDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
    "forbidOnly": false,
    "fullyParallel": true,
    "globalSetup": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-setup.js",
    "globalTeardown": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-teardown.js",
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/05753f6fe52ffc21b01b062e11b82b1be626a9dd",
        "commitHash": "05753f6fe52ffc21b01b062e11b82b1be626a9dd",
        "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/33",
        "prTitle": "Add card_draw stage with metal_armor card",
        "prBaseHash": "6db5943692b40caef32caa8c6c7bf54848f4403e",
        "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21158248052"
      },
      "gitCommit": {
        "shortHash": "05753f6",
        "hash": "05753f6fe52ffc21b01b062e11b82b1be626a9dd",
        "subject": "Merge 0380ca309e2f57b97e8c896556da0cd5641c2e0c into 6db5943692b40caef32caa8c6c7bf54848f4403e",
        "body": "Merge 0380ca309e2f57b97e8c896556da0cd5641c2e0c into 6db5943692b40caef32caa8c6c7bf54848f4403e\n",
        "author": {
          "name": "mark kolodkin",
          "email": "mark.kolodkin@gmail.com",
          "time": 1768879031000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1768879031000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 2c1329f..1827087 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -6,6 +6,8 @@ from ..common import (\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\n@@ -22,6 +24,7 @@ from ..common import (\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n@@ -35,6 +38,8 @@ ACTION_MAP: Dict[str, type[Action]] = {\n     DISCONNECT: DisconnectAction,\n     CHARACTER_PRESS: CharacterPressAction,\n     CHARACTER_SELECT_ACTION: CharacterSelectAction,\n+    CARD_DRAW_ACTION: CardDrawAction,\n+    CARD_SELECT_ACTION: CardSelectAction,\n     ABILITY_PRESS: AbilityPressAction,\n     ABILITY_SELECT: AbilitySelectAction,\n     ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex 0d9861f..f9bc5a1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -46,17 +46,22 @@ class BattleEndAction(Action):\n         active_character = self.active_character\n         opponent_character = self.opponent_character\n \n-        # Calculate scores\n-        active_score = sum(self.game.active.dice_roll) + active_character.attack\n-        opponent_score = sum(self.game.opponent.dice_roll) + opponent_character.attack\n+        # Calculate scores (including effects)\n+        active_total_attack = active_character.attack + active_character.effect.attack_bonus + active_character.effect.attack_neg_bonus\n+        opponent_total_attack = opponent_character.attack + opponent_character.effect.attack_bonus + opponent_character.effect.attack_neg_bonus\n \n-        # Determine loser and reduce health\n+        active_score = sum(self.game.active.dice_roll) + active_total_attack\n+        opponent_score = sum(self.game.opponent.dice_roll) + opponent_total_attack\n+\n+        # Determine loser and reduce health (defense reduces incoming damage)\n         if active_score > opponent_score:\n             # Active player wins, opponent loses health\n-            opponent_character.health = max(0, opponent_character.health - 1)\n+            damage = max(0, 1 - opponent_character.effect.defense_bonus)\n+            opponent_character.health = max(0, opponent_character.health - damage)\n         elif opponent_score > active_score:\n             # Opponent wins, active player loses health\n-            active_character.health = max(0, active_character.health - 1)\n+            damage = max(0, 1 - active_character.effect.defense_bonus)\n+            active_character.health = max(0, active_character.health - damage)\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n@@ -84,6 +89,8 @@ class BattleEndAction(Action):\n         # Clear battle state and transition to next turn\n         self.game.active = ActivePlayer1(player=next_player_name)\n         self.game.opponent = None\n+        self.game.card = None\n+        self.game.ability = None\n         self.game.stage = CHARACTER_SELECT\n         self.game.stage_meta = None\n \ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nnew file mode 100644\nindex 0000000..bc21331\n--- /dev/null\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -0,0 +1,118 @@\n+\"\"\"\n+Card Draw Stage Actions\n+\n+This module implements actions for the card draw stage:\n+- CardDrawAction: Automatically draws a random card and stores it in stage_meta\n+- CardSelectAction: Applies the drawn card's effects and transitions to ability_selection\n+\n+Important: Card effects are PERSISTENT (not disposed after battle) unlike ability effects.\n+Card effects remain on the character for the entire game unless explicitly removed.\n+\"\"\"\n+\n+import random\n+import copy\n+from .action import Action\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n+from ..cards import CardName, CARDS_MAP, CARDS_NAMES\n+from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n+\n+\n+class CardDrawAction(Action):\n+    \"\"\"\n+    Action invoked when entering the card draw stage.\n+\n+    Draws a random card from the available cards and stores it in stage_meta.\n+    This action should be called automatically when the stage starts.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Draw a random card\n+        drawn_card = random.choice(CARDS_NAMES)\n+\n+        # Store the drawn card in stage metadata\n+        self.game.stage_meta = CardDrawMeta(drawn_card=drawn_card)\n+\n+        return self.game\n+\n+\n+class CardSelectAction(Action):\n+    \"\"\"\n+    Action invoked when the player confirms to use the drawn card.\n+\n+    Applies the card's effects to the active player's character and transitions\n+    to the ability_selection stage.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Get the active character\n+        if not hasattr(self.game.active, \"character\"):\n+            raise GameException(\"No character selected\")\n+\n+        # Validate that a card was drawn\n+        if not self.game.stage_meta or not isinstance(self.game.stage_meta, CardDrawMeta):\n+            raise GameException(\"No card was drawn\")\n+\n+        player = self.game.players[self.user]\n+        character = player.characters[self.game.active.character]\n+\n+        # Get the drawn card\n+        drawn_card_name = self.game.stage_meta.drawn_card\n+        card_obj = CARDS_MAP.get(drawn_card_name)\n+\n+        if not card_obj:\n+            raise GameException(f\"Card {drawn_card_name} not found\")\n+\n+        # Store the selected card in GamePlay.card\n+        self.game.card = drawn_card_name\n+\n+        # Apply \"self\" effects to the active player's character\n+        # Note: APPLY_TO_BATTLE_OPPONENT effects will be applied when opponent is selected (in OpponentSelectAction)\n+        # Card effects are PERSISTENT (dispose_actions=[]) and remain for the entire game\n+        for effect in card_obj.effects:\n+            if effect.apply_to == APPLY_TO_SELF:\n+                # Deep copy the effect to avoid modifying the original card definition\n+                effect_copy = copy.deepcopy(effect)\n+                character.effects.append(effect_copy)\n+\n+        # Add the card to the player's card list (for display purposes)\n+        player.cards.append(drawn_card_name)\n+\n+        # Clear stage_meta after selection\n+        self.game.stage_meta = None\n+\n+        # Transition to ability_selection stage\n+        self.game.stage = ABILITY_SELECTION\n+\n+        # Auto-select if character has only one ability\n+        if len(character.abilities) == 1:\n+            self.game.stage_meta = AbilitySelectMeta(\n+                selected=character.abilities[0].name\n+            )\n+\n+        return self.game\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 474748e..cd8ba75 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -3,7 +3,7 @@ Character Select Stage Actions\n \n This module implements actions for the character selection stage:\n - CharacterPressAction: Highlights selected character by setting stage_meta\n-- CharacterSelectAction: Confirms selection, disposes effects, and transitions to ability_selection\n+- CharacterSelectAction: Confirms selection, disposes effects, and transitions to card_draw\n \"\"\"\n \n from .action import Action\n@@ -13,10 +13,12 @@ from ..common import (\n     CHARACTER_SELECT_ACTION,\n )\n from ..gameplay import (\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n+    CardDrawMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n )\n@@ -63,7 +65,7 @@ class CharacterSelectAction(Action):\n     Action invoked when the Select button is pressed to confirm character choice.\n \n     Populates selected_character in game metadata, disposes effects with\n-    'character_select' in dispose_actions, and transitions the game stage to 'ability_selection'.\n+    'character_select' in dispose_actions, and transitions the game stage to 'card_draw'.\n     \"\"\"\n \n     @property\n@@ -98,16 +100,10 @@ class CharacterSelectAction(Action):\n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n-        # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n-\n-        # Auto-select if character has only one ability\n-        selected_character = player.characters[character]\n-        if len(selected_character.abilities) == 1:\n-            self.game.stage_meta = AbilitySelectMeta(\n-                selected=selected_character.abilities[0].name\n-            )\n-        else:\n-            self.game.stage_meta = None\n+        # Transition to card_draw stage\n+        self.game.stage = CARD_DRAW\n+\n+        # Clear stage_meta - will be populated by CardDrawAction\n+        self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex ff48b63..0195959 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -3,7 +3,7 @@ Opponent Selection Stage Actions\n \n This module implements actions for the opponent selection stage:\n - OpponentPressAction: Highlights selected opponent by setting stage_meta\n-- OpponentSelectAction: Confirms opponent selection and transitions to battle stage\n+- OpponentSelectAction: Confirms opponent selection, applies card and ability effects to opponent, and transitions to battle stage\n \"\"\"\n \n import copy\n@@ -100,7 +100,18 @@ class OpponentSelectAction(Action):\n         # Set opponent in game metadata\n         self.game.opponent = selected_opponent\n \n-        # Apply \"battle_opponent\" effects to the opponent's character\n+        # Apply \"battle_opponent\" effects from card to the opponent's character\n+        if self.game.card:\n+            from ..cards import CARDS_MAP\n+            card_obj = CARDS_MAP.get(self.game.card)\n+            if card_obj:\n+                for effect in card_obj.effects:\n+                    if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\n+                        # Deep copy the effect to avoid modifying the original card definition\n+                        effect_copy = copy.deepcopy(effect)\n+                        opponent_character.effects.append(effect_copy)\n+\n+        # Apply \"battle_opponent\" effects from ability to the opponent's character\n         if self.game.ability:\n             for effect in self.game.ability.effects:\n                 if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\ndiff --git a/server/gameplay/actions_names.py b/server/gameplay/actions_names.py\nindex 0d4eafc..9c48bba 100644\n--- a/server/gameplay/actions_names.py\n+++ b/server/gameplay/actions_names.py\n@@ -11,6 +11,8 @@ LEAVE = \"leave\"\n DISCONNECT = \"disconnect\"\n CHARACTER_PRESS = \"character_press\"\n CHARACTER_SELECT_ACTION = \"character_select\"\n+CARD_DRAW_ACTION = \"card_draw\"\n+CARD_SELECT_ACTION = \"card_select\"\n ABILITY_PRESS = \"ability_press\"\n ABILITY_SELECT = \"ability_select\"\n ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n@@ -30,6 +32,8 @@ ACTION_NAMES = [\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\ndiff --git a/server/gameplay/cards.py b/server/gameplay/cards.py\nnew file mode 100644\nindex 0000000..c86e63a\n--- /dev/null\n+++ b/server/gameplay/cards.py\n@@ -0,0 +1,60 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_CARD_MAP\n+    DEFENSE_BONUS,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+)\n+\n+########################################################\n+# Card names - defined before imports from effects to avoid circular dependency\n+########################################################\n+METAL_ARMOR = \"metal_armor\"\n+CARDS_NAMES: list[str] = [METAL_ARMOR]\n+CardName = Literal[*CARDS_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which cards can create which effects\n+# This is used for validation to ensure effects have valid source cards\n+EFFECTS_SOURCE_CARD_MAP: dict[str, set[str]] = {\n+    DEFENSE_BONUS: {METAL_ARMOR},  # DefenseBonusEffect can come from METAL_ARMOR\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    DefenseBonusEffect,\n+)\n+\n+\n+class Card(StrictModel):\n+    \"\"\"\n+    Card model representing gameplay cards that players can draw and use.\n+\n+    Important: Card effects are PERSISTENT and last for the entire game (or until character dies).\n+    This is different from ability effects which are disposed after each battle.\n+\n+    To make effects persistent, set dispose_actions=[] when creating the effect.\n+    \"\"\"\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the card is used\n+\n+\n+CARDS_MAP: dict[CardName, Card] = {\n+    METAL_ARMOR: Card(\n+        name=METAL_ARMOR,\n+        effects=[\n+            # Card effects persist across battles (empty dispose_actions)\n+            # Unlike ability effects which dispose after BATTLE_END_ACTION\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nindex 6eb879e..27525ac 100644\n--- a/server/gameplay/effects.py\n+++ b/server/gameplay/effects.py\n@@ -18,6 +18,7 @@ from .actions_names import (\n ########################################################\n ATTACK_BONUS = \"attack_bonus\"\n ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+DEFENSE_BONUS = \"defense_bonus\"\n REROLL_DICE = \"reroll_dice\"\n SKIP_TURN = \"skip_turn\"\n DRAW_CARD = \"draw_card\"\n@@ -51,7 +52,16 @@ class Effect(StrictModel):\n         # Lazy import to avoid circular dependency\n         from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n \n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        try:\n+            from .cards import EFFECTS_SOURCE_CARD_MAP\n+        except ImportError:\n+            EFFECTS_SOURCE_CARD_MAP = {}\n+\n+        # Combine ability and card sources\n+        ability_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        card_sources = EFFECTS_SOURCE_CARD_MAP.get(self.name, set())\n+        valid_sources = ability_sources | card_sources\n+\n         if self.source not in valid_sources and len(valid_sources) > 0:\n             raise ValueError(\n                 f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n@@ -86,6 +96,19 @@ class AttackBonusEffect(Effect):\n     attack_bonus: int\n \n \n+class DefenseBonusEffect(Effect):\n+    \"\"\"\n+    Character's defense is increased, reducing incoming attack damage.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DEFENSE_BONUS] = DEFENSE_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    defense_bonus: int\n+\n+\n class RerollDiceEffect(Effect):\n     \"\"\"\n     Character's dice are rerolled if lost the battle.\n@@ -127,7 +150,7 @@ class DrawCardEffect(Effect):\n \n # Define EffectUnion for discriminated union of all effect types (without base classes)\n EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Union[AttackBonusEffect, AttackNegBonusEffect, DefenseBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n     Field(discriminator=\"name\"),\n ]\n \n@@ -140,6 +163,7 @@ class EffectTotal(StrictModel):\n \n     attack_bonus: int = 0\n     attack_neg_bonus: int = 0\n+    defense_bonus: int = 0\n     skip_next_turn: bool = False\n     reroll_dice_available: bool = False\n     draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nindex 937d1f7..7cc6b3a 100644\n--- a/server/gameplay/gameplay.py\n+++ b/server/gameplay/gameplay.py\n@@ -18,6 +18,7 @@ from .common import (\n # Stages\n ########################################################\n CHARACTER_SELECT = \"character_select\"\n+CARD_DRAW = \"card_draw\"\n ABILITY_SELECTION = \"ability_selection\"\n ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n OPPONENT_SELECTION = \"opponent_selection\"\n@@ -25,6 +26,7 @@ BATTLE_DICE_ROLL = \"battle_dice_roll\"\n BATTLE_END = \"battle_end\"\n STAGES_NAMES = [\n     CHARACTER_SELECT,\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n@@ -46,6 +48,7 @@ from .effects import (\n     EffectTotal,\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -79,6 +82,8 @@ class Character(StrictModel):\n                 total.attack_bonus += eff.attack_bonus\n             elif isinstance(eff, AttackNegBonusEffect):\n                 total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, DefenseBonusEffect):\n+                total.defense_bonus += eff.defense_bonus\n             elif isinstance(eff, SkipTurnEffect):\n                 total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n             elif isinstance(eff, RerollDiceEffect):\n@@ -98,6 +103,12 @@ class CharacterSelectMeta(StrictModel):\n     selected: str  # Currently highlighted character\n \n \n+class CardDrawMeta(StrictModel):\n+    \"\"\"Stage metadata for card draw stage\"\"\"\n+\n+    drawn_card: str  # The card that was randomly drawn\n+\n+\n class AbilitySelectMeta(StrictModel):\n     \"\"\"Stage metadata for ability selection stage\"\"\"\n \n@@ -171,10 +182,11 @@ class GamePlay(StrictModel):\n     stage: StageName = CHARACTER_SELECT\n     players: dict[str, Player] = Field(default_factory=dict)\n     active: Optional[ActivePlayer] = None  # The active player and its selections\n+    card: Optional[str] = None  # Selected card from card_draw stage\n     ability: Optional[Ability] = None  # Selected ability\n     ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n     opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+    stage_meta: Optional[Ability | CharacterSelectMeta | CardDrawMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n \n     def reorder_players(self, username: str):\n         \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\ndiff --git a/src/constants/stages.js b/src/constants/stages.js\nindex 176cc8f..08ca49d 100644\n--- a/src/constants/stages.js\n+++ b/src/constants/stages.js\n@@ -1,5 +1,6 @@\n // Stage constants - must match backend stage names in server/gameplay/models.py\n export const CHARACTER_SELECT = \"character_select\";\n+export const CARD_DRAW = \"card_draw\";\n export const ABILITY_SELECTION = \"ability_selection\";\n export const ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\";\n export const OPPONENT_SELECTION = \"opponent_selection\";"
    },
    "preserveOutput": "always",
    "reporter": [
      [
        "html",
        {
          "open": "never"
        }
      ],
      [
        "json",
        {
          "outputFile": "playwright-report/results.json"
        }
      ],
      [
        "junit",
        {
          "outputFile": "playwright-report/results.xml"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "quiet": false,
    "projects": [
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/05753f6fe52ffc21b01b062e11b82b1be626a9dd",
            "commitHash": "05753f6fe52ffc21b01b062e11b82b1be626a9dd",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/33",
            "prTitle": "Add card_draw stage with metal_armor card",
            "prBaseHash": "6db5943692b40caef32caa8c6c7bf54848f4403e",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21158248052"
          },
          "gitCommit": {
            "shortHash": "05753f6",
            "hash": "05753f6fe52ffc21b01b062e11b82b1be626a9dd",
            "subject": "Merge 0380ca309e2f57b97e8c896556da0cd5641c2e0c into 6db5943692b40caef32caa8c6c7bf54848f4403e",
            "body": "Merge 0380ca309e2f57b97e8c896556da0cd5641c2e0c into 6db5943692b40caef32caa8c6c7bf54848f4403e\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768879031000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768879031000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 2c1329f..1827087 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -6,6 +6,8 @@ from ..common import (\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\n@@ -22,6 +24,7 @@ from ..common import (\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n@@ -35,6 +38,8 @@ ACTION_MAP: Dict[str, type[Action]] = {\n     DISCONNECT: DisconnectAction,\n     CHARACTER_PRESS: CharacterPressAction,\n     CHARACTER_SELECT_ACTION: CharacterSelectAction,\n+    CARD_DRAW_ACTION: CardDrawAction,\n+    CARD_SELECT_ACTION: CardSelectAction,\n     ABILITY_PRESS: AbilityPressAction,\n     ABILITY_SELECT: AbilitySelectAction,\n     ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex 0d9861f..f9bc5a1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -46,17 +46,22 @@ class BattleEndAction(Action):\n         active_character = self.active_character\n         opponent_character = self.opponent_character\n \n-        # Calculate scores\n-        active_score = sum(self.game.active.dice_roll) + active_character.attack\n-        opponent_score = sum(self.game.opponent.dice_roll) + opponent_character.attack\n+        # Calculate scores (including effects)\n+        active_total_attack = active_character.attack + active_character.effect.attack_bonus + active_character.effect.attack_neg_bonus\n+        opponent_total_attack = opponent_character.attack + opponent_character.effect.attack_bonus + opponent_character.effect.attack_neg_bonus\n \n-        # Determine loser and reduce health\n+        active_score = sum(self.game.active.dice_roll) + active_total_attack\n+        opponent_score = sum(self.game.opponent.dice_roll) + opponent_total_attack\n+\n+        # Determine loser and reduce health (defense reduces incoming damage)\n         if active_score > opponent_score:\n             # Active player wins, opponent loses health\n-            opponent_character.health = max(0, opponent_character.health - 1)\n+            damage = max(0, 1 - opponent_character.effect.defense_bonus)\n+            opponent_character.health = max(0, opponent_character.health - damage)\n         elif opponent_score > active_score:\n             # Opponent wins, active player loses health\n-            active_character.health = max(0, active_character.health - 1)\n+            damage = max(0, 1 - active_character.effect.defense_bonus)\n+            active_character.health = max(0, active_character.health - damage)\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n@@ -84,6 +89,8 @@ class BattleEndAction(Action):\n         # Clear battle state and transition to next turn\n         self.game.active = ActivePlayer1(player=next_player_name)\n         self.game.opponent = None\n+        self.game.card = None\n+        self.game.ability = None\n         self.game.stage = CHARACTER_SELECT\n         self.game.stage_meta = None\n \ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nnew file mode 100644\nindex 0000000..bc21331\n--- /dev/null\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -0,0 +1,118 @@\n+\"\"\"\n+Card Draw Stage Actions\n+\n+This module implements actions for the card draw stage:\n+- CardDrawAction: Automatically draws a random card and stores it in stage_meta\n+- CardSelectAction: Applies the drawn card's effects and transitions to ability_selection\n+\n+Important: Card effects are PERSISTENT (not disposed after battle) unlike ability effects.\n+Card effects remain on the character for the entire game unless explicitly removed.\n+\"\"\"\n+\n+import random\n+import copy\n+from .action import Action\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n+from ..cards import CardName, CARDS_MAP, CARDS_NAMES\n+from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n+\n+\n+class CardDrawAction(Action):\n+    \"\"\"\n+    Action invoked when entering the card draw stage.\n+\n+    Draws a random card from the available cards and stores it in stage_meta.\n+    This action should be called automatically when the stage starts.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Draw a random card\n+        drawn_card = random.choice(CARDS_NAMES)\n+\n+        # Store the drawn card in stage metadata\n+        self.game.stage_meta = CardDrawMeta(drawn_card=drawn_card)\n+\n+        return self.game\n+\n+\n+class CardSelectAction(Action):\n+    \"\"\"\n+    Action invoked when the player confirms to use the drawn card.\n+\n+    Applies the card's effects to the active player's character and transitions\n+    to the ability_selection stage.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Get the active character\n+        if not hasattr(self.game.active, \"character\"):\n+            raise GameException(\"No character selected\")\n+\n+        # Validate that a card was drawn\n+        if not self.game.stage_meta or not isinstance(self.game.stage_meta, CardDrawMeta):\n+            raise GameException(\"No card was drawn\")\n+\n+        player = self.game.players[self.user]\n+        character = player.characters[self.game.active.character]\n+\n+        # Get the drawn card\n+        drawn_card_name = self.game.stage_meta.drawn_card\n+        card_obj = CARDS_MAP.get(drawn_card_name)\n+\n+        if not card_obj:\n+            raise GameException(f\"Card {drawn_card_name} not found\")\n+\n+        # Store the selected card in GamePlay.card\n+        self.game.card = drawn_card_name\n+\n+        # Apply \"self\" effects to the active player's character\n+        # Note: APPLY_TO_BATTLE_OPPONENT effects will be applied when opponent is selected (in OpponentSelectAction)\n+        # Card effects are PERSISTENT (dispose_actions=[]) and remain for the entire game\n+        for effect in card_obj.effects:\n+            if effect.apply_to == APPLY_TO_SELF:\n+                # Deep copy the effect to avoid modifying the original card definition\n+                effect_copy = copy.deepcopy(effect)\n+                character.effects.append(effect_copy)\n+\n+        # Add the card to the player's card list (for display purposes)\n+        player.cards.append(drawn_card_name)\n+\n+        # Clear stage_meta after selection\n+        self.game.stage_meta = None\n+\n+        # Transition to ability_selection stage\n+        self.game.stage = ABILITY_SELECTION\n+\n+        # Auto-select if character has only one ability\n+        if len(character.abilities) == 1:\n+            self.game.stage_meta = AbilitySelectMeta(\n+                selected=character.abilities[0].name\n+            )\n+\n+        return self.game\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 474748e..cd8ba75 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -3,7 +3,7 @@ Character Select Stage Actions\n \n This module implements actions for the character selection stage:\n - CharacterPressAction: Highlights selected character by setting stage_meta\n-- CharacterSelectAction: Confirms selection, disposes effects, and transitions to ability_selection\n+- CharacterSelectAction: Confirms selection, disposes effects, and transitions to card_draw\n \"\"\"\n \n from .action import Action\n@@ -13,10 +13,12 @@ from ..common import (\n     CHARACTER_SELECT_ACTION,\n )\n from ..gameplay import (\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n+    CardDrawMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n )\n@@ -63,7 +65,7 @@ class CharacterSelectAction(Action):\n     Action invoked when the Select button is pressed to confirm character choice.\n \n     Populates selected_character in game metadata, disposes effects with\n-    'character_select' in dispose_actions, and transitions the game stage to 'ability_selection'.\n+    'character_select' in dispose_actions, and transitions the game stage to 'card_draw'.\n     \"\"\"\n \n     @property\n@@ -98,16 +100,10 @@ class CharacterSelectAction(Action):\n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n-        # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n-\n-        # Auto-select if character has only one ability\n-        selected_character = player.characters[character]\n-        if len(selected_character.abilities) == 1:\n-            self.game.stage_meta = AbilitySelectMeta(\n-                selected=selected_character.abilities[0].name\n-            )\n-        else:\n-            self.game.stage_meta = None\n+        # Transition to card_draw stage\n+        self.game.stage = CARD_DRAW\n+\n+        # Clear stage_meta - will be populated by CardDrawAction\n+        self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex ff48b63..0195959 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -3,7 +3,7 @@ Opponent Selection Stage Actions\n \n This module implements actions for the opponent selection stage:\n - OpponentPressAction: Highlights selected opponent by setting stage_meta\n-- OpponentSelectAction: Confirms opponent selection and transitions to battle stage\n+- OpponentSelectAction: Confirms opponent selection, applies card and ability effects to opponent, and transitions to battle stage\n \"\"\"\n \n import copy\n@@ -100,7 +100,18 @@ class OpponentSelectAction(Action):\n         # Set opponent in game metadata\n         self.game.opponent = selected_opponent\n \n-        # Apply \"battle_opponent\" effects to the opponent's character\n+        # Apply \"battle_opponent\" effects from card to the opponent's character\n+        if self.game.card:\n+            from ..cards import CARDS_MAP\n+            card_obj = CARDS_MAP.get(self.game.card)\n+            if card_obj:\n+                for effect in card_obj.effects:\n+                    if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\n+                        # Deep copy the effect to avoid modifying the original card definition\n+                        effect_copy = copy.deepcopy(effect)\n+                        opponent_character.effects.append(effect_copy)\n+\n+        # Apply \"battle_opponent\" effects from ability to the opponent's character\n         if self.game.ability:\n             for effect in self.game.ability.effects:\n                 if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\ndiff --git a/server/gameplay/actions_names.py b/server/gameplay/actions_names.py\nindex 0d4eafc..9c48bba 100644\n--- a/server/gameplay/actions_names.py\n+++ b/server/gameplay/actions_names.py\n@@ -11,6 +11,8 @@ LEAVE = \"leave\"\n DISCONNECT = \"disconnect\"\n CHARACTER_PRESS = \"character_press\"\n CHARACTER_SELECT_ACTION = \"character_select\"\n+CARD_DRAW_ACTION = \"card_draw\"\n+CARD_SELECT_ACTION = \"card_select\"\n ABILITY_PRESS = \"ability_press\"\n ABILITY_SELECT = \"ability_select\"\n ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n@@ -30,6 +32,8 @@ ACTION_NAMES = [\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\ndiff --git a/server/gameplay/cards.py b/server/gameplay/cards.py\nnew file mode 100644\nindex 0000000..c86e63a\n--- /dev/null\n+++ b/server/gameplay/cards.py\n@@ -0,0 +1,60 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_CARD_MAP\n+    DEFENSE_BONUS,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+)\n+\n+########################################################\n+# Card names - defined before imports from effects to avoid circular dependency\n+########################################################\n+METAL_ARMOR = \"metal_armor\"\n+CARDS_NAMES: list[str] = [METAL_ARMOR]\n+CardName = Literal[*CARDS_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which cards can create which effects\n+# This is used for validation to ensure effects have valid source cards\n+EFFECTS_SOURCE_CARD_MAP: dict[str, set[str]] = {\n+    DEFENSE_BONUS: {METAL_ARMOR},  # DefenseBonusEffect can come from METAL_ARMOR\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    DefenseBonusEffect,\n+)\n+\n+\n+class Card(StrictModel):\n+    \"\"\"\n+    Card model representing gameplay cards that players can draw and use.\n+\n+    Important: Card effects are PERSISTENT and last for the entire game (or until character dies).\n+    This is different from ability effects which are disposed after each battle.\n+\n+    To make effects persistent, set dispose_actions=[] when creating the effect.\n+    \"\"\"\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the card is used\n+\n+\n+CARDS_MAP: dict[CardName, Card] = {\n+    METAL_ARMOR: Card(\n+        name=METAL_ARMOR,\n+        effects=[\n+            # Card effects persist across battles (empty dispose_actions)\n+            # Unlike ability effects which dispose after BATTLE_END_ACTION\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nindex 6eb879e..27525ac 100644\n--- a/server/gameplay/effects.py\n+++ b/server/gameplay/effects.py\n@@ -18,6 +18,7 @@ from .actions_names import (\n ########################################################\n ATTACK_BONUS = \"attack_bonus\"\n ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+DEFENSE_BONUS = \"defense_bonus\"\n REROLL_DICE = \"reroll_dice\"\n SKIP_TURN = \"skip_turn\"\n DRAW_CARD = \"draw_card\"\n@@ -51,7 +52,16 @@ class Effect(StrictModel):\n         # Lazy import to avoid circular dependency\n         from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n \n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        try:\n+            from .cards import EFFECTS_SOURCE_CARD_MAP\n+        except ImportError:\n+            EFFECTS_SOURCE_CARD_MAP = {}\n+\n+        # Combine ability and card sources\n+        ability_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        card_sources = EFFECTS_SOURCE_CARD_MAP.get(self.name, set())\n+        valid_sources = ability_sources | card_sources\n+\n         if self.source not in valid_sources and len(valid_sources) > 0:\n             raise ValueError(\n                 f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n@@ -86,6 +96,19 @@ class AttackBonusEffect(Effect):\n     attack_bonus: int\n \n \n+class DefenseBonusEffect(Effect):\n+    \"\"\"\n+    Character's defense is increased, reducing incoming attack damage.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DEFENSE_BONUS] = DEFENSE_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    defense_bonus: int\n+\n+\n class RerollDiceEffect(Effect):\n     \"\"\"\n     Character's dice are rerolled if lost the battle.\n@@ -127,7 +150,7 @@ class DrawCardEffect(Effect):\n \n # Define EffectUnion for discriminated union of all effect types (without base classes)\n EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Union[AttackBonusEffect, AttackNegBonusEffect, DefenseBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n     Field(discriminator=\"name\"),\n ]\n \n@@ -140,6 +163,7 @@ class EffectTotal(StrictModel):\n \n     attack_bonus: int = 0\n     attack_neg_bonus: int = 0\n+    defense_bonus: int = 0\n     skip_next_turn: bool = False\n     reroll_dice_available: bool = False\n     draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nindex 937d1f7..7cc6b3a 100644\n--- a/server/gameplay/gameplay.py\n+++ b/server/gameplay/gameplay.py\n@@ -18,6 +18,7 @@ from .common import (\n # Stages\n ########################################################\n CHARACTER_SELECT = \"character_select\"\n+CARD_DRAW = \"card_draw\"\n ABILITY_SELECTION = \"ability_selection\"\n ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n OPPONENT_SELECTION = \"opponent_selection\"\n@@ -25,6 +26,7 @@ BATTLE_DICE_ROLL = \"battle_dice_roll\"\n BATTLE_END = \"battle_end\"\n STAGES_NAMES = [\n     CHARACTER_SELECT,\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n@@ -46,6 +48,7 @@ from .effects import (\n     EffectTotal,\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -79,6 +82,8 @@ class Character(StrictModel):\n                 total.attack_bonus += eff.attack_bonus\n             elif isinstance(eff, AttackNegBonusEffect):\n                 total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, DefenseBonusEffect):\n+                total.defense_bonus += eff.defense_bonus\n             elif isinstance(eff, SkipTurnEffect):\n                 total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n             elif isinstance(eff, RerollDiceEffect):\n@@ -98,6 +103,12 @@ class CharacterSelectMeta(StrictModel):\n     selected: str  # Currently highlighted character\n \n \n+class CardDrawMeta(StrictModel):\n+    \"\"\"Stage metadata for card draw stage\"\"\"\n+\n+    drawn_card: str  # The card that was randomly drawn\n+\n+\n class AbilitySelectMeta(StrictModel):\n     \"\"\"Stage metadata for ability selection stage\"\"\"\n \n@@ -171,10 +182,11 @@ class GamePlay(StrictModel):\n     stage: StageName = CHARACTER_SELECT\n     players: dict[str, Player] = Field(default_factory=dict)\n     active: Optional[ActivePlayer] = None  # The active player and its selections\n+    card: Optional[str] = None  # Selected card from card_draw stage\n     ability: Optional[Ability] = None  # Selected ability\n     ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n     opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+    stage_meta: Optional[Ability | CharacterSelectMeta | CardDrawMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n \n     def reorder_players(self, username: str):\n         \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\ndiff --git a/src/constants/stages.js b/src/constants/stages.js\nindex 176cc8f..08ca49d 100644\n--- a/src/constants/stages.js\n+++ b/src/constants/stages.js\n@@ -1,5 +1,6 @@\n // Stage constants - must match backend stage names in server/gameplay/models.py\n export const CHARACTER_SELECT = \"character_select\";\n+export const CARD_DRAW = \"card_draw\";\n export const ABILITY_SELECTION = \"ability_selection\";\n export const ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\";\n export const OPPONENT_SELECTION = \"opponent_selection\";"
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      },
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/05753f6fe52ffc21b01b062e11b82b1be626a9dd",
            "commitHash": "05753f6fe52ffc21b01b062e11b82b1be626a9dd",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/33",
            "prTitle": "Add card_draw stage with metal_armor card",
            "prBaseHash": "6db5943692b40caef32caa8c6c7bf54848f4403e",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21158248052"
          },
          "gitCommit": {
            "shortHash": "05753f6",
            "hash": "05753f6fe52ffc21b01b062e11b82b1be626a9dd",
            "subject": "Merge 0380ca309e2f57b97e8c896556da0cd5641c2e0c into 6db5943692b40caef32caa8c6c7bf54848f4403e",
            "body": "Merge 0380ca309e2f57b97e8c896556da0cd5641c2e0c into 6db5943692b40caef32caa8c6c7bf54848f4403e\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768879031000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768879031000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 2c1329f..1827087 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -6,6 +6,8 @@ from ..common import (\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\n@@ -22,6 +24,7 @@ from ..common import (\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n from .stage_character_select import CharacterPressAction, CharacterSelectAction\n+from .stage_card_draw import CardDrawAction, CardSelectAction\n from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n from .stage_opponent_selection import OpponentPressAction, OpponentSelectAction\n@@ -35,6 +38,8 @@ ACTION_MAP: Dict[str, type[Action]] = {\n     DISCONNECT: DisconnectAction,\n     CHARACTER_PRESS: CharacterPressAction,\n     CHARACTER_SELECT_ACTION: CharacterSelectAction,\n+    CARD_DRAW_ACTION: CardDrawAction,\n+    CARD_SELECT_ACTION: CardSelectAction,\n     ABILITY_PRESS: AbilityPressAction,\n     ABILITY_SELECT: AbilitySelectAction,\n     ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex 0d9861f..f9bc5a1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -46,17 +46,22 @@ class BattleEndAction(Action):\n         active_character = self.active_character\n         opponent_character = self.opponent_character\n \n-        # Calculate scores\n-        active_score = sum(self.game.active.dice_roll) + active_character.attack\n-        opponent_score = sum(self.game.opponent.dice_roll) + opponent_character.attack\n+        # Calculate scores (including effects)\n+        active_total_attack = active_character.attack + active_character.effect.attack_bonus + active_character.effect.attack_neg_bonus\n+        opponent_total_attack = opponent_character.attack + opponent_character.effect.attack_bonus + opponent_character.effect.attack_neg_bonus\n \n-        # Determine loser and reduce health\n+        active_score = sum(self.game.active.dice_roll) + active_total_attack\n+        opponent_score = sum(self.game.opponent.dice_roll) + opponent_total_attack\n+\n+        # Determine loser and reduce health (defense reduces incoming damage)\n         if active_score > opponent_score:\n             # Active player wins, opponent loses health\n-            opponent_character.health = max(0, opponent_character.health - 1)\n+            damage = max(0, 1 - opponent_character.effect.defense_bonus)\n+            opponent_character.health = max(0, opponent_character.health - damage)\n         elif opponent_score > active_score:\n             # Opponent wins, active player loses health\n-            active_character.health = max(0, active_character.health - 1)\n+            damage = max(0, 1 - active_character.effect.defense_bonus)\n+            active_character.health = max(0, active_character.health - damage)\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n@@ -84,6 +89,8 @@ class BattleEndAction(Action):\n         # Clear battle state and transition to next turn\n         self.game.active = ActivePlayer1(player=next_player_name)\n         self.game.opponent = None\n+        self.game.card = None\n+        self.game.ability = None\n         self.game.stage = CHARACTER_SELECT\n         self.game.stage_meta = None\n \ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nnew file mode 100644\nindex 0000000..bc21331\n--- /dev/null\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -0,0 +1,118 @@\n+\"\"\"\n+Card Draw Stage Actions\n+\n+This module implements actions for the card draw stage:\n+- CardDrawAction: Automatically draws a random card and stores it in stage_meta\n+- CardSelectAction: Applies the drawn card's effects and transitions to ability_selection\n+\n+Important: Card effects are PERSISTENT (not disposed after battle) unlike ability effects.\n+Card effects remain on the character for the entire game unless explicitly removed.\n+\"\"\"\n+\n+import random\n+import copy\n+from .action import Action\n+from ..common import GameException, ReportedException\n+from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n+from ..cards import CardName, CARDS_MAP, CARDS_NAMES\n+from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n+\n+\n+class CardDrawAction(Action):\n+    \"\"\"\n+    Action invoked when entering the card draw stage.\n+\n+    Draws a random card from the available cards and stores it in stage_meta.\n+    This action should be called automatically when the stage starts.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Draw a random card\n+        drawn_card = random.choice(CARDS_NAMES)\n+\n+        # Store the drawn card in stage metadata\n+        self.game.stage_meta = CardDrawMeta(drawn_card=drawn_card)\n+\n+        return self.game\n+\n+\n+class CardSelectAction(Action):\n+    \"\"\"\n+    Action invoked when the player confirms to use the drawn card.\n+\n+    Applies the card's effects to the active player's character and transitions\n+    to the ability_selection stage.\n+    \"\"\"\n+\n+    @property\n+    def action_stages(self):\n+        return [CARD_DRAW]\n+\n+    def _run(self) -> GamePlay:\n+        # Validate user is the active player\n+        if not self.game.active or self.game.active.player != self.user:\n+            raise ReportedException(\"It's not your turn\")\n+\n+        # Validate user exists\n+        if self.user not in self.game.players:\n+            raise GameException(\"Player not in game\")\n+\n+        # Get the active character\n+        if not hasattr(self.game.active, \"character\"):\n+            raise GameException(\"No character selected\")\n+\n+        # Validate that a card was drawn\n+        if not self.game.stage_meta or not isinstance(self.game.stage_meta, CardDrawMeta):\n+            raise GameException(\"No card was drawn\")\n+\n+        player = self.game.players[self.user]\n+        character = player.characters[self.game.active.character]\n+\n+        # Get the drawn card\n+        drawn_card_name = self.game.stage_meta.drawn_card\n+        card_obj = CARDS_MAP.get(drawn_card_name)\n+\n+        if not card_obj:\n+            raise GameException(f\"Card {drawn_card_name} not found\")\n+\n+        # Store the selected card in GamePlay.card\n+        self.game.card = drawn_card_name\n+\n+        # Apply \"self\" effects to the active player's character\n+        # Note: APPLY_TO_BATTLE_OPPONENT effects will be applied when opponent is selected (in OpponentSelectAction)\n+        # Card effects are PERSISTENT (dispose_actions=[]) and remain for the entire game\n+        for effect in card_obj.effects:\n+            if effect.apply_to == APPLY_TO_SELF:\n+                # Deep copy the effect to avoid modifying the original card definition\n+                effect_copy = copy.deepcopy(effect)\n+                character.effects.append(effect_copy)\n+\n+        # Add the card to the player's card list (for display purposes)\n+        player.cards.append(drawn_card_name)\n+\n+        # Clear stage_meta after selection\n+        self.game.stage_meta = None\n+\n+        # Transition to ability_selection stage\n+        self.game.stage = ABILITY_SELECTION\n+\n+        # Auto-select if character has only one ability\n+        if len(character.abilities) == 1:\n+            self.game.stage_meta = AbilitySelectMeta(\n+                selected=character.abilities[0].name\n+            )\n+\n+        return self.game\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex 474748e..cd8ba75 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -3,7 +3,7 @@ Character Select Stage Actions\n \n This module implements actions for the character selection stage:\n - CharacterPressAction: Highlights selected character by setting stage_meta\n-- CharacterSelectAction: Confirms selection, disposes effects, and transitions to ability_selection\n+- CharacterSelectAction: Confirms selection, disposes effects, and transitions to card_draw\n \"\"\"\n \n from .action import Action\n@@ -13,10 +13,12 @@ from ..common import (\n     CHARACTER_SELECT_ACTION,\n )\n from ..gameplay import (\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n+    CardDrawMeta,\n     AbilitySelectMeta,\n     ActivePlayer2,\n )\n@@ -63,7 +65,7 @@ class CharacterSelectAction(Action):\n     Action invoked when the Select button is pressed to confirm character choice.\n \n     Populates selected_character in game metadata, disposes effects with\n-    'character_select' in dispose_actions, and transitions the game stage to 'ability_selection'.\n+    'character_select' in dispose_actions, and transitions the game stage to 'card_draw'.\n     \"\"\"\n \n     @property\n@@ -98,16 +100,10 @@ class CharacterSelectAction(Action):\n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n-        # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n-\n-        # Auto-select if character has only one ability\n-        selected_character = player.characters[character]\n-        if len(selected_character.abilities) == 1:\n-            self.game.stage_meta = AbilitySelectMeta(\n-                selected=selected_character.abilities[0].name\n-            )\n-        else:\n-            self.game.stage_meta = None\n+        # Transition to card_draw stage\n+        self.game.stage = CARD_DRAW\n+\n+        # Clear stage_meta - will be populated by CardDrawAction\n+        self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex ff48b63..0195959 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -3,7 +3,7 @@ Opponent Selection Stage Actions\n \n This module implements actions for the opponent selection stage:\n - OpponentPressAction: Highlights selected opponent by setting stage_meta\n-- OpponentSelectAction: Confirms opponent selection and transitions to battle stage\n+- OpponentSelectAction: Confirms opponent selection, applies card and ability effects to opponent, and transitions to battle stage\n \"\"\"\n \n import copy\n@@ -100,7 +100,18 @@ class OpponentSelectAction(Action):\n         # Set opponent in game metadata\n         self.game.opponent = selected_opponent\n \n-        # Apply \"battle_opponent\" effects to the opponent's character\n+        # Apply \"battle_opponent\" effects from card to the opponent's character\n+        if self.game.card:\n+            from ..cards import CARDS_MAP\n+            card_obj = CARDS_MAP.get(self.game.card)\n+            if card_obj:\n+                for effect in card_obj.effects:\n+                    if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\n+                        # Deep copy the effect to avoid modifying the original card definition\n+                        effect_copy = copy.deepcopy(effect)\n+                        opponent_character.effects.append(effect_copy)\n+\n+        # Apply \"battle_opponent\" effects from ability to the opponent's character\n         if self.game.ability:\n             for effect in self.game.ability.effects:\n                 if effect.apply_to == APPLY_TO_BATTLE_OPPONENT:\ndiff --git a/server/gameplay/actions_names.py b/server/gameplay/actions_names.py\nindex 0d4eafc..9c48bba 100644\n--- a/server/gameplay/actions_names.py\n+++ b/server/gameplay/actions_names.py\n@@ -11,6 +11,8 @@ LEAVE = \"leave\"\n DISCONNECT = \"disconnect\"\n CHARACTER_PRESS = \"character_press\"\n CHARACTER_SELECT_ACTION = \"character_select\"\n+CARD_DRAW_ACTION = \"card_draw\"\n+CARD_SELECT_ACTION = \"card_select\"\n ABILITY_PRESS = \"ability_press\"\n ABILITY_SELECT = \"ability_select\"\n ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n@@ -30,6 +32,8 @@ ACTION_NAMES = [\n     DISCONNECT,\n     CHARACTER_PRESS,\n     CHARACTER_SELECT_ACTION,\n+    CARD_DRAW_ACTION,\n+    CARD_SELECT_ACTION,\n     ABILITY_PRESS,\n     ABILITY_SELECT,\n     ABILITY_OPPONENT_PRESS,\ndiff --git a/server/gameplay/cards.py b/server/gameplay/cards.py\nnew file mode 100644\nindex 0000000..c86e63a\n--- /dev/null\n+++ b/server/gameplay/cards.py\n@@ -0,0 +1,60 @@\n+from __future__ import annotations\n+\n+from typing import Literal\n+\n+from pydantic import Field\n+\n+from .common import StrictModel\n+from .effects import (\n+    # Effect name constants for EFFECTS_SOURCE_CARD_MAP\n+    DEFENSE_BONUS,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+)\n+\n+########################################################\n+# Card names - defined before imports from effects to avoid circular dependency\n+########################################################\n+METAL_ARMOR = \"metal_armor\"\n+CARDS_NAMES: list[str] = [METAL_ARMOR]\n+CardName = Literal[*CARDS_NAMES]\n+\n+########################################################\n+# Effect-to-Source mapping\n+########################################################\n+# Defines which cards can create which effects\n+# This is used for validation to ensure effects have valid source cards\n+EFFECTS_SOURCE_CARD_MAP: dict[str, set[str]] = {\n+    DEFENSE_BONUS: {METAL_ARMOR},  # DefenseBonusEffect can come from METAL_ARMOR\n+}\n+\n+# Import Effect classes after defining constants to avoid circular import\n+from .effects import (\n+    EffectUnion,\n+    DefenseBonusEffect,\n+)\n+\n+\n+class Card(StrictModel):\n+    \"\"\"\n+    Card model representing gameplay cards that players can draw and use.\n+\n+    Important: Card effects are PERSISTENT and last for the entire game (or until character dies).\n+    This is different from ability effects which are disposed after each battle.\n+\n+    To make effects persistent, set dispose_actions=[] when creating the effect.\n+    \"\"\"\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the card is used\n+\n+\n+CARDS_MAP: dict[CardName, Card] = {\n+    METAL_ARMOR: Card(\n+        name=METAL_ARMOR,\n+        effects=[\n+            # Card effects persist across battles (empty dispose_actions)\n+            # Unlike ability effects which dispose after BATTLE_END_ACTION\n+            DefenseBonusEffect(source=METAL_ARMOR, defense_bonus=2, dispose_actions=[]),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nindex 6eb879e..27525ac 100644\n--- a/server/gameplay/effects.py\n+++ b/server/gameplay/effects.py\n@@ -18,6 +18,7 @@ from .actions_names import (\n ########################################################\n ATTACK_BONUS = \"attack_bonus\"\n ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+DEFENSE_BONUS = \"defense_bonus\"\n REROLL_DICE = \"reroll_dice\"\n SKIP_TURN = \"skip_turn\"\n DRAW_CARD = \"draw_card\"\n@@ -51,7 +52,16 @@ class Effect(StrictModel):\n         # Lazy import to avoid circular dependency\n         from .abilities import EFFECTS_SOURCE_ABILITY_MAP\n \n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        try:\n+            from .cards import EFFECTS_SOURCE_CARD_MAP\n+        except ImportError:\n+            EFFECTS_SOURCE_CARD_MAP = {}\n+\n+        # Combine ability and card sources\n+        ability_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        card_sources = EFFECTS_SOURCE_CARD_MAP.get(self.name, set())\n+        valid_sources = ability_sources | card_sources\n+\n         if self.source not in valid_sources and len(valid_sources) > 0:\n             raise ValueError(\n                 f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n@@ -86,6 +96,19 @@ class AttackBonusEffect(Effect):\n     attack_bonus: int\n \n \n+class DefenseBonusEffect(Effect):\n+    \"\"\"\n+    Character's defense is increased, reducing incoming attack damage.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DEFENSE_BONUS] = DEFENSE_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    defense_bonus: int\n+\n+\n class RerollDiceEffect(Effect):\n     \"\"\"\n     Character's dice are rerolled if lost the battle.\n@@ -127,7 +150,7 @@ class DrawCardEffect(Effect):\n \n # Define EffectUnion for discriminated union of all effect types (without base classes)\n EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Union[AttackBonusEffect, AttackNegBonusEffect, DefenseBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n     Field(discriminator=\"name\"),\n ]\n \n@@ -140,6 +163,7 @@ class EffectTotal(StrictModel):\n \n     attack_bonus: int = 0\n     attack_neg_bonus: int = 0\n+    defense_bonus: int = 0\n     skip_next_turn: bool = False\n     reroll_dice_available: bool = False\n     draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nindex 937d1f7..7cc6b3a 100644\n--- a/server/gameplay/gameplay.py\n+++ b/server/gameplay/gameplay.py\n@@ -18,6 +18,7 @@ from .common import (\n # Stages\n ########################################################\n CHARACTER_SELECT = \"character_select\"\n+CARD_DRAW = \"card_draw\"\n ABILITY_SELECTION = \"ability_selection\"\n ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n OPPONENT_SELECTION = \"opponent_selection\"\n@@ -25,6 +26,7 @@ BATTLE_DICE_ROLL = \"battle_dice_roll\"\n BATTLE_END = \"battle_end\"\n STAGES_NAMES = [\n     CHARACTER_SELECT,\n+    CARD_DRAW,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n@@ -46,6 +48,7 @@ from .effects import (\n     EffectTotal,\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n+    DefenseBonusEffect,\n     SkipTurnEffect,\n     RerollDiceEffect,\n     DrawCardEffect,\n@@ -79,6 +82,8 @@ class Character(StrictModel):\n                 total.attack_bonus += eff.attack_bonus\n             elif isinstance(eff, AttackNegBonusEffect):\n                 total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, DefenseBonusEffect):\n+                total.defense_bonus += eff.defense_bonus\n             elif isinstance(eff, SkipTurnEffect):\n                 total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n             elif isinstance(eff, RerollDiceEffect):\n@@ -98,6 +103,12 @@ class CharacterSelectMeta(StrictModel):\n     selected: str  # Currently highlighted character\n \n \n+class CardDrawMeta(StrictModel):\n+    \"\"\"Stage metadata for card draw stage\"\"\"\n+\n+    drawn_card: str  # The card that was randomly drawn\n+\n+\n class AbilitySelectMeta(StrictModel):\n     \"\"\"Stage metadata for ability selection stage\"\"\"\n \n@@ -171,10 +182,11 @@ class GamePlay(StrictModel):\n     stage: StageName = CHARACTER_SELECT\n     players: dict[str, Player] = Field(default_factory=dict)\n     active: Optional[ActivePlayer] = None  # The active player and its selections\n+    card: Optional[str] = None  # Selected card from card_draw stage\n     ability: Optional[Ability] = None  # Selected ability\n     ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n     opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+    stage_meta: Optional[Ability | CharacterSelectMeta | CardDrawMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n \n     def reorder_players(self, username: str):\n         \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\ndiff --git a/src/constants/stages.js b/src/constants/stages.js\nindex 176cc8f..08ca49d 100644\n--- a/src/constants/stages.js\n+++ b/src/constants/stages.js\n@@ -1,5 +1,6 @@\n // Stage constants - must match backend stage names in server/gameplay/models.py\n export const CHARACTER_SELECT = \"character_select\";\n+export const CARD_DRAW = \"card_draw\";\n export const ABILITY_SELECTION = \"ability_selection\";\n export const ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\";\n export const OPPONENT_SELECTION = \"opponent_selection\";"
        },
        "id": "mobile-landscape",
        "name": "mobile-landscape",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "shard": null,
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.55.1",
    "workers": 1,
    "webServer": null
  },
  "suites": [],
  "errors": [
    {
      "message": "Error: Process from config.webServer was not able to start. Exit code: 1",
      "stack": "Error: Process from config.webServer was not able to start. Exit code: 1"
    }
  ],
  "stats": {
    "startTime": "2026-01-20T03:18:48.783Z",
    "duration": 4481.13,
    "expected": 0,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}