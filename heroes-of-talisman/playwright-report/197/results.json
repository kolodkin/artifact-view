{
  "config": {
    "configFile": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/playwright.config.js",
    "rootDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
    "forbidOnly": false,
    "fullyParallel": true,
    "globalSetup": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-setup.js",
    "globalTeardown": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-teardown.js",
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/e76da431d025adeaf6fd4cec21407c6cd045b7a4",
        "commitHash": "e76da431d025adeaf6fd4cec21407c6cd045b7a4",
        "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/34",
        "prTitle": "Standardize constant naming conventions across codebase",
        "prBaseHash": "7eea3362a32949bb1a86b804e9c27b37ea10d33d",
        "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21262381021"
      },
      "gitCommit": {
        "shortHash": "e76da43",
        "hash": "e76da431d025adeaf6fd4cec21407c6cd045b7a4",
        "subject": "Merge 8f23547df5408e06ac408eb775db83b2985e6c65 into 7eea3362a32949bb1a86b804e9c27b37ea10d33d",
        "body": "Merge 8f23547df5408e06ac408eb775db83b2985e6c65 into 7eea3362a32949bb1a86b804e9c27b37ea10d33d\n",
        "author": {
          "name": "mark kolodkin",
          "email": "mark.kolodkin@gmail.com",
          "time": 1769110792000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1769110792000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nindex 423dea5..6b441b0 100644\n--- a/server/gameplay/abilities.py\n+++ b/server/gameplay/abilities.py\n@@ -7,11 +7,11 @@ from pydantic import Field\n from .common import StrictModel\n from .effects import (\n     # Effect name constants for EFFECTS_SOURCE_ABILITY_MAP\n-    ATTACK_BONUS,\n-    ATTACK_NEG_BONUS,\n-    REROLL_DICE,\n-    SKIP_TURN,\n-    DRAW_CARD,\n+    EFFECT_ATTACK_BONUS,\n+    EFFECT_ATTACK_NEG_BONUS,\n+    EFFECT_REROLL_DICE,\n+    EFFECT_SKIP_TURN,\n+    EFFECT_DRAW_CARD,\n     # Apply to constants\n     APPLY_TO_SELECTED_OPPONENT,\n )\n@@ -19,10 +19,10 @@ from .effects import (\n ########################################################\n # Ability names - defined before imports from effects to avoid circular dependency\n ########################################################\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+ABILITY_BATTLE_HOWL = \"battle_howl\"\n+ABILITY_BOUNCING_ARROW = \"bouncing_arrow\"\n+ABILITY_FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE]\n AbilityName = Literal[*ABILITIES_NAMES]\n \n ########################################################\n@@ -31,11 +31,11 @@ AbilityName = Literal[*ABILITIES_NAMES]\n # Defines which abilities can create which effects\n # This is used for validation to ensure effects have valid source abilities\n EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+    EFFECT_ATTACK_BONUS: {ABILITY_BATTLE_HOWL},  # AttackBonusEffect can come from ABILITY_BATTLE_HOWL\n+    EFFECT_ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    EFFECT_REROLL_DICE: {ABILITY_BOUNCING_ARROW},  # RerollDiceEffect can come from ABILITY_BOUNCING_ARROW\n+    EFFECT_SKIP_TURN: {ABILITY_FREEZE},  # SkipTurnEffect can come from ABILITY_FREEZE\n+    EFFECT_DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n }\n \n # Import Effect classes after defining constants to avoid circular import\n@@ -58,22 +58,22 @@ class Ability(StrictModel):\n \n \n ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n+    ABILITY_BATTLE_HOWL: Ability(\n+        name=ABILITY_BATTLE_HOWL,\n         effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+            AttackBonusEffect(source=ABILITY_BATTLE_HOWL, attack_bonus=2),\n         ],\n     ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n+    ABILITY_BOUNCING_ARROW: Ability(\n+        name=ABILITY_BOUNCING_ARROW,\n         effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n+            RerollDiceEffect(source=ABILITY_BOUNCING_ARROW),\n         ],\n     ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n+    ABILITY_FREEZE: Ability(\n+        name=ABILITY_FREEZE,\n         effects=[\n-            SkipTurnEffect(source=FREEZE),\n+            SkipTurnEffect(source=ABILITY_FREEZE),\n         ],\n     ),\n }\ndiff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 431c25d..f66df31 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -1,26 +1,26 @@\n from typing import Dict\n \n from ..common import (\n-    CONNECT,\n-    LEAVE,\n-    DISCONNECT,\n-    CHARACTER_PRESS,\n-    CHARACTER_SELECT_ACTION,\n-    CARD_DRAW_ACTION,\n-    CARD_SELECT_ACTION,\n-    ABILITY_PRESS,\n-    ABILITY_SELECT,\n-    ABILITY_OPPONENT_PRESS,\n-    ABILITY_OPPONENT_SELECT,\n-    OPPONENT_PRESS,\n-    OPPONENT_SELECT,\n-    ACTIVE_PLAYER_ROLL,\n-    OPPONENT_ROLL,\n+    ACTION_CONNECT,\n+    ACTION_LEAVE,\n+    ACTION_DISCONNECT,\n+    ACTION_CHARACTER_PRESS,\n+    ACTION_CHARACTER_SELECT,\n+    ACTION_CARD_DRAW,\n+    ACTION_CARD_SELECT,\n+    ACTION_ABILITY_PRESS,\n+    ACTION_ABILITY_SELECT,\n+    ACTION_ABILITY_OPPONENT_PRESS,\n+    ACTION_ABILITY_OPPONENT_SELECT,\n+    ACTION_OPPONENT_PRESS,\n+    ACTION_OPPONENT_SELECT,\n+    ACTION_ACTIVE_PLAYER_ROLL,\n+    ACTION_OPPONENT_ROLL,\n     ACTION_REROLL,\n     ACTION_REROLL_EFFECT,\n-    BATTLE_END_ACTION,\n-    DEBUG_SET_BATTLE_DICE_ROLLS,\n-    DEBUG_SET_DRAWN_CARD,\n+    ACTION_BATTLE_END,\n+    ACTION_DEBUG_SET_BATTLE_DICE_ROLLS,\n+    ACTION_DEBUG_SET_DRAWN_CARD,\n )  # Action constants stay in models.py\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n@@ -34,24 +34,24 @@ from .battle_end import BattleEndAction\n \n # Action mapping for dynamic action execution\n ACTION_MAP: Dict[str, type[Action]] = {\n-    CONNECT: ConnectAction,\n-    LEAVE: LeaveAction,\n-    DISCONNECT: DisconnectAction,\n-    CHARACTER_PRESS: CharacterPressAction,\n-    CHARACTER_SELECT_ACTION: CharacterSelectAction,\n-    CARD_DRAW_ACTION: CardDrawAction,\n-    CARD_SELECT_ACTION: CardSelectAction,\n-    ABILITY_PRESS: AbilityPressAction,\n-    ABILITY_SELECT: AbilitySelectAction,\n-    ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\n-    ABILITY_OPPONENT_SELECT: AbilityOpponentSelectAction,\n-    OPPONENT_PRESS: OpponentPressAction,\n-    OPPONENT_SELECT: OpponentSelectAction,\n-    ACTIVE_PLAYER_ROLL: ActivePlayerRollAction,\n-    OPPONENT_ROLL: OpponentRollAction,\n+    ACTION_CONNECT: ConnectAction,\n+    ACTION_LEAVE: LeaveAction,\n+    ACTION_DISCONNECT: DisconnectAction,\n+    ACTION_CHARACTER_PRESS: CharacterPressAction,\n+    ACTION_CHARACTER_SELECT: CharacterSelectAction,\n+    ACTION_CARD_DRAW: CardDrawAction,\n+    ACTION_CARD_SELECT: CardSelectAction,\n+    ACTION_ABILITY_PRESS: AbilityPressAction,\n+    ACTION_ABILITY_SELECT: AbilitySelectAction,\n+    ACTION_ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\n+    ACTION_ABILITY_OPPONENT_SELECT: AbilityOpponentSelectAction,\n+    ACTION_OPPONENT_PRESS: OpponentPressAction,\n+    ACTION_OPPONENT_SELECT: OpponentSelectAction,\n+    ACTION_ACTIVE_PLAYER_ROLL: ActivePlayerRollAction,\n+    ACTION_OPPONENT_ROLL: OpponentRollAction,\n     ACTION_REROLL: RerollAction,\n     ACTION_REROLL_EFFECT: RerollEffectAction,\n-    BATTLE_END_ACTION: BattleEndAction,\n-    DEBUG_SET_BATTLE_DICE_ROLLS: DebugSetBattleDiceRollsAction,\n-    DEBUG_SET_DRAWN_CARD: DebugSetDrawnCardAction,\n+    ACTION_BATTLE_END: BattleEndAction,\n+    ACTION_DEBUG_SET_BATTLE_DICE_ROLLS: DebugSetBattleDiceRollsAction,\n+    ACTION_DEBUG_SET_DRAWN_CARD: DebugSetDrawnCardAction,\n }\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex f9bc5a1..52705e1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -7,8 +7,8 @@ Ends the battle, calculates winner, and reduces loser's health by 1.\n from .action import Action\n from ..common import GameException, ReportedException\n from ..gameplay import (\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     ActivePlayer1,\n     ActivePlayer3,\n@@ -28,7 +28,7 @@ class BattleEndAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_END]\n+        return [STAGE_BATTLE_END]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -65,11 +65,11 @@ class BattleEndAction(Action):\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n-        from ..common import BATTLE_END_ACTION\n+        from ..common import ACTION_BATTLE_END\n \n         def should_keep_effect(effect):\n             \"\"\"Returns True if effect should be kept after battle\"\"\"\n-            return BATTLE_END_ACTION not in effect.dispose_actions\n+            return ACTION_BATTLE_END not in effect.dispose_actions\n \n         active_character.effects = [\n             effect for effect in active_character.effects\n@@ -91,7 +91,7 @@ class BattleEndAction(Action):\n         self.game.opponent = None\n         self.game.card = None\n         self.game.ability = None\n-        self.game.stage = CHARACTER_SELECT\n+        self.game.stage = STAGE_CHARACTER_SELECT\n         self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/connection.py b/server/gameplay/actions/connection.py\nindex d5e417e..d538498 100644\n--- a/server/gameplay/actions/connection.py\n+++ b/server/gameplay/actions/connection.py\n@@ -4,14 +4,14 @@ from .action import Action\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n-    CHARACTER_SELECT,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     Character,\n@@ -33,17 +33,17 @@ class ConnectAction(Action):\n                 raise ReportedException(\"Game is full\")\n \n             characters: Dict[str, Character] = {}\n-            for char_type in [KNIGHT, ARCHER, MAGE]:\n+            for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n                 characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n \n-            self.players[self.user] = Player(name=self.user, status=CONNECTED, characters=characters)\n+            self.players[self.user] = Player(name=self.user, status=STATUS_CONNECTED, characters=characters)\n \n         if self.game.active is None:\n             if self.game.stage is None:\n-                self.game.stage = CHARACTER_SELECT\n+                self.game.stage = STAGE_CHARACTER_SELECT\n             self.game.active = ActivePlayer1(player=self.user)\n \n-        self.player.status = CONNECTED\n+        self.player.status = STATUS_CONNECTED\n         return self.game\n \n \n@@ -66,5 +66,5 @@ class DisconnectAction(Action):\n         return None  # Can disconnect at any time\n \n     def _run(self) -> GamePlay:\n-        self.player.status = DISCONNECTED\n+        self.player.status = STATUS_DISCONNECTED\n         return self.game\ndiff --git a/server/gameplay/actions/stage_ability_opponent_selection.py b/server/gameplay/actions/stage_ability_opponent_selection.py\nindex 5985c08..0280458 100644\n--- a/server/gameplay/actions/stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/stage_ability_opponent_selection.py\n@@ -8,7 +8,7 @@ This module implements actions for the ability opponent selection stage:\n \n from .action import Action\n from ..common import GameException, ReportedException\n-from ..gameplay import ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION, GamePlay, Opponent2\n+from ..gameplay import STAGE_ABILITY_OPPONENT_SELECTION, STAGE_OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class AbilityOpponentPressAction(Action):\n@@ -21,7 +21,7 @@ class AbilityOpponentPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_OPPONENT_SELECTION]\n+        return [STAGE_ABILITY_OPPONENT_SELECTION]\n \n     def _run(self, opponent: str, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -67,7 +67,7 @@ class AbilityOpponentSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_OPPONENT_SELECTION]\n+        return [STAGE_ABILITY_OPPONENT_SELECTION]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -107,7 +107,7 @@ class AbilityOpponentSelectAction(Action):\n         self.game.ability_opponent = selected_opponent\n \n         # Transition to opponent selection stage\n-        self.game.stage = OPPONENT_SELECTION\n+        self.game.stage = STAGE_OPPONENT_SELECTION\n         self.game.stage_meta = None  # Clear stage metadata\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_ability_selection.py b/server/gameplay/actions/stage_ability_selection.py\nindex af35bf2..fe8c9c4 100644\n--- a/server/gameplay/actions/stage_ability_selection.py\n+++ b/server/gameplay/actions/stage_ability_selection.py\n@@ -12,7 +12,7 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_SELF\n from ..abilities import AbilityName\n-from ..gameplay import ABILITY_SELECTION, ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION\n+from ..gameplay import STAGE_ABILITY_SELECTION, STAGE_ABILITY_OPPONENT_SELECTION, STAGE_OPPONENT_SELECTION\n from ..gameplay import GamePlay, AbilitySelectMeta\n \n \n@@ -26,7 +26,7 @@ class AbilityPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_SELECTION]\n+        return [STAGE_ABILITY_SELECTION]\n \n     def _run(self, ability: AbilityName) -> GamePlay:\n         # Validate user is the active player\n@@ -66,7 +66,7 @@ class AbilitySelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_SELECTION]\n+        return [STAGE_ABILITY_SELECTION]\n \n     def _run(self, ability: AbilityName) -> GamePlay:\n         # Validate user is the active player\n@@ -108,8 +108,8 @@ class AbilitySelectAction(Action):\n \n         # Transition to ability_opponent_selection if ability requires it, otherwise skip to opponent_selection\n         if ability_obj.requires_opponent_selection:\n-            self.game.stage = ABILITY_OPPONENT_SELECTION\n+            self.game.stage = STAGE_ABILITY_OPPONENT_SELECTION\n         else:\n-            self.game.stage = OPPONENT_SELECTION\n+            self.game.stage = STAGE_OPPONENT_SELECTION\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_battle.py b/server/gameplay/actions/stage_battle.py\nindex a8fe573..846a62f 100644\n--- a/server/gameplay/actions/stage_battle.py\n+++ b/server/gameplay/actions/stage_battle.py\n@@ -13,9 +13,9 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import RerollDiceEffect\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -100,7 +100,7 @@ def set_winner_if_both_rolled(game: GamePlay) -> None:\n                 return\n \n         # No reroll available for loser, transition to BATTLE_END\n-        game.stage = BATTLE_END\n+        game.stage = STAGE_BATTLE_END\n \n \n class ActivePlayerRollAction(Action):\n@@ -112,7 +112,7 @@ class ActivePlayerRollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -159,7 +159,7 @@ class OpponentRollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate opponent exists\n@@ -246,7 +246,7 @@ class RerollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate it's a draw (no winner) - must be ActivePlayer4/Opponent4 with results\n@@ -274,7 +274,7 @@ class RerollEffectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -321,7 +321,7 @@ class DebugSetBattleDiceRollsAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL, BATTLE_END]\n+        return [STAGE_BATTLE_DICE_ROLL, STAGE_BATTLE_END]\n \n     def _run(self, active_dice_roll: list[int], opponent_dice_roll: list[int]) -> GamePlay:\n         # Validate both players have rolled (must be ActivePlayer3/4 and Opponent3/4)\ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nindex 5578205..116c91d 100644\n--- a/server/gameplay/actions/stage_card_draw.py\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -11,7 +11,7 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n from ..cards import CardName, CARDS_MAP\n-from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import STAGE_CARD_DRAW, STAGE_ABILITY_SELECTION\n from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n \n \n@@ -25,7 +25,7 @@ class CardDrawAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -55,7 +55,7 @@ class CardSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -106,7 +106,7 @@ class CardSelectAction(Action):\n         self.game.stage_meta = None\n \n         # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n+        self.game.stage = STAGE_ABILITY_SELECTION\n \n         # Auto-select if character has only one ability\n         if len(character.abilities) == 1:\n@@ -133,7 +133,7 @@ class DebugSetDrawnCardAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self, card_name: str) -> GamePlay:\n         # Validate card exists\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex cd8ba75..e79d53a 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -10,12 +10,12 @@ from .action import Action\n from ..common import (\n     GameException,\n     ReportedException,\n-    CHARACTER_SELECT_ACTION,\n+    ACTION_CHARACTER_SELECT,\n )\n from ..gameplay import (\n-    CARD_DRAW,\n-    ABILITY_SELECTION,\n-    CHARACTER_SELECT,\n+    STAGE_CARD_DRAW,\n+    STAGE_ABILITY_SELECTION,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n     CardDrawMeta,\n@@ -34,7 +34,7 @@ class CharacterPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CHARACTER_SELECT]\n+        return [STAGE_CHARACTER_SELECT]\n \n     def _run(self, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -70,7 +70,7 @@ class CharacterSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CHARACTER_SELECT]\n+        return [STAGE_CHARACTER_SELECT]\n \n     def _run(self, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -94,14 +94,14 @@ class CharacterSelectAction(Action):\n         for char in player.characters.values():\n             char.effects = [\n                 effect for effect in char.effects\n-                if CHARACTER_SELECT_ACTION not in effect.dispose_actions\n+                if ACTION_CHARACTER_SELECT not in effect.dispose_actions\n             ]\n \n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n         # Transition to card_draw stage\n-        self.game.stage = CARD_DRAW\n+        self.game.stage = STAGE_CARD_DRAW\n \n         # Clear stage_meta - will be populated by CardDrawAction\n         self.game.stage_meta = None\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex 0195959..5afe93d 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -10,7 +10,7 @@ import copy\n from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_BATTLE_OPPONENT\n-from ..gameplay import BATTLE_DICE_ROLL, OPPONENT_SELECTION, GamePlay, Opponent2\n+from ..gameplay import STAGE_BATTLE_DICE_ROLL, STAGE_OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class OpponentPressAction(Action):\n@@ -23,7 +23,7 @@ class OpponentPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [OPPONENT_SELECTION]\n+        return [STAGE_OPPONENT_SELECTION]\n \n     def _run(self, opponent: str, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -69,7 +69,7 @@ class OpponentSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [OPPONENT_SELECTION]\n+        return [STAGE_OPPONENT_SELECTION]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -120,7 +120,7 @@ class OpponentSelectAction(Action):\n                     opponent_character.effects.append(effect_copy)\n \n         # Transition to battle dice roll stage\n-        self.game.stage = BATTLE_DICE_ROLL\n+        self.game.stage = STAGE_BATTLE_DICE_ROLL\n         self.game.stage_meta = None  # Clear stage metadata\n \n         return self.game\ndiff --git a/server/gameplay/actions/test_action_properties.py b/server/gameplay/actions/test_action_properties.py\nindex 858c847..93833d2 100644\n--- a/server/gameplay/actions/test_action_properties.py\n+++ b/server/gameplay/actions/test_action_properties.py\n@@ -7,10 +7,10 @@ These tests verify that action properties work correctly across different game s\n import pytest\n \n from .action import Action\n-from ..common import GameException, KNIGHT, MAGE, ARCHER\n+from ..common import GameException, CHARACTER_KNIGHT, CHARACTER_MAGE, CHARACTER_ARCHER\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     ActivePlayer1,\n@@ -54,8 +54,8 @@ def test_active_character_with_active_player2():\n     \"\"\"Test active_character property with ActivePlayer2\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -73,8 +73,8 @@ def test_active_character_with_active_player3():\n     \"\"\"Test active_character property with ActivePlayer3\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -92,8 +92,8 @@ def test_active_character_with_active_player4():\n     \"\"\"Test active_character property with ActivePlayer4\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer4(player=\"player1\", character=ARCHER, dice_roll=[3], result=BattleResult(winner=True, score=3)),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer4(player=\"player1\", character=CHARACTER_ARCHER, dice_roll=[3], result=BattleResult(winner=True, score=3)),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -111,7 +111,7 @@ def test_active_character_with_active_player1_fails():\n     \"\"\"Test active_character property fails with ActivePlayer1 (no character selected)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -127,7 +127,7 @@ def test_active_character_with_no_active_fails():\n     \"\"\"Test active_character property fails when no active player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -148,9 +148,9 @@ def test_opponent_character_with_opponent2():\n     \"\"\"Test opponent_character property with Opponent2\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -169,9 +169,9 @@ def test_opponent_character_with_opponent3():\n     \"\"\"Test opponent_character property with Opponent3\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent3(player=\"player2\", character=ARCHER, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_ARCHER, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -190,9 +190,9 @@ def test_opponent_character_with_opponent4():\n     \"\"\"Test opponent_character property with Opponent4\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer4(player=\"player1\", character=KNIGHT, dice_roll=[6], result=BattleResult(winner=True, score=7)),\n-        opponent=Opponent4(player=\"player2\", character=MAGE, dice_roll=[1], result=BattleResult(winner=False, score=1)),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer4(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6], result=BattleResult(winner=True, score=7)),\n+        opponent=Opponent4(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[1], result=BattleResult(winner=False, score=1)),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -211,8 +211,8 @@ def test_opponent_character_with_no_opponent_fails():\n     \"\"\"Test opponent_character property fails when no opponent\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -233,7 +233,7 @@ def test_player_property():\n     \"\"\"Test player property returns correct player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -245,16 +245,16 @@ def test_player_property():\n     player = action.player\n \n     assert player.name == \"player1\"\n-    assert KNIGHT in player.characters\n-    assert player.characters[KNIGHT].health == KNIGHT_L1_DEFAULT_HEALTH\n-    assert player.characters[KNIGHT].attack == KNIGHT_L1_ATTACK\n+    assert CHARACTER_KNIGHT in player.characters\n+    assert player.characters[CHARACTER_KNIGHT].health == KNIGHT_L1_DEFAULT_HEALTH\n+    assert player.characters[CHARACTER_KNIGHT].attack == KNIGHT_L1_ATTACK\n \n \n def test_player_property_player_not_in_game_fails():\n     \"\"\"Test player property fails when player not in game\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -275,7 +275,7 @@ def test_stage_property_get():\n     \"\"\"Test stage property getter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n+        stage=STAGE_BATTLE_DICE_ROLL,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -283,14 +283,14 @@ def test_stage_property_get():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    assert action.stage == BATTLE_DICE_ROLL\n+    assert action.stage == STAGE_BATTLE_DICE_ROLL\n \n \n def test_stage_property_set():\n     \"\"\"Test stage property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -298,9 +298,9 @@ def test_stage_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    action.stage = BATTLE_DICE_ROLL\n-    assert action.stage == BATTLE_DICE_ROLL\n-    assert game.stage == BATTLE_DICE_ROLL\n+    action.stage = STAGE_BATTLE_DICE_ROLL\n+    assert action.stage == STAGE_BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n \n \n # ============================================================================\n@@ -311,9 +311,9 @@ def test_stage_property_set():\n def test_active_property_get():\n     \"\"\"Test active property getter\"\"\"\n     characters = init_characters()\n-    active_player = ActivePlayer2(player=\"player1\", character=KNIGHT)\n+    active_player = ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT)\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=active_player,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -323,14 +323,14 @@ def test_active_property_get():\n     action = ConcreteAction(\"player1\", game)\n     assert action.active == active_player\n     assert action.active.player == \"player1\"\n-    assert action.active.character == KNIGHT\n+    assert action.active.character == CHARACTER_KNIGHT\n \n \n def test_active_property_set():\n     \"\"\"Test active property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -338,7 +338,7 @@ def test_active_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    new_active = ActivePlayer2(player=\"player1\", character=MAGE)\n+    new_active = ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE)\n     action.active = new_active\n \n     assert action.active == new_active\n@@ -348,10 +348,10 @@ def test_active_property_set():\n def test_opponent_property_get():\n     \"\"\"Test opponent property getter\"\"\"\n     characters = init_characters()\n-    opponent = Opponent2(player=\"player2\", character=ARCHER)\n+    opponent = Opponent2(player=\"player2\", character=CHARACTER_ARCHER)\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=opponent,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -362,15 +362,15 @@ def test_opponent_property_get():\n     action = ConcreteAction(\"player1\", game)\n     assert action.opponent == opponent\n     assert action.opponent.player == \"player2\"\n-    assert action.opponent.character == ARCHER\n+    assert action.opponent.character == CHARACTER_ARCHER\n \n \n def test_opponent_property_set():\n     \"\"\"Test opponent property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -379,7 +379,7 @@ def test_opponent_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    new_opponent = Opponent2(player=\"player2\", character=MAGE)\n+    new_opponent = Opponent2(player=\"player2\", character=CHARACTER_MAGE)\n     action.opponent = new_opponent\n \n     assert action.opponent == new_opponent\ndiff --git a/server/gameplay/actions/test_connect_action.py b/server/gameplay/actions/test_connect_action.py\nindex 3e2564d..30dfb73 100644\n--- a/server/gameplay/actions/test_connect_action.py\n+++ b/server/gameplay/actions/test_connect_action.py\n@@ -10,14 +10,14 @@ import pytest\n from .connection import ConnectAction, MAX_PLAYERS\n from ..common import (\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n-    CHARACTER_SELECT,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     Character,\n@@ -37,31 +37,31 @@ def test_connect_action_new_player():\n \n     assert \"player1\" in updated_game.players\n     assert updated_game.players[\"player1\"].name == \"player1\"\n-    assert updated_game.players[\"player1\"].status == CONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n     assert len(updated_game.players[\"player1\"].characters) == 3\n-    assert KNIGHT in updated_game.players[\"player1\"].characters\n-    assert ARCHER in updated_game.players[\"player1\"].characters\n-    assert MAGE in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_KNIGHT in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_ARCHER in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_MAGE in updated_game.players[\"player1\"].characters\n     # Verify each character has empty cards list\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].cards == []\n-    assert updated_game.players[\"player1\"].characters[ARCHER].cards == []\n-    assert updated_game.players[\"player1\"].characters[MAGE].cards == []\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].cards == []\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_ARCHER].cards == []\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_MAGE].cards == []\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n \n def test_connect_action_existing_player_reconnect():\n     \"\"\"Test reconnecting an existing player who was disconnected\"\"\"\n     game = GamePlay()\n-    knight_char = Character(level=2, **CHARACTER_DEFAULT_STATS[KNIGHT])\n+    knight_char = Character(level=2, **CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT])\n     knight_char.cards = [\"talisman\"]  # Knight has a card\n     game.players[\"player1\"] = Player(\n         name=\"player1\",\n-        status=DISCONNECTED,\n+        status=STATUS_DISCONNECTED,\n         characters={\n             KNIGHT: knight_char,\n-            ARCHER: Character(level=1, **CHARACTER_DEFAULT_STATS[ARCHER]),\n-            MAGE: Character(level=1, **CHARACTER_DEFAULT_STATS[MAGE]),\n+            ARCHER: Character(level=1, **CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER]),\n+            MAGE: Character(level=1, **CHARACTER_DEFAULT_STATS[CHARACTER_MAGE]),\n         },\n     )\n \n@@ -69,9 +69,9 @@ def test_connect_action_existing_player_reconnect():\n     updated_game = action.run()\n \n     # Player should be reconnected with their existing data\n-    assert updated_game.players[\"player1\"].status == CONNECTED\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].cards == [\"talisman\"]\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].level == 2\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].cards == [\"talisman\"]\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].level == 2\n \n \n def test_connect_action_game_full():\n@@ -82,7 +82,7 @@ def test_connect_action_game_full():\n     for i in range(MAX_PLAYERS):\n         player_name = f\"player{i+1}\"\n         characters = {}\n-        for char_type in [KNIGHT, ARCHER, MAGE]:\n+        for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n             characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n         game.players[player_name] = Player(name=player_name, characters=characters)\n \n@@ -95,10 +95,10 @@ def test_connect_action_game_full():\n def test_connect_action_second_player():\n     \"\"\"Test connecting a second player to a game with one player\"\"\"\n     game = GamePlay()\n-    game.stage = CHARACTER_SELECT\n+    game.stage = STAGE_CHARACTER_SELECT\n     game.active = ActivePlayer1(player=\"player1\")\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n \n@@ -106,8 +106,8 @@ def test_connect_action_second_player():\n     updated_game = action.run()\n \n     assert \"player2\" in updated_game.players\n-    assert updated_game.players[\"player2\"].status == CONNECTED\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player2\"].status == STATUS_CONNECTED\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"  # Active player should not change\n \n \n@@ -119,7 +119,7 @@ def test_connect_action_stage_none():\n \n     updated_game = action.run()\n \n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n \n@@ -133,25 +133,25 @@ def test_connect_action_character_stats():\n     player = updated_game.players[\"player1\"]\n \n     # Check knight stats\n-    knight = player.characters[KNIGHT]\n+    knight = player.characters[CHARACTER_KNIGHT]\n     assert knight.level == 1\n-    assert knight.health == CHARACTER_DEFAULT_STATS[KNIGHT][\"health\"]\n-    assert knight.max_health == CHARACTER_DEFAULT_STATS[KNIGHT][\"max_health\"]\n-    assert knight.dice == CHARACTER_DEFAULT_STATS[KNIGHT][\"dice\"]\n-    assert knight.attack == CHARACTER_DEFAULT_STATS[KNIGHT][\"attack\"]\n+    assert knight.health == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"health\"]\n+    assert knight.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"max_health\"]\n+    assert knight.dice == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"dice\"]\n+    assert knight.attack == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"attack\"]\n \n     # Check archer stats (no attack bonus)\n-    archer = player.characters[ARCHER]\n+    archer = player.characters[CHARACTER_ARCHER]\n     assert archer.level == 1\n-    assert archer.health == CHARACTER_DEFAULT_STATS[ARCHER][\"health\"]\n-    assert archer.max_health == CHARACTER_DEFAULT_STATS[ARCHER][\"max_health\"]\n-    assert archer.dice == CHARACTER_DEFAULT_STATS[ARCHER][\"dice\"]\n+    assert archer.health == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"health\"]\n+    assert archer.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"max_health\"]\n+    assert archer.dice == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"dice\"]\n     assert archer.attack == ARCHER_L1_ATTACK\n \n     # Check mage stats (no attack bonus)\n-    mage = player.characters[MAGE]\n+    mage = player.characters[CHARACTER_MAGE]\n     assert mage.level == 1\n-    assert mage.health == CHARACTER_DEFAULT_STATS[MAGE][\"health\"]\n-    assert mage.max_health == CHARACTER_DEFAULT_STATS[MAGE][\"max_health\"]\n-    assert mage.dice == CHARACTER_DEFAULT_STATS[MAGE][\"dice\"]\n+    assert mage.health == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"health\"]\n+    assert mage.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"max_health\"]\n+    assert mage.dice == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"dice\"]\n     assert mage.attack == MAGE_L1_ATTACK\ndiff --git a/server/gameplay/actions/test_connection_integration.py b/server/gameplay/actions/test_connection_integration.py\nindex e63bdab..fed9856 100644\n--- a/server/gameplay/actions/test_connection_integration.py\n+++ b/server/gameplay/actions/test_connection_integration.py\n@@ -9,8 +9,8 @@ and leaving actions.\n import pytest\n \n from .connection import ConnectAction, DisconnectAction, LeaveAction\n-from ..common import CONNECTED, DISCONNECTED\n-from ..gameplay import CHARACTER_SELECT, GamePlay\n+from ..common import STATUS_CONNECTED, STATUS_DISCONNECTED\n+from ..gameplay import STAGE_CHARACTER_SELECT, GamePlay\n \n \n def test_connect_then_disconnect_then_reconnect():\n@@ -21,21 +21,21 @@ def test_connect_then_disconnect_then_reconnect():\n     connect_action = ConnectAction(\"player1\", game)\n     updated_game = connect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == CONNECTED\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n     # Disconnect\n     disconnect_action = DisconnectAction(\"player1\", updated_game)\n     updated_game = disconnect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\n \n     # Reconnect\n     reconnect_action = ConnectAction(\"player1\", updated_game)\n     updated_game = reconnect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == CONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n \n \n def test_multiple_players_connect_disconnect_leave():\n@@ -55,7 +55,7 @@ def test_multiple_players_connect_disconnect_leave():\n     disconnect_action = DisconnectAction(\"player2\", game)\n     game = disconnect_action.run()\n \n-    assert game.players[\"player2\"].status == DISCONNECTED\n+    assert game.players[\"player2\"].status == STATUS_DISCONNECTED\n     assert len(game.players) == 3  # Still in game\n \n     # Player3 leaves\n@@ -69,5 +69,5 @@ def test_multiple_players_connect_disconnect_leave():\n     reconnect_action = ConnectAction(\"player2\", game)\n     game = reconnect_action.run()\n \n-    assert game.players[\"player2\"].status == CONNECTED\n+    assert game.players[\"player2\"].status == STATUS_CONNECTED\n     assert len(game.players) == 2\ndiff --git a/server/gameplay/actions/test_disconnect_action.py b/server/gameplay/actions/test_disconnect_action.py\nindex 2337f53..c9fdb35 100644\n--- a/server/gameplay/actions/test_disconnect_action.py\n+++ b/server/gameplay/actions/test_disconnect_action.py\n@@ -10,11 +10,11 @@ import pytest\n from .connection import DisconnectAction\n from ..common import (\n     GameException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n     GamePlay,\n@@ -28,14 +28,14 @@ def test_disconnect_action_existing_player():\n     \"\"\"Test disconnecting an existing connected player\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n-    game.players[\"player1\"] = Player(name=\"player1\", status=CONNECTED, characters=characters)\n+    game.players[\"player1\"] = Player(name=\"player1\", status=STATUS_CONNECTED, characters=characters)\n \n     action = DisconnectAction(\"player1\", game)\n     updated_game = action.run()\n \n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\n     assert updated_game.players[\"player1\"].name == \"player1\"  # Other data preserved\n \n \n@@ -52,12 +52,12 @@ def test_disconnect_action_already_disconnected():\n     \"\"\"Test disconnecting a player who is already disconnected\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n-    game.players[\"player1\"] = Player(name=\"player1\", status=DISCONNECTED, characters=characters)\n+    game.players[\"player1\"] = Player(name=\"player1\", status=STATUS_DISCONNECTED, characters=characters)\n \n     action = DisconnectAction(\"player1\", game)\n     updated_game = action.run()\n \n     # Should still work and status remains disconnected\n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\ndiff --git a/server/gameplay/actions/test_leave_action.py b/server/gameplay/actions/test_leave_action.py\nindex e67ef2e..7b43472 100644\n--- a/server/gameplay/actions/test_leave_action.py\n+++ b/server/gameplay/actions/test_leave_action.py\n@@ -9,7 +9,7 @@ the only player leaving.\n import pytest\n \n from .connection import LeaveAction\n-from ..common import GameException, KNIGHT, ARCHER, MAGE\n+from ..common import GameException, CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE\n from ..gameplay import (\n     GamePlay,\n     Player,\n@@ -22,7 +22,7 @@ def test_leave_action_existing_player():\n     \"\"\"Test a player leaving the game\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n     game.players[\"player2\"] = Player(name=\"player2\", characters=characters)\n@@ -47,7 +47,7 @@ def test_leave_action_only_player():\n     \"\"\"Test the only player in the game leaving\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n \ndiff --git a/server/gameplay/actions/test_stage_ability_opponent_selection.py b/server/gameplay/actions/test_stage_ability_opponent_selection.py\nindex 75dfb7d..1f4618f 100644\n--- a/server/gameplay/actions/test_stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_opponent_selection.py\n@@ -8,11 +8,11 @@ selected opponents for ability targeting and confirming selections to apply effe\n import pytest\n \n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n-from ..common import GameException, ReportedException, KNIGHT, MAGE\n-from ..abilities import BATTLE_HOWL, FREEZE, ABILITIES_MAP\n+from ..common import GameException, ReportedException, CHARACTER_KNIGHT, CHARACTER_MAGE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_FREEZE, ABILITIES_MAP\n from ..gameplay import (\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n+    STAGE_ABILITY_OPPONENT_SELECTION,\n+    STAGE_OPPONENT_SELECTION,\n     GamePlay,\n     Player,\n     ActivePlayer2,\n@@ -25,9 +25,9 @@ def test_ability_opponent_press_action_valid():\n     \"\"\"Test pressing opponent's character highlights it in stage_meta\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -35,22 +35,22 @@ def test_ability_opponent_press_action_valid():\n     )\n \n     action = AbilityOpponentPressAction(\"player1\", game)\n-    updated_game = action.run(opponent=\"player2\", character=KNIGHT)\n+    updated_game = action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n     assert updated_game.stage_meta is not None\n     assert isinstance(updated_game.stage_meta, Opponent2)\n     assert updated_game.stage_meta.player == \"player2\"\n-    assert updated_game.stage_meta.character == KNIGHT\n-    assert updated_game.stage == ABILITY_OPPONENT_SELECTION  # Still in ability opponent selection\n+    assert updated_game.stage_meta.character == CHARACTER_KNIGHT\n+    assert updated_game.stage == STAGE_ABILITY_OPPONENT_SELECTION  # Still in ability opponent selection\n \n \n def test_ability_opponent_press_action_not_active_player():\n     \"\"\"Test pressing opponent when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -60,16 +60,16 @@ def test_ability_opponent_press_action_not_active_player():\n     action = AbilityOpponentPressAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(opponent=\"player1\", character=KNIGHT)\n+        action.run(opponent=\"player1\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_wrong_stage():\n     \"\"\"Test pressing opponent in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -79,32 +79,32 @@ def test_ability_opponent_press_action_wrong_stage():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(opponent=\"player2\", character=KNIGHT)\n+        action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_invalid_opponent():\n     \"\"\"Test pressing non-existent opponent raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"not in game\"):\n-        action.run(opponent=\"nonexistent\", character=KNIGHT)\n+        action.run(opponent=\"nonexistent\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_self_as_opponent():\n     \"\"\"Test pressing self as opponent raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -114,18 +114,18 @@ def test_ability_opponent_press_action_self_as_opponent():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"Cannot select yourself as opponent\"):\n-        action.run(opponent=\"player1\", character=KNIGHT)\n+        action.run(opponent=\"player1\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_dead_character():\n     \"\"\"Test pressing dead character raises error\"\"\"\n     characters = init_characters()\n     # Kill the knight\n-    characters[KNIGHT].health = 0\n+    characters[CHARACTER_KNIGHT].health = 0\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n-        ability=ABILITIES_MAP[FREEZE],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n+        ability=ABILITIES_MAP[ABILITY_FREEZE],\n         players={\n             \"player1\": Player(name=\"player1\", characters=init_characters()),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -135,7 +135,7 @@ def test_ability_opponent_press_action_dead_character():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"is dead and can't be targeted\"):\n-        action.run(opponent=\"player2\", character=KNIGHT)\n+        action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_select_action_valid():\n@@ -143,10 +143,10 @@ def test_ability_opponent_select_action_valid():\n     characters1 = init_characters()\n     characters2 = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters1),\n             \"player2\": Player(name=\"player2\", characters=characters2),\n@@ -157,28 +157,28 @@ def test_ability_opponent_select_action_valid():\n     updated_game = action.run()\n \n     # Check stage transition\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.stage_meta is None\n \n     # Check ability_opponent is set\n     assert updated_game.ability_opponent is not None\n     assert updated_game.ability_opponent.player == \"player2\"\n-    assert updated_game.ability_opponent.character == KNIGHT\n+    assert updated_game.ability_opponent.character == CHARACTER_KNIGHT\n \n     # Check effects were applied to target character\n-    target_character = updated_game.players[\"player2\"].characters[KNIGHT]\n+    target_character = updated_game.players[\"player2\"].characters[CHARACTER_KNIGHT]\n     assert len(target_character.effects) > 0\n-    assert target_character.effects[0].source == BATTLE_HOWL\n+    assert target_character.effects[0].source == ABILITY_BATTLE_HOWL\n \n \n def test_ability_opponent_select_action_not_active_player():\n     \"\"\"Test confirming ability opponent selection when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -195,10 +195,10 @@ def test_ability_opponent_select_action_wrong_stage():\n     \"\"\"Test confirming ability opponent selection in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -215,9 +215,9 @@ def test_ability_opponent_select_action_no_target_selected():\n     \"\"\"Test confirming ability opponent selection without selecting target raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -235,13 +235,13 @@ def test_ability_opponent_select_action_dead_character():\n     characters1 = init_characters()\n     characters2 = init_characters()\n     # Kill the target knight\n-    characters2[KNIGHT].health = 0\n+    characters2[CHARACTER_KNIGHT].health = 0\n \n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n-        ability=ABILITIES_MAP[FREEZE],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n+        ability=ABILITIES_MAP[ABILITY_FREEZE],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters1),\n             \"player2\": Player(name=\"player2\", characters=characters2),\ndiff --git a/server/gameplay/actions/test_stage_ability_selection.py b/server/gameplay/actions/test_stage_ability_selection.py\nindex b3c0106..60c2eb1 100644\n--- a/server/gameplay/actions/test_stage_ability_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_selection.py\n@@ -3,8 +3,8 @@ Tests for Ability Selection Stage Actions.\n \n These tests verify ability selection behavior including highlighting\n selected abilities and confirming selections to transition to:\n-- ability_opponent_selection (for effects requiring target selection, e.g., FREEZE)\n-- opponent_selection (for effects applied to battle opponent, e.g., BATTLE_HOWL, BOUNCING_ARROW)\n+- ability_opponent_selection (for effects requiring target selection, e.g., ABILITY_FREEZE)\n+- opponent_selection (for effects applied to battle opponent, e.g., ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW)\n \"\"\"\n \n import pytest\n@@ -13,17 +13,17 @@ from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n )\n from ..effects import REROLL_DICE\n-from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE\n from ..gameplay import (\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    CHARACTER_SELECT,\n+    STAGE_ABILITY_SELECTION,\n+    STAGE_ABILITY_OPPONENT_SELECTION,\n+    STAGE_OPPONENT_SELECTION,\n+    STAGE_CHARACTER_SELECT,\n )\n from ..effects import RerollDiceEffect\n from ..gameplay import (\n@@ -38,25 +38,25 @@ def test_ability_press_action_valid():\n     \"\"\"Test pressing an ability highlights it in stage_meta\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=BATTLE_HOWL)\n+    updated_game = action.run(ability=ABILITY_BATTLE_HOWL)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == BATTLE_HOWL\n-    assert updated_game.stage == ABILITY_SELECTION  # Still in ability selection\n+    assert updated_game.stage_meta.selected == ABILITY_BATTLE_HOWL\n+    assert updated_game.stage == STAGE_ABILITY_SELECTION  # Still in ability selection\n \n \n def test_ability_press_action_not_active_player():\n     \"\"\"Test pressing ability when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -66,88 +66,88 @@ def test_ability_press_action_not_active_player():\n     action = AbilityPressAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_press_action_wrong_stage():\n     \"\"\"Test pressing ability in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_press_action_invalid_ability():\n     \"\"\"Test pressing ability not available for character raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n \n-    # Knight should have BATTLE_HOWL, not FREEZE (which is for mage)\n+    # Knight should have ABILITY_BATTLE_HOWL, not ABILITY_FREEZE (which is for mage)\n     with pytest.raises(ReportedException, match=\"not available for this character\"):\n-        action.run(ability=FREEZE)\n+        action.run(ability=ABILITY_FREEZE)\n \n \n def test_ability_press_action_archer():\n-    \"\"\"Test pressing archer's ability (BOUNCING_ARROW) works correctly\"\"\"\n+    \"\"\"Test pressing archer's ability (ABILITY_BOUNCING_ARROW) works correctly\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == BOUNCING_ARROW\n+    assert updated_game.stage_meta.selected == ABILITY_BOUNCING_ARROW\n \n \n def test_ability_press_action_mage():\n-    \"\"\"Test pressing mage's ability (FREEZE) works correctly\"\"\"\n+    \"\"\"Test pressing mage's ability (ABILITY_FREEZE) works correctly\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=FREEZE)\n+    updated_game = action.run(ability=ABILITY_FREEZE)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == FREEZE\n+    assert updated_game.stage_meta.selected == ABILITY_FREEZE\n \n \n def test_ability_select_action_valid():\n     \"\"\"Test confirming ability selection transitions to opponent_selection (for battle opponent effects)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BATTLE_HOWL)\n+    updated_game = action.run(ability=ABILITY_BATTLE_HOWL)\n \n-    # BATTLE_HOWL applies to battle opponent, so skip ability_opponent_selection\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    # ABILITY_BATTLE_HOWL applies to battle opponent, so skip ability_opponent_selection\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == BATTLE_HOWL\n+    assert updated_game.ability.name == ABILITY_BATTLE_HOWL\n     assert updated_game.stage_meta is None\n \n \n@@ -155,8 +155,8 @@ def test_ability_select_action_not_active_player():\n     \"\"\"Test confirming ability selection when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -166,76 +166,76 @@ def test_ability_select_action_not_active_player():\n     action = AbilitySelectAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_select_action_wrong_stage():\n     \"\"\"Test confirming ability selection in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_select_action_invalid_ability():\n     \"\"\"Test confirming ability not available for character raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n \n-    # Knight should have BATTLE_HOWL, not BOUNCING_ARROW (which is for archer)\n+    # Knight should have ABILITY_BATTLE_HOWL, not ABILITY_BOUNCING_ARROW (which is for archer)\n     with pytest.raises(ReportedException, match=\"not available for this character\"):\n-        action.run(ability=BOUNCING_ARROW)\n+        action.run(ability=ABILITY_BOUNCING_ARROW)\n \n \n def test_ability_select_action_archer():\n     \"\"\"Test confirming archer's ability selection skips to opponent_selection\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n-    # BOUNCING_ARROW applies to self, so skip ability_opponent_selection\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    # ABILITY_BOUNCING_ARROW applies to self, so skip ability_opponent_selection\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == BOUNCING_ARROW\n+    assert updated_game.ability.name == ABILITY_BOUNCING_ARROW\n     assert updated_game.stage_meta is None\n \n \n def test_ability_select_action_archer_applies_reroll_effect():\n-    \"\"\"Test confirming BOUNCING_ARROW applies RerollDiceEffect to active player's character\"\"\"\n+    \"\"\"Test confirming ABILITY_BOUNCING_ARROW applies RerollDiceEffect to active player's character\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     # Verify archer has no effects before\n-    assert len(game.players[\"player1\"].characters[ARCHER].effects) == 0\n+    assert len(game.players[\"player1\"].characters[CHARACTER_ARCHER].effects) == 0\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n     # Verify RerollDiceEffect was applied to the active player's archer\n-    archer = updated_game.players[\"player1\"].characters[ARCHER]\n+    archer = updated_game.players[\"player1\"].characters[CHARACTER_ARCHER]\n     assert len(archer.effects) == 1\n     assert isinstance(archer.effects[0], RerollDiceEffect)\n     assert archer.effects[0].name == REROLL_DICE\n@@ -247,16 +247,16 @@ def test_ability_select_action_mage():\n     \"\"\"Test confirming mage's ability selection transitions to ability_opponent_selection\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=FREEZE)\n+    updated_game = action.run(ability=ABILITY_FREEZE)\n \n-    # FREEZE requires opponent selection (SkipTurnEffect), so go to ability_opponent_selection\n-    assert updated_game.stage == ABILITY_OPPONENT_SELECTION\n+    # ABILITY_FREEZE requires opponent selection (SkipTurnEffect), so go to ability_opponent_selection\n+    assert updated_game.stage == STAGE_ABILITY_STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == FREEZE\n+    assert updated_game.ability.name == ABILITY_FREEZE\n     assert updated_game.stage_meta is None\ndiff --git a/server/gameplay/actions/test_stage_battle_dice_roll.py b/server/gameplay/actions/test_stage_battle_dice_roll.py\nindex bbc80fd..80e63ff 100644\n--- a/server/gameplay/actions/test_stage_battle_dice_roll.py\n+++ b/server/gameplay/actions/test_stage_battle_dice_roll.py\n@@ -19,11 +19,11 @@ from .stage_battle import (\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n )\n-from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE\n from ..effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n@@ -31,10 +31,10 @@ from ..effects import (\n     RerollDiceEffect,\n )\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n-    OPPONENT_SELECTION,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n+    STAGE_OPPONENT_SELECTION,\n )\n from ..gameplay import (\n     GamePlay,\n@@ -60,9 +60,9 @@ def test_active_player_roll_action_valid():\n     \"\"\"Test active player successfully rolls dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -75,9 +75,9 @@ def test_active_player_roll_action_valid():\n     # Verify active player upgraded to ActivePlayer3 with dice_roll\n     assert isinstance(updated_game.active, ActivePlayer3)\n     assert updated_game.active.player == \"player1\"\n-    assert updated_game.active.character == KNIGHT\n+    assert updated_game.active.character == CHARACTER_KNIGHT\n     assert updated_game.active.dice_roll is not None\n-    assert len(updated_game.active.dice_roll) == characters[KNIGHT].dice\n+    assert len(updated_game.active.dice_roll) == characters[CHARACTER_KNIGHT].dice\n     assert all(1 <= d <= 6 for d in updated_game.active.dice_roll)\n \n     # Opponent should still be Opponent2 (hasn't rolled yet)\n@@ -88,9 +88,9 @@ def test_active_player_roll_triggers_winner_calculation():\n     \"\"\"Test that when active player rolls and opponent already rolled, winner is calculated\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -109,7 +109,7 @@ def test_active_player_roll_wrong_stage():\n     \"\"\"Test active player roll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -126,9 +126,9 @@ def test_active_player_roll_not_active_player():\n     \"\"\"Test active player roll fails when user is not the active player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -145,9 +145,9 @@ def test_active_player_roll_player_not_in_game():\n     \"\"\"Test active player roll fails when player doesn't exist in game\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player2\": Player(name=\"player2\", characters=characters),\n         },\n@@ -163,7 +163,7 @@ def test_active_player_roll_no_character():\n     \"\"\"Test active player roll fails when no character selected\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n+        stage=STAGE_BATTLE_DICE_ROLL,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -185,9 +185,9 @@ def test_opponent_roll_action_valid():\n     \"\"\"Test opponent successfully rolls dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -200,9 +200,9 @@ def test_opponent_roll_action_valid():\n     # Verify opponent upgraded to Opponent3 with dice_roll\n     assert isinstance(updated_game.opponent, Opponent3)\n     assert updated_game.opponent.player == \"player2\"\n-    assert updated_game.opponent.character == MAGE\n+    assert updated_game.opponent.character == CHARACTER_MAGE\n     assert updated_game.opponent.dice_roll is not None\n-    assert len(updated_game.opponent.dice_roll) == characters[MAGE].dice\n+    assert len(updated_game.opponent.dice_roll) == characters[CHARACTER_MAGE].dice\n     assert all(1 <= d <= 6 for d in updated_game.opponent.dice_roll)\n \n     # Active player should still be ActivePlayer2 (hasn't rolled yet)\n@@ -213,9 +213,9 @@ def test_opponent_roll_triggers_winner_calculation():\n     \"\"\"Test that when opponent rolls and active already rolled, winner is calculated\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -234,7 +234,7 @@ def test_opponent_roll_wrong_stage():\n     \"\"\"Test opponent roll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -252,9 +252,9 @@ def test_opponent_roll_not_opponent():\n     \"\"\"Test opponent roll fails when user is not the opponent\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -271,8 +271,8 @@ def test_opponent_roll_no_opponent():\n     \"\"\"Test opponent roll fails when no opponent exists\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -298,7 +298,7 @@ def test_reroll_action_valid_draw():\n     game = get_debug_preset(\"battle_draw\")\n \n     # Verify initial state is a draw\n-    assert game.stage == BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n     assert isinstance(game.active, ActivePlayer4)\n     assert isinstance(game.opponent, Opponent4)\n     assert game.active.result.winner is False\n@@ -311,16 +311,16 @@ def test_reroll_action_valid_draw():\n     assert isinstance(updated_game.active, ActivePlayer2)\n     assert isinstance(updated_game.opponent, Opponent2)\n     assert updated_game.active.player == \"player1\"\n-    assert updated_game.active.character == KNIGHT\n+    assert updated_game.active.character == CHARACTER_KNIGHT\n     assert updated_game.opponent.player == \"player2\"\n-    assert updated_game.opponent.character == ARCHER\n+    assert updated_game.opponent.character == CHARACTER_ARCHER\n \n \n def test_reroll_action_wrong_stage():\n     \"\"\"Test reroll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -347,9 +347,9 @@ def test_reroll_action_active_not_rolled():\n     \"\"\"Test reroll fails when active player hasn't rolled yet (not ActivePlayer4)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -367,9 +367,9 @@ def test_reroll_action_opponent_not_rolled():\n     \"\"\"Test reroll fails when opponent hasn't rolled yet (not Opponent4)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -384,25 +384,25 @@ def test_reroll_action_opponent_not_rolled():\n \n \n def test_reroll_action_winner_exists():\n-    \"\"\"Test reroll fails when there's already a winner (stage is BATTLE_END)\"\"\"\n+    \"\"\"Test reroll fails when there's already a winner (stage is STAGE_BATTLE_END)\"\"\"\n     game = get_debug_preset(\"battle_player_1_win\")\n \n-    # Verify initial state has a winner and is in BATTLE_END stage\n+    # Verify initial state has a winner and is in STAGE_BATTLE_END stage\n     assert game.active.result.winner is True\n     assert game.opponent.result.winner is False\n-    assert game.stage == BATTLE_END\n+    assert game.stage == STAGE_BATTLE_END\n \n     action = RerollAction(\"player1\", game)\n \n-    # Should fail because stage is BATTLE_END, not BATTLE_DICE_ROLL\n+    # Should fail because stage is STAGE_BATTLE_END, not STAGE_BATTLE_DICE_ROLL\n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n         action.run()\n \n \n def test_reroll_action_winner_not_determined():\n     \"\"\"Test reroll fails when there's a winner (ActivePlayer4/Opponent4 with winner=True)\"\"\"\n-    # Use battle_player_1_win preset but keep stage as BATTLE_DICE_ROLL\n-    game = get_debug_preset(\"battle_player_1_win\", stage=BATTLE_DICE_ROLL)\n+    # Use battle_player_1_win preset but keep stage as STAGE_BATTLE_DICE_ROLL\n+    game = get_debug_preset(\"battle_player_1_win\", stage=STAGE_BATTLE_DICE_ROLL)\n \n     # Verify state: player1 won (knight dice=[6] + attack=1 = 7 > mage dice=[3] = 3)\n     assert isinstance(game.active, ActivePlayer4)\n@@ -458,12 +458,12 @@ def test_calculate_winner_draw():\n \n \n def test_set_winner_if_both_rolled_upgrades_to_player4():\n-    \"\"\"Test set_winner_if_both_rolled upgrades both players to Player4/Opponent4 and transitions to BATTLE_END\"\"\"\n+    \"\"\"Test set_winner_if_both_rolled upgrades both players to Player4/Opponent4 and transitions to STAGE_BATTLE_END\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -479,17 +479,17 @@ def test_set_winner_if_both_rolled_upgrades_to_player4():\n     assert game.opponent.result.winner is False\n     assert game.active.result.score == 7\n     assert game.opponent.result.score == 3\n-    # Verify stage transitioned to BATTLE_END\n-    assert game.stage == BATTLE_END\n+    # Verify stage transitioned to STAGE_BATTLE_END\n+    assert game.stage == STAGE_BATTLE_END\n \n \n def test_set_winner_if_both_rolled_does_nothing_when_not_both_rolled():\n     \"\"\"Test set_winner_if_both_rolled does nothing when only one player rolled\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -512,9 +512,9 @@ def test_debug_set_battle_dice_rolls_valid():\n     \"\"\"Test debug action successfully sets dice rolls and recalculates winner\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -545,9 +545,9 @@ def test_debug_set_battle_dice_rolls_creates_draw():\n     \"\"\"Test debug action can create a draw scenario\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=ARCHER, dice_roll=[1]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_ARCHER, dice_roll=[1]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -573,7 +573,7 @@ def test_debug_set_battle_dice_rolls_wrong_stage():\n     \"\"\"Test debug action fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -589,9 +589,9 @@ def test_debug_set_battle_dice_rolls_active_not_rolled():\n     \"\"\"Test debug action fails when active player hasn't rolled yet\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -607,9 +607,9 @@ def test_debug_set_battle_dice_rolls_opponent_not_rolled():\n     \"\"\"Test debug action fails when opponent hasn't rolled yet\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -625,9 +625,9 @@ def test_debug_set_battle_dice_rolls_invalid_dice_count():\n     \"\"\"Test debug action fails when dice count doesn't match character dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -659,9 +659,9 @@ def test_reroll_effect_action():\n     # - Second RerollDiceEffect (to test all are removed)\n     # - AttackBonusEffect and SkipTurnEffect (to test other effects are preserved)\n     active_character = game.players[game.active.player].characters[game.active.character]\n-    active_character.effects.append(RerollDiceEffect(source=BOUNCING_ARROW))\n-    active_character.effects.append(AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2))\n-    active_character.effects.append(SkipTurnEffect(source=FREEZE))\n+    active_character.effects.append(RerollDiceEffect(source=ABILITY_BOUNCING_ARROW))\n+    active_character.effects.append(AttackBonusEffect(source=ABILITY_BATTLE_HOWL, attack_bonus=2))\n+    active_character.effects.append(SkipTurnEffect(source=ABILITY_FREEZE))\n \n     # Verify initial state: 4 effects total (1 original + 3 added)\n     assert len(active_character.effects) == 4\n@@ -671,12 +671,12 @@ def test_reroll_effect_action():\n \n     # Verify preset created game state as ActivePlayer4/Opponent4 (both rolled, winner calculated)\n     # Archer lost: dice=[2] = 2 < mage dice=[5] = 5\n-    # Stage stays BATTLE_DICE_ROLL because loser has reroll effect available\n+    # Stage stays STAGE_BATTLE_DICE_ROLL because loser has reroll effect available\n     assert isinstance(game.active, ActivePlayer4)\n     assert isinstance(game.opponent, Opponent4)\n     assert game.active.result.winner is False\n     assert game.opponent.result.winner is True\n-    assert game.stage == BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n \n     # Perform reroll using RerollEffectAction\n     action = RerollEffectAction(\"player1\", game)\ndiff --git a/server/gameplay/actions/test_stage_battle_end.py b/server/gameplay/actions/test_stage_battle_end.py\nindex 996f74f..53362bc 100644\n--- a/server/gameplay/actions/test_stage_battle_end.py\n+++ b/server/gameplay/actions/test_stage_battle_end.py\n@@ -16,12 +16,12 @@ from .battle_end import BattleEndAction\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_MAGE,\n+    CHARACTER_ARCHER,\n )\n-from ..abilities import BATTLE_HOWL, FREEZE, BOUNCING_ARROW\n-from ..gameplay import BATTLE_END, CHARACTER_SELECT\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_FREEZE, ABILITY_BOUNCING_ARROW\n+from ..gameplay import STAGE_BATTLE_END, STAGE_CHARACTER_SELECT\n from ..effects import AttackNegBonusEffect, SkipTurnEffect, RerollDiceEffect\n from ..gameplay import (\n     GamePlay,\n@@ -39,20 +39,20 @@ def test_battle_end_clears_battle_effects():\n     characters2 = init_characters()\n \n     # Add BattleEffect to both characters\n-    characters1[KNIGHT].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-2))\n-    characters2[MAGE].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-1))\n+    characters1[CHARACTER_KNIGHT].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-2))\n+    characters2[CHARACTER_MAGE].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-1))\n \n     game = GamePlay(\n-        stage=BATTLE_END,\n+        stage=STAGE_BATTLE_END,\n         active=ActivePlayer4(\n             player=\"player1\",\n-            character=KNIGHT,\n+            character=CHARACTER_KNIGHT,\n             dice_roll=[6],\n             result=BattleResult(winner=True, score=7)\n         ),\n         opponent=Opponent4(\n             player=\"player2\",\n-            character=MAGE,\n+            character=CHARACTER_MAGE,\n             dice_roll=[5],\n             result=BattleResult(winner=False, score=5)\n         ),\n@@ -63,19 +63,19 @@ def test_battle_end_clears_battle_effects():\n     )\n \n     # Verify effects exist before battle end\n-    assert len(game.players[\"player1\"].characters[KNIGHT].effects) == 1\n-    assert len(game.players[\"player2\"].characters[MAGE].effects) == 1\n+    assert len(game.players[\"player1\"].characters[CHARACTER_KNIGHT].effects) == 1\n+    assert len(game.players[\"player2\"].characters[CHARACTER_MAGE].effects) == 1\n \n     # Execute battle end action\n     action = BattleEndAction(\"player1\", game)\n     updated_game = action.run()\n \n     # Verify BattleEffects are cleared from both characters\n-    assert len(updated_game.players[\"player1\"].characters[KNIGHT].effects) == 0\n-    assert len(updated_game.players[\"player2\"].characters[MAGE].effects) == 0\n+    assert len(updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].effects) == 0\n+    assert len(updated_game.players[\"player2\"].characters[CHARACTER_MAGE].effects) == 0\n \n     # Verify game transitioned to next turn\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player2\"  # Next player's turn\n \n \n@@ -85,22 +85,22 @@ def test_battle_end_disposes_reroll_effect():\n     characters2 = init_characters()\n \n     # Add RerollDiceEffect to active player\n-    characters1[ARCHER].effects.append(RerollDiceEffect(source=BOUNCING_ARROW, reroll_dice=True))\n+    characters1[CHARACTER_ARCHER].effects.append(RerollDiceEffect(source=ABILITY_BOUNCING_ARROW, reroll_dice=True))\n \n     # Add BattleEffect to opponent\n-    characters2[KNIGHT].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-2))\n+    characters2[CHARACTER_KNIGHT].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-2))\n \n     game = GamePlay(\n-        stage=BATTLE_END,\n+        stage=STAGE_BATTLE_END,\n         active=ActivePlayer4(\n             player=\"player1\",\n-            character=ARCHER,\n+            character=CHARACTER_ARCHER,\n             dice_roll=[6],\n             result=BattleResult(winner=True, score=7)\n         ),\n         opponent=Opponent4(\n             player=\"player2\",\n-            character=KNIGHT,\n+            character=CHARACTER_KNIGHT,\n             dice_roll=[5],\n             result=BattleResult(winner=False, score=5)\n         ),\n@@ -111,18 +111,18 "
    },
    "preserveOutput": "always",
    "reporter": [
      [
        "html",
        {
          "open": "never"
        }
      ],
      [
        "json",
        {
          "outputFile": "playwright-report/results.json"
        }
      ],
      [
        "junit",
        {
          "outputFile": "playwright-report/results.xml"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "quiet": false,
    "projects": [
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/e76da431d025adeaf6fd4cec21407c6cd045b7a4",
            "commitHash": "e76da431d025adeaf6fd4cec21407c6cd045b7a4",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/34",
            "prTitle": "Standardize constant naming conventions across codebase",
            "prBaseHash": "7eea3362a32949bb1a86b804e9c27b37ea10d33d",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21262381021"
          },
          "gitCommit": {
            "shortHash": "e76da43",
            "hash": "e76da431d025adeaf6fd4cec21407c6cd045b7a4",
            "subject": "Merge 8f23547df5408e06ac408eb775db83b2985e6c65 into 7eea3362a32949bb1a86b804e9c27b37ea10d33d",
            "body": "Merge 8f23547df5408e06ac408eb775db83b2985e6c65 into 7eea3362a32949bb1a86b804e9c27b37ea10d33d\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1769110792000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1769110792000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nindex 423dea5..6b441b0 100644\n--- a/server/gameplay/abilities.py\n+++ b/server/gameplay/abilities.py\n@@ -7,11 +7,11 @@ from pydantic import Field\n from .common import StrictModel\n from .effects import (\n     # Effect name constants for EFFECTS_SOURCE_ABILITY_MAP\n-    ATTACK_BONUS,\n-    ATTACK_NEG_BONUS,\n-    REROLL_DICE,\n-    SKIP_TURN,\n-    DRAW_CARD,\n+    EFFECT_ATTACK_BONUS,\n+    EFFECT_ATTACK_NEG_BONUS,\n+    EFFECT_REROLL_DICE,\n+    EFFECT_SKIP_TURN,\n+    EFFECT_DRAW_CARD,\n     # Apply to constants\n     APPLY_TO_SELECTED_OPPONENT,\n )\n@@ -19,10 +19,10 @@ from .effects import (\n ########################################################\n # Ability names - defined before imports from effects to avoid circular dependency\n ########################################################\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+ABILITY_BATTLE_HOWL = \"battle_howl\"\n+ABILITY_BOUNCING_ARROW = \"bouncing_arrow\"\n+ABILITY_FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE]\n AbilityName = Literal[*ABILITIES_NAMES]\n \n ########################################################\n@@ -31,11 +31,11 @@ AbilityName = Literal[*ABILITIES_NAMES]\n # Defines which abilities can create which effects\n # This is used for validation to ensure effects have valid source abilities\n EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+    EFFECT_ATTACK_BONUS: {ABILITY_BATTLE_HOWL},  # AttackBonusEffect can come from ABILITY_BATTLE_HOWL\n+    EFFECT_ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    EFFECT_REROLL_DICE: {ABILITY_BOUNCING_ARROW},  # RerollDiceEffect can come from ABILITY_BOUNCING_ARROW\n+    EFFECT_SKIP_TURN: {ABILITY_FREEZE},  # SkipTurnEffect can come from ABILITY_FREEZE\n+    EFFECT_DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n }\n \n # Import Effect classes after defining constants to avoid circular import\n@@ -58,22 +58,22 @@ class Ability(StrictModel):\n \n \n ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n+    ABILITY_BATTLE_HOWL: Ability(\n+        name=ABILITY_BATTLE_HOWL,\n         effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+            AttackBonusEffect(source=ABILITY_BATTLE_HOWL, attack_bonus=2),\n         ],\n     ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n+    ABILITY_BOUNCING_ARROW: Ability(\n+        name=ABILITY_BOUNCING_ARROW,\n         effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n+            RerollDiceEffect(source=ABILITY_BOUNCING_ARROW),\n         ],\n     ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n+    ABILITY_FREEZE: Ability(\n+        name=ABILITY_FREEZE,\n         effects=[\n-            SkipTurnEffect(source=FREEZE),\n+            SkipTurnEffect(source=ABILITY_FREEZE),\n         ],\n     ),\n }\ndiff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 431c25d..f66df31 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -1,26 +1,26 @@\n from typing import Dict\n \n from ..common import (\n-    CONNECT,\n-    LEAVE,\n-    DISCONNECT,\n-    CHARACTER_PRESS,\n-    CHARACTER_SELECT_ACTION,\n-    CARD_DRAW_ACTION,\n-    CARD_SELECT_ACTION,\n-    ABILITY_PRESS,\n-    ABILITY_SELECT,\n-    ABILITY_OPPONENT_PRESS,\n-    ABILITY_OPPONENT_SELECT,\n-    OPPONENT_PRESS,\n-    OPPONENT_SELECT,\n-    ACTIVE_PLAYER_ROLL,\n-    OPPONENT_ROLL,\n+    ACTION_CONNECT,\n+    ACTION_LEAVE,\n+    ACTION_DISCONNECT,\n+    ACTION_CHARACTER_PRESS,\n+    ACTION_CHARACTER_SELECT,\n+    ACTION_CARD_DRAW,\n+    ACTION_CARD_SELECT,\n+    ACTION_ABILITY_PRESS,\n+    ACTION_ABILITY_SELECT,\n+    ACTION_ABILITY_OPPONENT_PRESS,\n+    ACTION_ABILITY_OPPONENT_SELECT,\n+    ACTION_OPPONENT_PRESS,\n+    ACTION_OPPONENT_SELECT,\n+    ACTION_ACTIVE_PLAYER_ROLL,\n+    ACTION_OPPONENT_ROLL,\n     ACTION_REROLL,\n     ACTION_REROLL_EFFECT,\n-    BATTLE_END_ACTION,\n-    DEBUG_SET_BATTLE_DICE_ROLLS,\n-    DEBUG_SET_DRAWN_CARD,\n+    ACTION_BATTLE_END,\n+    ACTION_DEBUG_SET_BATTLE_DICE_ROLLS,\n+    ACTION_DEBUG_SET_DRAWN_CARD,\n )  # Action constants stay in models.py\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n@@ -34,24 +34,24 @@ from .battle_end import BattleEndAction\n \n # Action mapping for dynamic action execution\n ACTION_MAP: Dict[str, type[Action]] = {\n-    CONNECT: ConnectAction,\n-    LEAVE: LeaveAction,\n-    DISCONNECT: DisconnectAction,\n-    CHARACTER_PRESS: CharacterPressAction,\n-    CHARACTER_SELECT_ACTION: CharacterSelectAction,\n-    CARD_DRAW_ACTION: CardDrawAction,\n-    CARD_SELECT_ACTION: CardSelectAction,\n-    ABILITY_PRESS: AbilityPressAction,\n-    ABILITY_SELECT: AbilitySelectAction,\n-    ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\n-    ABILITY_OPPONENT_SELECT: AbilityOpponentSelectAction,\n-    OPPONENT_PRESS: OpponentPressAction,\n-    OPPONENT_SELECT: OpponentSelectAction,\n-    ACTIVE_PLAYER_ROLL: ActivePlayerRollAction,\n-    OPPONENT_ROLL: OpponentRollAction,\n+    ACTION_CONNECT: ConnectAction,\n+    ACTION_LEAVE: LeaveAction,\n+    ACTION_DISCONNECT: DisconnectAction,\n+    ACTION_CHARACTER_PRESS: CharacterPressAction,\n+    ACTION_CHARACTER_SELECT: CharacterSelectAction,\n+    ACTION_CARD_DRAW: CardDrawAction,\n+    ACTION_CARD_SELECT: CardSelectAction,\n+    ACTION_ABILITY_PRESS: AbilityPressAction,\n+    ACTION_ABILITY_SELECT: AbilitySelectAction,\n+    ACTION_ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\n+    ACTION_ABILITY_OPPONENT_SELECT: AbilityOpponentSelectAction,\n+    ACTION_OPPONENT_PRESS: OpponentPressAction,\n+    ACTION_OPPONENT_SELECT: OpponentSelectAction,\n+    ACTION_ACTIVE_PLAYER_ROLL: ActivePlayerRollAction,\n+    ACTION_OPPONENT_ROLL: OpponentRollAction,\n     ACTION_REROLL: RerollAction,\n     ACTION_REROLL_EFFECT: RerollEffectAction,\n-    BATTLE_END_ACTION: BattleEndAction,\n-    DEBUG_SET_BATTLE_DICE_ROLLS: DebugSetBattleDiceRollsAction,\n-    DEBUG_SET_DRAWN_CARD: DebugSetDrawnCardAction,\n+    ACTION_BATTLE_END: BattleEndAction,\n+    ACTION_DEBUG_SET_BATTLE_DICE_ROLLS: DebugSetBattleDiceRollsAction,\n+    ACTION_DEBUG_SET_DRAWN_CARD: DebugSetDrawnCardAction,\n }\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex f9bc5a1..52705e1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -7,8 +7,8 @@ Ends the battle, calculates winner, and reduces loser's health by 1.\n from .action import Action\n from ..common import GameException, ReportedException\n from ..gameplay import (\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     ActivePlayer1,\n     ActivePlayer3,\n@@ -28,7 +28,7 @@ class BattleEndAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_END]\n+        return [STAGE_BATTLE_END]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -65,11 +65,11 @@ class BattleEndAction(Action):\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n-        from ..common import BATTLE_END_ACTION\n+        from ..common import ACTION_BATTLE_END\n \n         def should_keep_effect(effect):\n             \"\"\"Returns True if effect should be kept after battle\"\"\"\n-            return BATTLE_END_ACTION not in effect.dispose_actions\n+            return ACTION_BATTLE_END not in effect.dispose_actions\n \n         active_character.effects = [\n             effect for effect in active_character.effects\n@@ -91,7 +91,7 @@ class BattleEndAction(Action):\n         self.game.opponent = None\n         self.game.card = None\n         self.game.ability = None\n-        self.game.stage = CHARACTER_SELECT\n+        self.game.stage = STAGE_CHARACTER_SELECT\n         self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/connection.py b/server/gameplay/actions/connection.py\nindex d5e417e..d538498 100644\n--- a/server/gameplay/actions/connection.py\n+++ b/server/gameplay/actions/connection.py\n@@ -4,14 +4,14 @@ from .action import Action\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n-    CHARACTER_SELECT,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     Character,\n@@ -33,17 +33,17 @@ class ConnectAction(Action):\n                 raise ReportedException(\"Game is full\")\n \n             characters: Dict[str, Character] = {}\n-            for char_type in [KNIGHT, ARCHER, MAGE]:\n+            for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n                 characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n \n-            self.players[self.user] = Player(name=self.user, status=CONNECTED, characters=characters)\n+            self.players[self.user] = Player(name=self.user, status=STATUS_CONNECTED, characters=characters)\n \n         if self.game.active is None:\n             if self.game.stage is None:\n-                self.game.stage = CHARACTER_SELECT\n+                self.game.stage = STAGE_CHARACTER_SELECT\n             self.game.active = ActivePlayer1(player=self.user)\n \n-        self.player.status = CONNECTED\n+        self.player.status = STATUS_CONNECTED\n         return self.game\n \n \n@@ -66,5 +66,5 @@ class DisconnectAction(Action):\n         return None  # Can disconnect at any time\n \n     def _run(self) -> GamePlay:\n-        self.player.status = DISCONNECTED\n+        self.player.status = STATUS_DISCONNECTED\n         return self.game\ndiff --git a/server/gameplay/actions/stage_ability_opponent_selection.py b/server/gameplay/actions/stage_ability_opponent_selection.py\nindex 5985c08..0280458 100644\n--- a/server/gameplay/actions/stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/stage_ability_opponent_selection.py\n@@ -8,7 +8,7 @@ This module implements actions for the ability opponent selection stage:\n \n from .action import Action\n from ..common import GameException, ReportedException\n-from ..gameplay import ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION, GamePlay, Opponent2\n+from ..gameplay import STAGE_ABILITY_OPPONENT_SELECTION, STAGE_OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class AbilityOpponentPressAction(Action):\n@@ -21,7 +21,7 @@ class AbilityOpponentPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_OPPONENT_SELECTION]\n+        return [STAGE_ABILITY_OPPONENT_SELECTION]\n \n     def _run(self, opponent: str, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -67,7 +67,7 @@ class AbilityOpponentSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_OPPONENT_SELECTION]\n+        return [STAGE_ABILITY_OPPONENT_SELECTION]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -107,7 +107,7 @@ class AbilityOpponentSelectAction(Action):\n         self.game.ability_opponent = selected_opponent\n \n         # Transition to opponent selection stage\n-        self.game.stage = OPPONENT_SELECTION\n+        self.game.stage = STAGE_OPPONENT_SELECTION\n         self.game.stage_meta = None  # Clear stage metadata\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_ability_selection.py b/server/gameplay/actions/stage_ability_selection.py\nindex af35bf2..fe8c9c4 100644\n--- a/server/gameplay/actions/stage_ability_selection.py\n+++ b/server/gameplay/actions/stage_ability_selection.py\n@@ -12,7 +12,7 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_SELF\n from ..abilities import AbilityName\n-from ..gameplay import ABILITY_SELECTION, ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION\n+from ..gameplay import STAGE_ABILITY_SELECTION, STAGE_ABILITY_OPPONENT_SELECTION, STAGE_OPPONENT_SELECTION\n from ..gameplay import GamePlay, AbilitySelectMeta\n \n \n@@ -26,7 +26,7 @@ class AbilityPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_SELECTION]\n+        return [STAGE_ABILITY_SELECTION]\n \n     def _run(self, ability: AbilityName) -> GamePlay:\n         # Validate user is the active player\n@@ -66,7 +66,7 @@ class AbilitySelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_SELECTION]\n+        return [STAGE_ABILITY_SELECTION]\n \n     def _run(self, ability: AbilityName) -> GamePlay:\n         # Validate user is the active player\n@@ -108,8 +108,8 @@ class AbilitySelectAction(Action):\n \n         # Transition to ability_opponent_selection if ability requires it, otherwise skip to opponent_selection\n         if ability_obj.requires_opponent_selection:\n-            self.game.stage = ABILITY_OPPONENT_SELECTION\n+            self.game.stage = STAGE_ABILITY_OPPONENT_SELECTION\n         else:\n-            self.game.stage = OPPONENT_SELECTION\n+            self.game.stage = STAGE_OPPONENT_SELECTION\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_battle.py b/server/gameplay/actions/stage_battle.py\nindex a8fe573..846a62f 100644\n--- a/server/gameplay/actions/stage_battle.py\n+++ b/server/gameplay/actions/stage_battle.py\n@@ -13,9 +13,9 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import RerollDiceEffect\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -100,7 +100,7 @@ def set_winner_if_both_rolled(game: GamePlay) -> None:\n                 return\n \n         # No reroll available for loser, transition to BATTLE_END\n-        game.stage = BATTLE_END\n+        game.stage = STAGE_BATTLE_END\n \n \n class ActivePlayerRollAction(Action):\n@@ -112,7 +112,7 @@ class ActivePlayerRollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -159,7 +159,7 @@ class OpponentRollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate opponent exists\n@@ -246,7 +246,7 @@ class RerollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate it's a draw (no winner) - must be ActivePlayer4/Opponent4 with results\n@@ -274,7 +274,7 @@ class RerollEffectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -321,7 +321,7 @@ class DebugSetBattleDiceRollsAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL, BATTLE_END]\n+        return [STAGE_BATTLE_DICE_ROLL, STAGE_BATTLE_END]\n \n     def _run(self, active_dice_roll: list[int], opponent_dice_roll: list[int]) -> GamePlay:\n         # Validate both players have rolled (must be ActivePlayer3/4 and Opponent3/4)\ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nindex 5578205..116c91d 100644\n--- a/server/gameplay/actions/stage_card_draw.py\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -11,7 +11,7 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n from ..cards import CardName, CARDS_MAP\n-from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import STAGE_CARD_DRAW, STAGE_ABILITY_SELECTION\n from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n \n \n@@ -25,7 +25,7 @@ class CardDrawAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -55,7 +55,7 @@ class CardSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -106,7 +106,7 @@ class CardSelectAction(Action):\n         self.game.stage_meta = None\n \n         # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n+        self.game.stage = STAGE_ABILITY_SELECTION\n \n         # Auto-select if character has only one ability\n         if len(character.abilities) == 1:\n@@ -133,7 +133,7 @@ class DebugSetDrawnCardAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self, card_name: str) -> GamePlay:\n         # Validate card exists\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex cd8ba75..e79d53a 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -10,12 +10,12 @@ from .action import Action\n from ..common import (\n     GameException,\n     ReportedException,\n-    CHARACTER_SELECT_ACTION,\n+    ACTION_CHARACTER_SELECT,\n )\n from ..gameplay import (\n-    CARD_DRAW,\n-    ABILITY_SELECTION,\n-    CHARACTER_SELECT,\n+    STAGE_CARD_DRAW,\n+    STAGE_ABILITY_SELECTION,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n     CardDrawMeta,\n@@ -34,7 +34,7 @@ class CharacterPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CHARACTER_SELECT]\n+        return [STAGE_CHARACTER_SELECT]\n \n     def _run(self, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -70,7 +70,7 @@ class CharacterSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CHARACTER_SELECT]\n+        return [STAGE_CHARACTER_SELECT]\n \n     def _run(self, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -94,14 +94,14 @@ class CharacterSelectAction(Action):\n         for char in player.characters.values():\n             char.effects = [\n                 effect for effect in char.effects\n-                if CHARACTER_SELECT_ACTION not in effect.dispose_actions\n+                if ACTION_CHARACTER_SELECT not in effect.dispose_actions\n             ]\n \n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n         # Transition to card_draw stage\n-        self.game.stage = CARD_DRAW\n+        self.game.stage = STAGE_CARD_DRAW\n \n         # Clear stage_meta - will be populated by CardDrawAction\n         self.game.stage_meta = None\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex 0195959..5afe93d 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -10,7 +10,7 @@ import copy\n from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_BATTLE_OPPONENT\n-from ..gameplay import BATTLE_DICE_ROLL, OPPONENT_SELECTION, GamePlay, Opponent2\n+from ..gameplay import STAGE_BATTLE_DICE_ROLL, STAGE_OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class OpponentPressAction(Action):\n@@ -23,7 +23,7 @@ class OpponentPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [OPPONENT_SELECTION]\n+        return [STAGE_OPPONENT_SELECTION]\n \n     def _run(self, opponent: str, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -69,7 +69,7 @@ class OpponentSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [OPPONENT_SELECTION]\n+        return [STAGE_OPPONENT_SELECTION]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -120,7 +120,7 @@ class OpponentSelectAction(Action):\n                     opponent_character.effects.append(effect_copy)\n \n         # Transition to battle dice roll stage\n-        self.game.stage = BATTLE_DICE_ROLL\n+        self.game.stage = STAGE_BATTLE_DICE_ROLL\n         self.game.stage_meta = None  # Clear stage metadata\n \n         return self.game\ndiff --git a/server/gameplay/actions/test_action_properties.py b/server/gameplay/actions/test_action_properties.py\nindex 858c847..93833d2 100644\n--- a/server/gameplay/actions/test_action_properties.py\n+++ b/server/gameplay/actions/test_action_properties.py\n@@ -7,10 +7,10 @@ These tests verify that action properties work correctly across different game s\n import pytest\n \n from .action import Action\n-from ..common import GameException, KNIGHT, MAGE, ARCHER\n+from ..common import GameException, CHARACTER_KNIGHT, CHARACTER_MAGE, CHARACTER_ARCHER\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     ActivePlayer1,\n@@ -54,8 +54,8 @@ def test_active_character_with_active_player2():\n     \"\"\"Test active_character property with ActivePlayer2\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -73,8 +73,8 @@ def test_active_character_with_active_player3():\n     \"\"\"Test active_character property with ActivePlayer3\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -92,8 +92,8 @@ def test_active_character_with_active_player4():\n     \"\"\"Test active_character property with ActivePlayer4\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer4(player=\"player1\", character=ARCHER, dice_roll=[3], result=BattleResult(winner=True, score=3)),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer4(player=\"player1\", character=CHARACTER_ARCHER, dice_roll=[3], result=BattleResult(winner=True, score=3)),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -111,7 +111,7 @@ def test_active_character_with_active_player1_fails():\n     \"\"\"Test active_character property fails with ActivePlayer1 (no character selected)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -127,7 +127,7 @@ def test_active_character_with_no_active_fails():\n     \"\"\"Test active_character property fails when no active player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -148,9 +148,9 @@ def test_opponent_character_with_opponent2():\n     \"\"\"Test opponent_character property with Opponent2\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -169,9 +169,9 @@ def test_opponent_character_with_opponent3():\n     \"\"\"Test opponent_character property with Opponent3\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent3(player=\"player2\", character=ARCHER, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_ARCHER, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -190,9 +190,9 @@ def test_opponent_character_with_opponent4():\n     \"\"\"Test opponent_character property with Opponent4\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer4(player=\"player1\", character=KNIGHT, dice_roll=[6], result=BattleResult(winner=True, score=7)),\n-        opponent=Opponent4(player=\"player2\", character=MAGE, dice_roll=[1], result=BattleResult(winner=False, score=1)),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer4(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6], result=BattleResult(winner=True, score=7)),\n+        opponent=Opponent4(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[1], result=BattleResult(winner=False, score=1)),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -211,8 +211,8 @@ def test_opponent_character_with_no_opponent_fails():\n     \"\"\"Test opponent_character property fails when no opponent\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -233,7 +233,7 @@ def test_player_property():\n     \"\"\"Test player property returns correct player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -245,16 +245,16 @@ def test_player_property():\n     player = action.player\n \n     assert player.name == \"player1\"\n-    assert KNIGHT in player.characters\n-    assert player.characters[KNIGHT].health == KNIGHT_L1_DEFAULT_HEALTH\n-    assert player.characters[KNIGHT].attack == KNIGHT_L1_ATTACK\n+    assert CHARACTER_KNIGHT in player.characters\n+    assert player.characters[CHARACTER_KNIGHT].health == KNIGHT_L1_DEFAULT_HEALTH\n+    assert player.characters[CHARACTER_KNIGHT].attack == KNIGHT_L1_ATTACK\n \n \n def test_player_property_player_not_in_game_fails():\n     \"\"\"Test player property fails when player not in game\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -275,7 +275,7 @@ def test_stage_property_get():\n     \"\"\"Test stage property getter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n+        stage=STAGE_BATTLE_DICE_ROLL,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -283,14 +283,14 @@ def test_stage_property_get():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    assert action.stage == BATTLE_DICE_ROLL\n+    assert action.stage == STAGE_BATTLE_DICE_ROLL\n \n \n def test_stage_property_set():\n     \"\"\"Test stage property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -298,9 +298,9 @@ def test_stage_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    action.stage = BATTLE_DICE_ROLL\n-    assert action.stage == BATTLE_DICE_ROLL\n-    assert game.stage == BATTLE_DICE_ROLL\n+    action.stage = STAGE_BATTLE_DICE_ROLL\n+    assert action.stage == STAGE_BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n \n \n # ============================================================================\n@@ -311,9 +311,9 @@ def test_stage_property_set():\n def test_active_property_get():\n     \"\"\"Test active property getter\"\"\"\n     characters = init_characters()\n-    active_player = ActivePlayer2(player=\"player1\", character=KNIGHT)\n+    active_player = ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT)\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=active_player,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -323,14 +323,14 @@ def test_active_property_get():\n     action = ConcreteAction(\"player1\", game)\n     assert action.active == active_player\n     assert action.active.player == \"player1\"\n-    assert action.active.character == KNIGHT\n+    assert action.active.character == CHARACTER_KNIGHT\n \n \n def test_active_property_set():\n     \"\"\"Test active property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -338,7 +338,7 @@ def test_active_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    new_active = ActivePlayer2(player=\"player1\", character=MAGE)\n+    new_active = ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE)\n     action.active = new_active\n \n     assert action.active == new_active\n@@ -348,10 +348,10 @@ def test_active_property_set():\n def test_opponent_property_get():\n     \"\"\"Test opponent property getter\"\"\"\n     characters = init_characters()\n-    opponent = Opponent2(player=\"player2\", character=ARCHER)\n+    opponent = Opponent2(player=\"player2\", character=CHARACTER_ARCHER)\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=opponent,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -362,15 +362,15 @@ def test_opponent_property_get():\n     action = ConcreteAction(\"player1\", game)\n     assert action.opponent == opponent\n     assert action.opponent.player == \"player2\"\n-    assert action.opponent.character == ARCHER\n+    assert action.opponent.character == CHARACTER_ARCHER\n \n \n def test_opponent_property_set():\n     \"\"\"Test opponent property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -379,7 +379,7 @@ def test_opponent_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    new_opponent = Opponent2(player=\"player2\", character=MAGE)\n+    new_opponent = Opponent2(player=\"player2\", character=CHARACTER_MAGE)\n     action.opponent = new_opponent\n \n     assert action.opponent == new_opponent\ndiff --git a/server/gameplay/actions/test_connect_action.py b/server/gameplay/actions/test_connect_action.py\nindex 3e2564d..30dfb73 100644\n--- a/server/gameplay/actions/test_connect_action.py\n+++ b/server/gameplay/actions/test_connect_action.py\n@@ -10,14 +10,14 @@ import pytest\n from .connection import ConnectAction, MAX_PLAYERS\n from ..common import (\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n-    CHARACTER_SELECT,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     Character,\n@@ -37,31 +37,31 @@ def test_connect_action_new_player():\n \n     assert \"player1\" in updated_game.players\n     assert updated_game.players[\"player1\"].name == \"player1\"\n-    assert updated_game.players[\"player1\"].status == CONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n     assert len(updated_game.players[\"player1\"].characters) == 3\n-    assert KNIGHT in updated_game.players[\"player1\"].characters\n-    assert ARCHER in updated_game.players[\"player1\"].characters\n-    assert MAGE in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_KNIGHT in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_ARCHER in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_MAGE in updated_game.players[\"player1\"].characters\n     # Verify each character has empty cards list\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].cards == []\n-    assert updated_game.players[\"player1\"].characters[ARCHER].cards == []\n-    assert updated_game.players[\"player1\"].characters[MAGE].cards == []\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].cards == []\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_ARCHER].cards == []\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_MAGE].cards == []\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n \n def test_connect_action_existing_player_reconnect():\n     \"\"\"Test reconnecting an existing player who was disconnected\"\"\"\n     game = GamePlay()\n-    knight_char = Character(level=2, **CHARACTER_DEFAULT_STATS[KNIGHT])\n+    knight_char = Character(level=2, **CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT])\n     knight_char.cards = [\"talisman\"]  # Knight has a card\n     game.players[\"player1\"] = Player(\n         name=\"player1\",\n-        status=DISCONNECTED,\n+        status=STATUS_DISCONNECTED,\n         characters={\n             KNIGHT: knight_char,\n-            ARCHER: Character(level=1, **CHARACTER_DEFAULT_STATS[ARCHER]),\n-            MAGE: Character(level=1, **CHARACTER_DEFAULT_STATS[MAGE]),\n+            ARCHER: Character(level=1, **CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER]),\n+            MAGE: Character(level=1, **CHARACTER_DEFAULT_STATS[CHARACTER_MAGE]),\n         },\n     )\n \n@@ -69,9 +69,9 @@ def test_connect_action_existing_player_reconnect():\n     updated_game = action.run()\n \n     # Player should be reconnected with their existing data\n-    assert updated_game.players[\"player1\"].status == CONNECTED\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].cards == [\"talisman\"]\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].level == 2\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].cards == [\"talisman\"]\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].level == 2\n \n \n def test_connect_action_game_full():\n@@ -82,7 +82,7 @@ def test_connect_action_game_full():\n     for i in range(MAX_PLAYERS):\n         player_name = f\"player{i+1}\"\n         characters = {}\n-        for char_type in [KNIGHT, ARCHER, MAGE]:\n+        for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n             characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n         game.players[player_name] = Player(name=player_name, characters=characters)\n \n@@ -95,10 +95,10 @@ def test_connect_action_game_full():\n def test_connect_action_second_player():\n     \"\"\"Test connecting a second player to a game with one player\"\"\"\n     game = GamePlay()\n-    game.stage = CHARACTER_SELECT\n+    game.stage = STAGE_CHARACTER_SELECT\n     game.active = ActivePlayer1(player=\"player1\")\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n \n@@ -106,8 +106,8 @@ def test_connect_action_second_player():\n     updated_game = action.run()\n \n     assert \"player2\" in updated_game.players\n-    assert updated_game.players[\"player2\"].status == CONNECTED\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player2\"].status == STATUS_CONNECTED\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"  # Active player should not change\n \n \n@@ -119,7 +119,7 @@ def test_connect_action_stage_none():\n \n     updated_game = action.run()\n \n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n \n@@ -133,25 +133,25 @@ def test_connect_action_character_stats():\n     player = updated_game.players[\"player1\"]\n \n     # Check knight stats\n-    knight = player.characters[KNIGHT]\n+    knight = player.characters[CHARACTER_KNIGHT]\n     assert knight.level == 1\n-    assert knight.health == CHARACTER_DEFAULT_STATS[KNIGHT][\"health\"]\n-    assert knight.max_health == CHARACTER_DEFAULT_STATS[KNIGHT][\"max_health\"]\n-    assert knight.dice == CHARACTER_DEFAULT_STATS[KNIGHT][\"dice\"]\n-    assert knight.attack == CHARACTER_DEFAULT_STATS[KNIGHT][\"attack\"]\n+    assert knight.health == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"health\"]\n+    assert knight.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"max_health\"]\n+    assert knight.dice == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"dice\"]\n+    assert knight.attack == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"attack\"]\n \n     # Check archer stats (no attack bonus)\n-    archer = player.characters[ARCHER]\n+    archer = player.characters[CHARACTER_ARCHER]\n     assert archer.level == 1\n-    assert archer.health == CHARACTER_DEFAULT_STATS[ARCHER][\"health\"]\n-    assert archer.max_health == CHARACTER_DEFAULT_STATS[ARCHER][\"max_health\"]\n-    assert archer.dice == CHARACTER_DEFAULT_STATS[ARCHER][\"dice\"]\n+    assert archer.health == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"health\"]\n+    assert archer.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"max_health\"]\n+    assert archer.dice == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"dice\"]\n     assert archer.attack == ARCHER_L1_ATTACK\n \n     # Check mage stats (no attack bonus)\n-    mage = player.characters[MAGE]\n+    mage = player.characters[CHARACTER_MAGE]\n     assert mage.level == 1\n-    assert mage.health == CHARACTER_DEFAULT_STATS[MAGE][\"health\"]\n-    assert mage.max_health == CHARACTER_DEFAULT_STATS[MAGE][\"max_health\"]\n-    assert mage.dice == CHARACTER_DEFAULT_STATS[MAGE][\"dice\"]\n+    assert mage.health == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"health\"]\n+    assert mage.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"max_health\"]\n+    assert mage.dice == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"dice\"]\n     assert mage.attack == MAGE_L1_ATTACK\ndiff --git a/server/gameplay/actions/test_connection_integration.py b/server/gameplay/actions/test_connection_integration.py\nindex e63bdab..fed9856 100644\n--- a/server/gameplay/actions/test_connection_integration.py\n+++ b/server/gameplay/actions/test_connection_integration.py\n@@ -9,8 +9,8 @@ and leaving actions.\n import pytest\n \n from .connection import ConnectAction, DisconnectAction, LeaveAction\n-from ..common import CONNECTED, DISCONNECTED\n-from ..gameplay import CHARACTER_SELECT, GamePlay\n+from ..common import STATUS_CONNECTED, STATUS_DISCONNECTED\n+from ..gameplay import STAGE_CHARACTER_SELECT, GamePlay\n \n \n def test_connect_then_disconnect_then_reconnect():\n@@ -21,21 +21,21 @@ def test_connect_then_disconnect_then_reconnect():\n     connect_action = ConnectAction(\"player1\", game)\n     updated_game = connect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == CONNECTED\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n     # Disconnect\n     disconnect_action = DisconnectAction(\"player1\", updated_game)\n     updated_game = disconnect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\n \n     # Reconnect\n     reconnect_action = ConnectAction(\"player1\", updated_game)\n     updated_game = reconnect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == CONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n \n \n def test_multiple_players_connect_disconnect_leave():\n@@ -55,7 +55,7 @@ def test_multiple_players_connect_disconnect_leave():\n     disconnect_action = DisconnectAction(\"player2\", game)\n     game = disconnect_action.run()\n \n-    assert game.players[\"player2\"].status == DISCONNECTED\n+    assert game.players[\"player2\"].status == STATUS_DISCONNECTED\n     assert len(game.players) == 3  # Still in game\n \n     # Player3 leaves\n@@ -69,5 +69,5 @@ def test_multiple_players_connect_disconnect_leave():\n     reconnect_action = ConnectAction(\"player2\", game)\n     game = reconnect_action.run()\n \n-    assert game.players[\"player2\"].status == CONNECTED\n+    assert game.players[\"player2\"].status == STATUS_CONNECTED\n     assert len(game.players) == 2\ndiff --git a/server/gameplay/actions/test_disconnect_action.py b/server/gameplay/actions/test_disconnect_action.py\nindex 2337f53..c9fdb35 100644\n--- a/server/gameplay/actions/test_disconnect_action.py\n+++ b/server/gameplay/actions/test_disconnect_action.py\n@@ -10,11 +10,11 @@ import pytest\n from .connection import DisconnectAction\n from ..common import (\n     GameException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n     GamePlay,\n@@ -28,14 +28,14 @@ def test_disconnect_action_existing_player():\n     \"\"\"Test disconnecting an existing connected player\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n-    game.players[\"player1\"] = Player(name=\"player1\", status=CONNECTED, characters=characters)\n+    game.players[\"player1\"] = Player(name=\"player1\", status=STATUS_CONNECTED, characters=characters)\n \n     action = DisconnectAction(\"player1\", game)\n     updated_game = action.run()\n \n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\n     assert updated_game.players[\"player1\"].name == \"player1\"  # Other data preserved\n \n \n@@ -52,12 +52,12 @@ def test_disconnect_action_already_disconnected():\n     \"\"\"Test disconnecting a player who is already disconnected\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n-    game.players[\"player1\"] = Player(name=\"player1\", status=DISCONNECTED, characters=characters)\n+    game.players[\"player1\"] = Player(name=\"player1\", status=STATUS_DISCONNECTED, characters=characters)\n \n     action = DisconnectAction(\"player1\", game)\n     updated_game = action.run()\n \n     # Should still work and status remains disconnected\n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\ndiff --git a/server/gameplay/actions/test_leave_action.py b/server/gameplay/actions/test_leave_action.py\nindex e67ef2e..7b43472 100644\n--- a/server/gameplay/actions/test_leave_action.py\n+++ b/server/gameplay/actions/test_leave_action.py\n@@ -9,7 +9,7 @@ the only player leaving.\n import pytest\n \n from .connection import LeaveAction\n-from ..common import GameException, KNIGHT, ARCHER, MAGE\n+from ..common import GameException, CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE\n from ..gameplay import (\n     GamePlay,\n     Player,\n@@ -22,7 +22,7 @@ def test_leave_action_existing_player():\n     \"\"\"Test a player leaving the game\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n     game.players[\"player2\"] = Player(name=\"player2\", characters=characters)\n@@ -47,7 +47,7 @@ def test_leave_action_only_player():\n     \"\"\"Test the only player in the game leaving\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n \ndiff --git a/server/gameplay/actions/test_stage_ability_opponent_selection.py b/server/gameplay/actions/test_stage_ability_opponent_selection.py\nindex 75dfb7d..1f4618f 100644\n--- a/server/gameplay/actions/test_stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_opponent_selection.py\n@@ -8,11 +8,11 @@ selected opponents for ability targeting and confirming selections to apply effe\n import pytest\n \n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n-from ..common import GameException, ReportedException, KNIGHT, MAGE\n-from ..abilities import BATTLE_HOWL, FREEZE, ABILITIES_MAP\n+from ..common import GameException, ReportedException, CHARACTER_KNIGHT, CHARACTER_MAGE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_FREEZE, ABILITIES_MAP\n from ..gameplay import (\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n+    STAGE_ABILITY_OPPONENT_SELECTION,\n+    STAGE_OPPONENT_SELECTION,\n     GamePlay,\n     Player,\n     ActivePlayer2,\n@@ -25,9 +25,9 @@ def test_ability_opponent_press_action_valid():\n     \"\"\"Test pressing opponent's character highlights it in stage_meta\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -35,22 +35,22 @@ def test_ability_opponent_press_action_valid():\n     )\n \n     action = AbilityOpponentPressAction(\"player1\", game)\n-    updated_game = action.run(opponent=\"player2\", character=KNIGHT)\n+    updated_game = action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n     assert updated_game.stage_meta is not None\n     assert isinstance(updated_game.stage_meta, Opponent2)\n     assert updated_game.stage_meta.player == \"player2\"\n-    assert updated_game.stage_meta.character == KNIGHT\n-    assert updated_game.stage == ABILITY_OPPONENT_SELECTION  # Still in ability opponent selection\n+    assert updated_game.stage_meta.character == CHARACTER_KNIGHT\n+    assert updated_game.stage == STAGE_ABILITY_OPPONENT_SELECTION  # Still in ability opponent selection\n \n \n def test_ability_opponent_press_action_not_active_player():\n     \"\"\"Test pressing opponent when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -60,16 +60,16 @@ def test_ability_opponent_press_action_not_active_player():\n     action = AbilityOpponentPressAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(opponent=\"player1\", character=KNIGHT)\n+        action.run(opponent=\"player1\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_wrong_stage():\n     \"\"\"Test pressing opponent in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -79,32 +79,32 @@ def test_ability_opponent_press_action_wrong_stage():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(opponent=\"player2\", character=KNIGHT)\n+        action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_invalid_opponent():\n     \"\"\"Test pressing non-existent opponent raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"not in game\"):\n-        action.run(opponent=\"nonexistent\", character=KNIGHT)\n+        action.run(opponent=\"nonexistent\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_self_as_opponent():\n     \"\"\"Test pressing self as opponent raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -114,18 +114,18 @@ def test_ability_opponent_press_action_self_as_opponent():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"Cannot select yourself as opponent\"):\n-        action.run(opponent=\"player1\", character=KNIGHT)\n+        action.run(opponent=\"player1\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_dead_character():\n     \"\"\"Test pressing dead character raises error\"\"\"\n     characters = init_characters()\n     # Kill the knight\n-    characters[KNIGHT].health = 0\n+    characters[CHARACTER_KNIGHT].health = 0\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n-        ability=ABILITIES_MAP[FREEZE],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n+        ability=ABILITIES_MAP[ABILITY_FREEZE],\n         players={\n             \"player1\": Player(name=\"player1\", characters=init_characters()),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -135,7 +135,7 @@ def test_ability_opponent_press_action_dead_character():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"is dead and can't be targeted\"):\n-        action.run(opponent=\"player2\", character=KNIGHT)\n+        action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_select_action_valid():\n@@ -143,10 +143,10 @@ def test_ability_opponent_select_action_valid():\n     characters1 = init_characters()\n     characters2 = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters1),\n             \"player2\": Player(name=\"player2\", characters=characters2),\n@@ -157,28 +157,28 @@ def test_ability_opponent_select_action_valid():\n     updated_game = action.run()\n \n     # Check stage transition\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.stage_meta is None\n \n     # Check ability_opponent is set\n     assert updated_game.ability_opponent is not None\n     assert updated_game.ability_opponent.player == \"player2\"\n-    assert updated_game.ability_opponent.character == KNIGHT\n+    assert updated_game.ability_opponent.character == CHARACTER_KNIGHT\n \n     # Check effects were applied to target character\n-    target_character = updated_game.players[\"player2\"].characters[KNIGHT]\n+    target_character = updated_game.players[\"player2\"].characters[CHARACTER_KNIGHT]\n     assert len(target_character.effects) > 0\n-    assert target_character.effects[0].source == BATTLE_HOWL\n+    assert target_character.effects[0].source == ABILITY_BATTLE_HOWL\n \n \n def test_ability_opponent_select_action_not_active_player():\n     \"\"\"Test confirming ability opponent selection when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -195,10 +195,10 @@ def test_ability_opponent_select_action_wrong_stage():\n     \"\"\"Test confirming ability opponent selection in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -215,9 +215,9 @@ def test_ability_opponent_select_action_no_target_selected():\n     \"\"\"Test confirming ability opponent selection without selecting target raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -235,13 +235,13 @@ def test_ability_opponent_select_action_dead_character():\n     characters1 = init_characters()\n     characters2 = init_characters()\n     # Kill the target knight\n-    characters2[KNIGHT].health = 0\n+    characters2[CHARACTER_KNIGHT].health = 0\n \n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n-        ability=ABILITIES_MAP[FREEZE],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n+        ability=ABILITIES_MAP[ABILITY_FREEZE],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters1),\n             \"player2\": Player(name=\"player2\", characters=characters2),\ndiff --git a/server/gameplay/actions/test_stage_ability_selection.py b/server/gameplay/actions/test_stage_ability_selection.py\nindex b3c0106..60c2eb1 100644\n--- a/server/gameplay/actions/test_stage_ability_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_selection.py\n@@ -3,8 +3,8 @@ Tests for Ability Selection Stage Actions.\n \n These tests verify ability selection behavior including highlighting\n selected abilities and confirming selections to transition to:\n-- ability_opponent_selection (for effects requiring target selection, e.g., FREEZE)\n-- opponent_selection (for effects applied to battle opponent, e.g., BATTLE_HOWL, BOUNCING_ARROW)\n+- ability_opponent_selection (for effects requiring target selection, e.g., ABILITY_FREEZE)\n+- opponent_selection (for effects applied to battle opponent, e.g., ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW)\n \"\"\"\n \n import pytest\n@@ -13,17 +13,17 @@ from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n )\n from ..effects import REROLL_DICE\n-from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE\n from ..gameplay import (\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    CHARACTER_SELECT,\n+    STAGE_ABILITY_SELECTION,\n+    STAGE_ABILITY_OPPONENT_SELECTION,\n+    STAGE_OPPONENT_SELECTION,\n+    STAGE_CHARACTER_SELECT,\n )\n from ..effects import RerollDiceEffect\n from ..gameplay import (\n@@ -38,25 +38,25 @@ def test_ability_press_action_valid():\n     \"\"\"Test pressing an ability highlights it in stage_meta\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=BATTLE_HOWL)\n+    updated_game = action.run(ability=ABILITY_BATTLE_HOWL)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == BATTLE_HOWL\n-    assert updated_game.stage == ABILITY_SELECTION  # Still in ability selection\n+    assert updated_game.stage_meta.selected == ABILITY_BATTLE_HOWL\n+    assert updated_game.stage == STAGE_ABILITY_SELECTION  # Still in ability selection\n \n \n def test_ability_press_action_not_active_player():\n     \"\"\"Test pressing ability when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -66,88 +66,88 @@ def test_ability_press_action_not_active_player():\n     action = AbilityPressAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_press_action_wrong_stage():\n     \"\"\"Test pressing ability in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_press_action_invalid_ability():\n     \"\"\"Test pressing ability not available for character raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n \n-    # Knight should have BATTLE_HOWL, not FREEZE (which is for mage)\n+    # Knight should have ABILITY_BATTLE_HOWL, not ABILITY_FREEZE (which is for mage)\n     with pytest.raises(ReportedException, match=\"not available for this character\"):\n-        action.run(ability=FREEZE)\n+        action.run(ability=ABILITY_FREEZE)\n \n \n def test_ability_press_action_archer():\n-    \"\"\"Test pressing archer's ability (BOUNCING_ARROW) works correctly\"\"\"\n+    \"\"\"Test pressing archer's ability (ABILITY_BOUNCING_ARROW) works correctly\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == BOUNCING_ARROW\n+    assert updated_game.stage_meta.selected == ABILITY_BOUNCING_ARROW\n \n \n def test_ability_press_action_mage():\n-    \"\"\"Test pressing mage's ability (FREEZE) works correctly\"\"\"\n+    \"\"\"Test pressing mage's ability (ABILITY_FREEZE) works correctly\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=FREEZE)\n+    updated_game = action.run(ability=ABILITY_FREEZE)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == FREEZE\n+    assert updated_game.stage_meta.selected == ABILITY_FREEZE\n \n \n def test_ability_select_action_valid():\n     \"\"\"Test confirming ability selection transitions to opponent_selection (for battle opponent effects)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BATTLE_HOWL)\n+    updated_game = action.run(ability=ABILITY_BATTLE_HOWL)\n \n-    # BATTLE_HOWL applies to battle opponent, so skip ability_opponent_selection\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    # ABILITY_BATTLE_HOWL applies to battle opponent, so skip ability_opponent_selection\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == BATTLE_HOWL\n+    assert updated_game.ability.name == ABILITY_BATTLE_HOWL\n     assert updated_game.stage_meta is None\n \n \n@@ -155,8 +155,8 @@ def test_ability_select_action_not_active_player():\n     \"\"\"Test confirming ability selection when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -166,76 +166,76 @@ def test_ability_select_action_not_active_player():\n     action = AbilitySelectAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_select_action_wrong_stage():\n     \"\"\"Test confirming ability selection in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_select_action_invalid_ability():\n     \"\"\"Test confirming ability not available for character raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n \n-    # Knight should have BATTLE_HOWL, not BOUNCING_ARROW (which is for archer)\n+    # Knight should have ABILITY_BATTLE_HOWL, not ABILITY_BOUNCING_ARROW (which is for archer)\n     with pytest.raises(ReportedException, match=\"not available for this character\"):\n-        action.run(ability=BOUNCING_ARROW)\n+        action.run(ability=ABILITY_BOUNCING_ARROW)\n \n \n def test_ability_select_action_archer():\n     \"\"\"Test confirming archer's ability selection skips to opponent_selection\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n-    # BOUNCING_ARROW applies to self, so skip ability_opponent_selection\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    # ABILITY_BOUNCING_ARROW applies to self, so skip ability_opponent_selection\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == BOUNCING_ARROW\n+    assert updated_game.ability.name == ABILITY_BOUNCING_ARROW\n     assert updated_game.stage_meta is None\n \n \n def test_ability_select_action_archer_applies_reroll_effect():\n-    \"\"\"Test confirming BOUNCING_ARROW applies RerollDiceEffect to active player's character\"\"\"\n+    \"\"\"Test confirming ABILITY_BOUNCING_ARROW applies RerollDiceEffect to active player's character\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     # Verify archer has no effects before\n-    assert len(game.players[\"player1\"].characters[ARCHER].effects) == 0\n+    assert len(game.players[\"player1\"].characters[CHARACTER_ARCHER].effects) == 0\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n     # Verify RerollDiceEffect was applied to the active player's archer\n-    archer = updated_game.players[\"player1\"].characters[ARCHER]\n+    archer = updated_game.players[\"player1\"].characters[CHARACTER_ARCHER]\n     assert len(archer.effects) == 1\n     assert isinstance(archer.effects[0], RerollDiceEffect)\n     assert archer.effects[0].name == REROLL_DICE\n@@ -247,16 +247,16 @@ def test_ability_select_action_mage():\n     \"\"\"Test confirming mage's ability selection transitions to ability_opponent_selection\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=FREEZE)\n+    updated_game = action.run(ability=ABILITY_FREEZE)\n \n-    # FREEZE requires opponent selection (SkipTurnEffect), so go to ability_opponent_selection\n-    assert updated_game.stage == ABILITY_OPPONENT_SELECTION\n+    # ABILITY_FREEZE requires opponent selection (SkipTurnEffect), so go to ability_opponent_selection\n+    assert updated_game.stage == STAGE_ABILITY_STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == FREEZE\n+    assert updated_game.ability.name == ABILITY_FREEZE\n     assert updated_game.stage_meta is None\ndiff --git a/server/gameplay/actions/test_stage_battle_dice_roll.py b/server/gameplay/actions/test_stage_battle_dice_roll.py\nindex bbc80fd..80e63ff 100644\n--- a/server/gameplay/actions/test_stage_battle_dice_roll.py\n+++ b/server/gameplay/actions/test_stage_battle_dice_roll.py\n@@ -19,11 +19,11 @@ from .stage_battle import (\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n )\n-from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE\n from ..effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n@@ -31,10 +31,10 @@ from ..effects import (\n     RerollDiceEffect,\n )\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n-    OPPONENT_SELECTION,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n+    STAGE_OPPONENT_SELECTION,\n )\n from ..gameplay import (\n     GamePlay,\n@@ -60,9 +60,9 @@ def test_active_player_roll_action_valid():\n     \"\"\"Test active player successfully rolls dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -75,9 +75,9 @@ def test_active_player_roll_action_valid():\n     # Verify active player upgraded to ActivePlayer3 with dice_roll\n     assert isinstance(updated_game.active, ActivePlayer3)\n     assert updated_game.active.player == \"player1\"\n-    assert updated_game.active.character == KNIGHT\n+    assert updated_game.active.character == CHARACTER_KNIGHT\n     assert updated_game.active.dice_roll is not None\n-    assert len(updated_game.active.dice_roll) == characters[KNIGHT].dice\n+    assert len(updated_game.active.dice_roll) == characters[CHARACTER_KNIGHT].dice\n     assert all(1 <= d <= 6 for d in updated_game.active.dice_roll)\n \n     # Opponent should still be Opponent2 (hasn't rolled yet)\n@@ -88,9 +88,9 @@ def test_active_player_roll_triggers_winner_calculation():\n     \"\"\"Test that when active player rolls and opponent already rolled, winner is calculated\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -109,7 +109,7 @@ def test_active_player_roll_wrong_stage():\n     \"\"\"Test active player roll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -126,9 +126,9 @@ def test_active_player_roll_not_active_player():\n     \"\"\"Test active player roll fails when user is not the active player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -145,9 +145,9 @@ def test_active_player_roll_player_not_in_game():\n     \"\"\"Test active player roll fails when player doesn't exist in game\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player2\": Player(name=\"player2\", characters=characters),\n         },\n@@ -163,7 +163,7 @@ def test_active_player_roll_no_character():\n     \"\"\"Test active player roll fails when no character selected\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n+        stage=STAGE_BATTLE_DICE_ROLL,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -185,9 +185,9 @@ def test_opponent_roll_action_valid():\n     \"\"\"Test opponent successfully rolls dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -200,9 +200,9 @@ def test_opponent_roll_action_valid():\n     # Verify opponent upgraded to Opponent3 with dice_roll\n     assert isinstance(updated_game.opponent, Opponent3)\n     assert updated_game.opponent.player == \"player2\"\n-    assert updated_game.opponent.character == MAGE\n+    assert updated_game.opponent.character == CHARACTER_MAGE\n     assert updated_game.opponent.dice_roll is not None\n-    assert len(updated_game.opponent.dice_roll) == characters[MAGE].dice\n+    assert len(updated_game.opponent.dice_roll) == characters[CHARACTER_MAGE].dice\n     assert all(1 <= d <= 6 for d in updated_game.opponent.dice_roll)\n \n     # Active player should still be ActivePlayer2 (hasn't rolled yet)\n@@ -213,9 +213,9 @@ def test_opponent_roll_triggers_winner_calculation():\n     \"\"\"Test that when opponent rolls and active already rolled, winner is calculated\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -234,7 +234,7 @@ def test_opponent_roll_wrong_stage():\n     \"\"\"Test opponent roll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -252,9 +252,9 @@ def test_opponent_roll_not_opponent():\n     \"\"\"Test opponent roll fails when user is not the opponent\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -271,8 +271,8 @@ def test_opponent_roll_no_opponent():\n     \"\"\"Test opponent roll fails when no opponent exists\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -298,7 +298,7 @@ def test_reroll_action_valid_draw():\n     game = get_debug_preset(\"battle_draw\")\n \n     # Verify initial state is a draw\n-    assert game.stage == BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n     assert isinstance(game.active, ActivePlayer4)\n     assert isinstance(game.opponent, Opponent4)\n     assert game.active.result.winner is False\n@@ -311,16 +311,16 @@ def test_reroll_action_valid_draw():\n     assert isinstance(updated_game.active, ActivePlayer2)\n     assert isinstance(updated_game.opponent, Opponent2)\n     assert updated_game.active.player == \"player1\"\n-    assert updated_game.active.character == KNIGHT\n+    assert updated_game.active.character == CHARACTER_KNIGHT\n     assert updated_game.opponent.player == \"player2\"\n-    assert updated_game.opponent.character == ARCHER\n+    assert updated_game.opponent.character == CHARACTER_ARCHER\n \n \n def test_reroll_action_wrong_stage():\n     \"\"\"Test reroll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -347,9 +347,9 @@ def test_reroll_action_active_not_rolled():\n     \"\"\"Test reroll fails when active player hasn't rolled yet (not ActivePlayer4)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -367,9 +367,9 @@ def test_reroll_action_opponent_not_rolled():\n     \"\"\"Test reroll fails when opponent hasn't rolled yet (not Opponent4)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -384,25 +384,25 @@ def test_reroll_action_opponent_not_rolled():\n \n \n def test_reroll_action_winner_exists():\n-    \"\"\"Test reroll fails when there's already a winner (stage is BATTLE_END)\"\"\"\n+    \"\"\"Test reroll fails when there's already a winner (stage is STAGE_BATTLE_END)\"\"\"\n     game = get_debug_preset(\"battle_player_1_win\")\n \n-    # Verify initial state has a winner and is in BATTLE_END stage\n+    # Verify initial state has a winner and is in STAGE_BATTLE_END stage\n     assert game.active.result.winner is True\n     assert game.opponent.result.winner is False\n-    assert game.stage == BATTLE_END\n+    assert game.stage == STAGE_BATTLE_END\n \n     action = RerollAction(\"player1\", game)\n \n-    # Should fail because stage is BATTLE_END, not BATTLE_DICE_ROLL\n+    # Should fail because stage is STAGE_BATTLE_END, not STAGE_BATTLE_DICE_ROLL\n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n         action.run()\n \n \n def test_reroll_action_winner_not_determined():\n     \"\"\"Test reroll fails when there's a winner (ActivePlayer4/Opponent4 with winner=True)\"\"\"\n-    # Use battle_player_1_win preset but keep stage as BATTLE_DICE_ROLL\n-    game = get_debug_preset(\"battle_player_1_win\", stage=BATTLE_DICE_ROLL)\n+    # Use battle_player_1_win preset but keep stage as STAGE_BATTLE_DICE_ROLL\n+    game = get_debug_preset(\"battle_player_1_win\", stage=STAGE_BATTLE_DICE_ROLL)\n \n     # Verify state: player1 won (knight dice=[6] + attack=1 = 7 > mage dice=[3] = 3)\n     assert isinstance(game.active, ActivePlayer4)\n@@ -458,12 +458,12 @@ def test_calculate_winner_draw():\n \n \n def test_set_winner_if_both_rolled_upgrades_to_player4():\n-    \"\"\"Test set_winner_if_both_rolled upgrades both players to Player4/Opponent4 and transitions to BATTLE_END\"\"\"\n+    \"\"\"Test set_winner_if_both_rolled upgrades both players to Player4/Opponent4 and transitions to STAGE_BATTLE_END\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -479,17 +479,17 @@ def test_set_winner_if_both_rolled_upgrades_to_player4():\n     assert game.opponent.result.winner is False\n     assert game.active.result.score == 7\n     assert game.opponent.result.score == 3\n-    # Verify stage transitioned to BATTLE_END\n-    assert game.stage == BATTLE_END\n+    # Verify stage transitioned to STAGE_BATTLE_END\n+    assert game.stage == STAGE_BATTLE_END\n \n \n def test_set_winner_if_both_rolled_does_nothing_when_not_both_rolled():\n     \"\"\"Test set_winner_if_both_rolled does nothing when only one player rolled\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -512,9 +512,9 @@ def test_debug_set_battle_dice_rolls_valid():\n     \"\"\"Test debug action successfully sets dice rolls and recalculates winner\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -545,9 +545,9 @@ def test_debug_set_battle_dice_rolls_creates_draw():\n     \"\"\"Test debug action can create a draw scenario\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=ARCHER, dice_roll=[1]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_ARCHER, dice_roll=[1]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -573,7 +573,7 @@ def test_debug_set_battle_dice_rolls_wrong_stage():\n     \"\"\"Test debug action fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -589,9 +589,9 @@ def test_debug_set_battle_dice_rolls_active_not_rolled():\n     \"\"\"Test debug action fails when active player hasn't rolled yet\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -607,9 +607,9 @@ def test_debug_set_battle_dice_rolls_opponent_not_rolled():\n     \"\"\"Test debug action fails when opponent hasn't rolled yet\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -625,9 +625,9 @@ def test_debug_set_battle_dice_rolls_invalid_dice_count():\n     \"\"\"Test debug action fails when dice count doesn't match character dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -659,9 +659,9 @@ def test_reroll_effect_action():\n     # - Second RerollDiceEffect (to test all are removed)\n     # - AttackBonusEffect and SkipTurnEffect (to test other effects are preserved)\n     active_character = game.players[game.active.player].characters[game.active.character]\n-    active_character.effects.append(RerollDiceEffect(source=BOUNCING_ARROW))\n-    active_character.effects.append(AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2))\n-    active_character.effects.append(SkipTurnEffect(source=FREEZE))\n+    active_character.effects.append(RerollDiceEffect(source=ABILITY_BOUNCING_ARROW))\n+    active_character.effects.append(AttackBonusEffect(source=ABILITY_BATTLE_HOWL, attack_bonus=2))\n+    active_character.effects.append(SkipTurnEffect(source=ABILITY_FREEZE))\n \n     # Verify initial state: 4 effects total (1 original + 3 added)\n     assert len(active_character.effects) == 4\n@@ -671,12 +671,12 @@ def test_reroll_effect_action():\n \n     # Verify preset created game state as ActivePlayer4/Opponent4 (both rolled, winner calculated)\n     # Archer lost: dice=[2] = 2 < mage dice=[5] = 5\n-    # Stage stays BATTLE_DICE_ROLL because loser has reroll effect available\n+    # Stage stays STAGE_BATTLE_DICE_ROLL because loser has reroll effect available\n     assert isinstance(game.active, ActivePlayer4)\n     assert isinstance(game.opponent, Opponent4)\n     assert game.active.result.winner is False\n     assert game.opponent.result.winner is True\n-    assert game.stage == BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n \n     # Perform reroll using RerollEffectAction\n     action = RerollEffectAction(\"player1\", game)\ndiff --git a/server/gameplay/actions/test_stage_battle_end.py b/server/gameplay/actions/test_stage_battle_end.py\nindex 996f74f..53362bc 100644\n--- a/server/gameplay/actions/test_stage_battle_end.py\n+++ b/server/gameplay/actions/test_stage_battle_end.py\n@@ -16,12 +16,12 @@ from .battle_end import BattleEndAction\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_MAGE,\n+    CHARACTER_ARCHER,\n )\n-from ..abilities import BATTLE_HOWL, FREEZE, BOUNCING_ARROW\n-from ..gameplay import BATTLE_END, CHARACTER_SELECT\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_FREEZE, ABILITY_BOUNCING_ARROW\n+from ..gameplay import STAGE_BATTLE_END, STAGE_CHARACTER_SELECT\n from ..effects import AttackNegBonusEffect, SkipTurnEffect, RerollDiceEffect\n from ..gameplay import (\n     GamePlay,\n@@ -39,20 +39,20 @@ def test_battle_end_clears_battle_effects():\n     characters2 = init_characters()\n \n     # Add BattleEffect to both characters\n-    characters1[KNIGHT].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-2))\n-    characters2[MAGE].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-1))\n+    characters1[CHARACTER_KNIGHT].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-2))\n+    characters2[CHARACTER_MAGE].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-1))\n \n     game = GamePlay(\n-        stage=BATTLE_END,\n+        stage=STAGE_BATTLE_END,\n         active=ActivePlayer4(\n             player=\"player1\",\n-            character=KNIGHT,\n+            character=CHARACTER_KNIGHT,\n             dice_roll=[6],\n             result=BattleResult(winner=True, score=7)\n         ),\n         opponent=Opponent4(\n             player=\"player2\",\n-            character=MAGE,\n+            character=CHARACTER_MAGE,\n             dice_roll=[5],\n             result=BattleResult(winner=False, score=5)\n         ),\n@@ -63,19 +63,19 @@ def test_battle_end_clears_battle_effects():\n     )\n \n     # Verify effects exist before battle end\n-    assert len(game.players[\"player1\"].characters[KNIGHT].effects) == 1\n-    assert len(game.players[\"player2\"].characters[MAGE].effects) == 1\n+    assert len(game.players[\"player1\"].characters[CHARACTER_KNIGHT].effects) == 1\n+    assert len(game.players[\"player2\"].characters[CHARACTER_MAGE].effects) == 1\n \n     # Execute battle end action\n     action = BattleEndAction(\"player1\", game)\n     updated_game = action.run()\n \n     # Verify BattleEffects are cleared from both characters\n-    assert len(updated_game.players[\"player1\"].characters[KNIGHT].effects) == 0\n-    assert len(updated_game.players[\"player2\"].characters[MAGE].effects) == 0\n+    assert len(updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].effects) == 0\n+    assert len(updated_game.players[\"player2\"].characters[CHARACTER_MAGE].effects) == 0\n \n     # Verify game transitioned to next turn\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player2\"  # Next player's turn\n \n \n@@ -85,22 +85,22 @@ def test_battle_end_disposes_reroll_effect():\n     characters2 = init_characters()\n \n     # Add RerollDiceEffect to active player\n-    characters1[ARCHER].effects.append(RerollDiceEffect(source=BOUNCING_ARROW, reroll_dice=True))\n+    characters1[CHARACTER_ARCHER].effects.append(RerollDiceEffect(source=ABILITY_BOUNCING_ARROW, reroll_dice=True))\n \n     # Add BattleEffect to opponent\n-    characters2[KNIGHT].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-2))\n+    characters2[CHARACTER_KNIGHT].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-2))\n \n     game = GamePlay(\n-        stage=BATTLE_END,\n+        stage=STAGE_BATTLE_END,\n         active=ActivePlayer4(\n             player=\"player1\",\n-            character=ARCHER,\n+            character=CHARACTER_ARCHER,\n             dice_roll=[6],\n             result=BattleResult(winner=True, score=7)\n         ),\n         opponent=Opponent4(\n             player=\"player2\",\n-            character=KNIGHT,\n+            character=CHARACTER_KNIGHT,\n             dice_roll=[5],\n             result=BattleResult(winner=False, score=5)\n         ),\n@@ -111,18 +111,18 "
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      },
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/e76da431d025adeaf6fd4cec21407c6cd045b7a4",
            "commitHash": "e76da431d025adeaf6fd4cec21407c6cd045b7a4",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/34",
            "prTitle": "Standardize constant naming conventions across codebase",
            "prBaseHash": "7eea3362a32949bb1a86b804e9c27b37ea10d33d",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21262381021"
          },
          "gitCommit": {
            "shortHash": "e76da43",
            "hash": "e76da431d025adeaf6fd4cec21407c6cd045b7a4",
            "subject": "Merge 8f23547df5408e06ac408eb775db83b2985e6c65 into 7eea3362a32949bb1a86b804e9c27b37ea10d33d",
            "body": "Merge 8f23547df5408e06ac408eb775db83b2985e6c65 into 7eea3362a32949bb1a86b804e9c27b37ea10d33d\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1769110792000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1769110792000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nindex 423dea5..6b441b0 100644\n--- a/server/gameplay/abilities.py\n+++ b/server/gameplay/abilities.py\n@@ -7,11 +7,11 @@ from pydantic import Field\n from .common import StrictModel\n from .effects import (\n     # Effect name constants for EFFECTS_SOURCE_ABILITY_MAP\n-    ATTACK_BONUS,\n-    ATTACK_NEG_BONUS,\n-    REROLL_DICE,\n-    SKIP_TURN,\n-    DRAW_CARD,\n+    EFFECT_ATTACK_BONUS,\n+    EFFECT_ATTACK_NEG_BONUS,\n+    EFFECT_REROLL_DICE,\n+    EFFECT_SKIP_TURN,\n+    EFFECT_DRAW_CARD,\n     # Apply to constants\n     APPLY_TO_SELECTED_OPPONENT,\n )\n@@ -19,10 +19,10 @@ from .effects import (\n ########################################################\n # Ability names - defined before imports from effects to avoid circular dependency\n ########################################################\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+ABILITY_BATTLE_HOWL = \"battle_howl\"\n+ABILITY_BOUNCING_ARROW = \"bouncing_arrow\"\n+ABILITY_FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE]\n AbilityName = Literal[*ABILITIES_NAMES]\n \n ########################################################\n@@ -31,11 +31,11 @@ AbilityName = Literal[*ABILITIES_NAMES]\n # Defines which abilities can create which effects\n # This is used for validation to ensure effects have valid source abilities\n EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+    EFFECT_ATTACK_BONUS: {ABILITY_BATTLE_HOWL},  # AttackBonusEffect can come from ABILITY_BATTLE_HOWL\n+    EFFECT_ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    EFFECT_REROLL_DICE: {ABILITY_BOUNCING_ARROW},  # RerollDiceEffect can come from ABILITY_BOUNCING_ARROW\n+    EFFECT_SKIP_TURN: {ABILITY_FREEZE},  # SkipTurnEffect can come from ABILITY_FREEZE\n+    EFFECT_DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n }\n \n # Import Effect classes after defining constants to avoid circular import\n@@ -58,22 +58,22 @@ class Ability(StrictModel):\n \n \n ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n+    ABILITY_BATTLE_HOWL: Ability(\n+        name=ABILITY_BATTLE_HOWL,\n         effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+            AttackBonusEffect(source=ABILITY_BATTLE_HOWL, attack_bonus=2),\n         ],\n     ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n+    ABILITY_BOUNCING_ARROW: Ability(\n+        name=ABILITY_BOUNCING_ARROW,\n         effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n+            RerollDiceEffect(source=ABILITY_BOUNCING_ARROW),\n         ],\n     ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n+    ABILITY_FREEZE: Ability(\n+        name=ABILITY_FREEZE,\n         effects=[\n-            SkipTurnEffect(source=FREEZE),\n+            SkipTurnEffect(source=ABILITY_FREEZE),\n         ],\n     ),\n }\ndiff --git a/server/gameplay/actions/__init__.py b/server/gameplay/actions/__init__.py\nindex 431c25d..f66df31 100644\n--- a/server/gameplay/actions/__init__.py\n+++ b/server/gameplay/actions/__init__.py\n@@ -1,26 +1,26 @@\n from typing import Dict\n \n from ..common import (\n-    CONNECT,\n-    LEAVE,\n-    DISCONNECT,\n-    CHARACTER_PRESS,\n-    CHARACTER_SELECT_ACTION,\n-    CARD_DRAW_ACTION,\n-    CARD_SELECT_ACTION,\n-    ABILITY_PRESS,\n-    ABILITY_SELECT,\n-    ABILITY_OPPONENT_PRESS,\n-    ABILITY_OPPONENT_SELECT,\n-    OPPONENT_PRESS,\n-    OPPONENT_SELECT,\n-    ACTIVE_PLAYER_ROLL,\n-    OPPONENT_ROLL,\n+    ACTION_CONNECT,\n+    ACTION_LEAVE,\n+    ACTION_DISCONNECT,\n+    ACTION_CHARACTER_PRESS,\n+    ACTION_CHARACTER_SELECT,\n+    ACTION_CARD_DRAW,\n+    ACTION_CARD_SELECT,\n+    ACTION_ABILITY_PRESS,\n+    ACTION_ABILITY_SELECT,\n+    ACTION_ABILITY_OPPONENT_PRESS,\n+    ACTION_ABILITY_OPPONENT_SELECT,\n+    ACTION_OPPONENT_PRESS,\n+    ACTION_OPPONENT_SELECT,\n+    ACTION_ACTIVE_PLAYER_ROLL,\n+    ACTION_OPPONENT_ROLL,\n     ACTION_REROLL,\n     ACTION_REROLL_EFFECT,\n-    BATTLE_END_ACTION,\n-    DEBUG_SET_BATTLE_DICE_ROLLS,\n-    DEBUG_SET_DRAWN_CARD,\n+    ACTION_BATTLE_END,\n+    ACTION_DEBUG_SET_BATTLE_DICE_ROLLS,\n+    ACTION_DEBUG_SET_DRAWN_CARD,\n )  # Action constants stay in models.py\n from .action import Action\n from .connection import ConnectAction, LeaveAction, DisconnectAction\n@@ -34,24 +34,24 @@ from .battle_end import BattleEndAction\n \n # Action mapping for dynamic action execution\n ACTION_MAP: Dict[str, type[Action]] = {\n-    CONNECT: ConnectAction,\n-    LEAVE: LeaveAction,\n-    DISCONNECT: DisconnectAction,\n-    CHARACTER_PRESS: CharacterPressAction,\n-    CHARACTER_SELECT_ACTION: CharacterSelectAction,\n-    CARD_DRAW_ACTION: CardDrawAction,\n-    CARD_SELECT_ACTION: CardSelectAction,\n-    ABILITY_PRESS: AbilityPressAction,\n-    ABILITY_SELECT: AbilitySelectAction,\n-    ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\n-    ABILITY_OPPONENT_SELECT: AbilityOpponentSelectAction,\n-    OPPONENT_PRESS: OpponentPressAction,\n-    OPPONENT_SELECT: OpponentSelectAction,\n-    ACTIVE_PLAYER_ROLL: ActivePlayerRollAction,\n-    OPPONENT_ROLL: OpponentRollAction,\n+    ACTION_CONNECT: ConnectAction,\n+    ACTION_LEAVE: LeaveAction,\n+    ACTION_DISCONNECT: DisconnectAction,\n+    ACTION_CHARACTER_PRESS: CharacterPressAction,\n+    ACTION_CHARACTER_SELECT: CharacterSelectAction,\n+    ACTION_CARD_DRAW: CardDrawAction,\n+    ACTION_CARD_SELECT: CardSelectAction,\n+    ACTION_ABILITY_PRESS: AbilityPressAction,\n+    ACTION_ABILITY_SELECT: AbilitySelectAction,\n+    ACTION_ABILITY_OPPONENT_PRESS: AbilityOpponentPressAction,\n+    ACTION_ABILITY_OPPONENT_SELECT: AbilityOpponentSelectAction,\n+    ACTION_OPPONENT_PRESS: OpponentPressAction,\n+    ACTION_OPPONENT_SELECT: OpponentSelectAction,\n+    ACTION_ACTIVE_PLAYER_ROLL: ActivePlayerRollAction,\n+    ACTION_OPPONENT_ROLL: OpponentRollAction,\n     ACTION_REROLL: RerollAction,\n     ACTION_REROLL_EFFECT: RerollEffectAction,\n-    BATTLE_END_ACTION: BattleEndAction,\n-    DEBUG_SET_BATTLE_DICE_ROLLS: DebugSetBattleDiceRollsAction,\n-    DEBUG_SET_DRAWN_CARD: DebugSetDrawnCardAction,\n+    ACTION_BATTLE_END: BattleEndAction,\n+    ACTION_DEBUG_SET_BATTLE_DICE_ROLLS: DebugSetBattleDiceRollsAction,\n+    ACTION_DEBUG_SET_DRAWN_CARD: DebugSetDrawnCardAction,\n }\ndiff --git a/server/gameplay/actions/battle_end.py b/server/gameplay/actions/battle_end.py\nindex f9bc5a1..52705e1 100644\n--- a/server/gameplay/actions/battle_end.py\n+++ b/server/gameplay/actions/battle_end.py\n@@ -7,8 +7,8 @@ Ends the battle, calculates winner, and reduces loser's health by 1.\n from .action import Action\n from ..common import GameException, ReportedException\n from ..gameplay import (\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     ActivePlayer1,\n     ActivePlayer3,\n@@ -28,7 +28,7 @@ class BattleEndAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_END]\n+        return [STAGE_BATTLE_END]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -65,11 +65,11 @@ class BattleEndAction(Action):\n         # If tied, no one loses health\n \n         # Dispose effects with 'battle_end' in their dispose_actions list\n-        from ..common import BATTLE_END_ACTION\n+        from ..common import ACTION_BATTLE_END\n \n         def should_keep_effect(effect):\n             \"\"\"Returns True if effect should be kept after battle\"\"\"\n-            return BATTLE_END_ACTION not in effect.dispose_actions\n+            return ACTION_BATTLE_END not in effect.dispose_actions\n \n         active_character.effects = [\n             effect for effect in active_character.effects\n@@ -91,7 +91,7 @@ class BattleEndAction(Action):\n         self.game.opponent = None\n         self.game.card = None\n         self.game.ability = None\n-        self.game.stage = CHARACTER_SELECT\n+        self.game.stage = STAGE_CHARACTER_SELECT\n         self.game.stage_meta = None\n \n         return self.game\ndiff --git a/server/gameplay/actions/connection.py b/server/gameplay/actions/connection.py\nindex d5e417e..d538498 100644\n--- a/server/gameplay/actions/connection.py\n+++ b/server/gameplay/actions/connection.py\n@@ -4,14 +4,14 @@ from .action import Action\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n-    CHARACTER_SELECT,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     Character,\n@@ -33,17 +33,17 @@ class ConnectAction(Action):\n                 raise ReportedException(\"Game is full\")\n \n             characters: Dict[str, Character] = {}\n-            for char_type in [KNIGHT, ARCHER, MAGE]:\n+            for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n                 characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n \n-            self.players[self.user] = Player(name=self.user, status=CONNECTED, characters=characters)\n+            self.players[self.user] = Player(name=self.user, status=STATUS_CONNECTED, characters=characters)\n \n         if self.game.active is None:\n             if self.game.stage is None:\n-                self.game.stage = CHARACTER_SELECT\n+                self.game.stage = STAGE_CHARACTER_SELECT\n             self.game.active = ActivePlayer1(player=self.user)\n \n-        self.player.status = CONNECTED\n+        self.player.status = STATUS_CONNECTED\n         return self.game\n \n \n@@ -66,5 +66,5 @@ class DisconnectAction(Action):\n         return None  # Can disconnect at any time\n \n     def _run(self) -> GamePlay:\n-        self.player.status = DISCONNECTED\n+        self.player.status = STATUS_DISCONNECTED\n         return self.game\ndiff --git a/server/gameplay/actions/stage_ability_opponent_selection.py b/server/gameplay/actions/stage_ability_opponent_selection.py\nindex 5985c08..0280458 100644\n--- a/server/gameplay/actions/stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/stage_ability_opponent_selection.py\n@@ -8,7 +8,7 @@ This module implements actions for the ability opponent selection stage:\n \n from .action import Action\n from ..common import GameException, ReportedException\n-from ..gameplay import ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION, GamePlay, Opponent2\n+from ..gameplay import STAGE_ABILITY_OPPONENT_SELECTION, STAGE_OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class AbilityOpponentPressAction(Action):\n@@ -21,7 +21,7 @@ class AbilityOpponentPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_OPPONENT_SELECTION]\n+        return [STAGE_ABILITY_OPPONENT_SELECTION]\n \n     def _run(self, opponent: str, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -67,7 +67,7 @@ class AbilityOpponentSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_OPPONENT_SELECTION]\n+        return [STAGE_ABILITY_OPPONENT_SELECTION]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -107,7 +107,7 @@ class AbilityOpponentSelectAction(Action):\n         self.game.ability_opponent = selected_opponent\n \n         # Transition to opponent selection stage\n-        self.game.stage = OPPONENT_SELECTION\n+        self.game.stage = STAGE_OPPONENT_SELECTION\n         self.game.stage_meta = None  # Clear stage metadata\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_ability_selection.py b/server/gameplay/actions/stage_ability_selection.py\nindex af35bf2..fe8c9c4 100644\n--- a/server/gameplay/actions/stage_ability_selection.py\n+++ b/server/gameplay/actions/stage_ability_selection.py\n@@ -12,7 +12,7 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_SELF\n from ..abilities import AbilityName\n-from ..gameplay import ABILITY_SELECTION, ABILITY_OPPONENT_SELECTION, OPPONENT_SELECTION\n+from ..gameplay import STAGE_ABILITY_SELECTION, STAGE_ABILITY_OPPONENT_SELECTION, STAGE_OPPONENT_SELECTION\n from ..gameplay import GamePlay, AbilitySelectMeta\n \n \n@@ -26,7 +26,7 @@ class AbilityPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_SELECTION]\n+        return [STAGE_ABILITY_SELECTION]\n \n     def _run(self, ability: AbilityName) -> GamePlay:\n         # Validate user is the active player\n@@ -66,7 +66,7 @@ class AbilitySelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [ABILITY_SELECTION]\n+        return [STAGE_ABILITY_SELECTION]\n \n     def _run(self, ability: AbilityName) -> GamePlay:\n         # Validate user is the active player\n@@ -108,8 +108,8 @@ class AbilitySelectAction(Action):\n \n         # Transition to ability_opponent_selection if ability requires it, otherwise skip to opponent_selection\n         if ability_obj.requires_opponent_selection:\n-            self.game.stage = ABILITY_OPPONENT_SELECTION\n+            self.game.stage = STAGE_ABILITY_OPPONENT_SELECTION\n         else:\n-            self.game.stage = OPPONENT_SELECTION\n+            self.game.stage = STAGE_OPPONENT_SELECTION\n \n         return self.game\ndiff --git a/server/gameplay/actions/stage_battle.py b/server/gameplay/actions/stage_battle.py\nindex a8fe573..846a62f 100644\n--- a/server/gameplay/actions/stage_battle.py\n+++ b/server/gameplay/actions/stage_battle.py\n@@ -13,9 +13,9 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import RerollDiceEffect\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     ActivePlayer2,\n     ActivePlayer3,\n@@ -100,7 +100,7 @@ def set_winner_if_both_rolled(game: GamePlay) -> None:\n                 return\n \n         # No reroll available for loser, transition to BATTLE_END\n-        game.stage = BATTLE_END\n+        game.stage = STAGE_BATTLE_END\n \n \n class ActivePlayerRollAction(Action):\n@@ -112,7 +112,7 @@ class ActivePlayerRollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -159,7 +159,7 @@ class OpponentRollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate opponent exists\n@@ -246,7 +246,7 @@ class RerollAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate it's a draw (no winner) - must be ActivePlayer4/Opponent4 with results\n@@ -274,7 +274,7 @@ class RerollEffectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL]\n+        return [STAGE_BATTLE_DICE_ROLL]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -321,7 +321,7 @@ class DebugSetBattleDiceRollsAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [BATTLE_DICE_ROLL, BATTLE_END]\n+        return [STAGE_BATTLE_DICE_ROLL, STAGE_BATTLE_END]\n \n     def _run(self, active_dice_roll: list[int], opponent_dice_roll: list[int]) -> GamePlay:\n         # Validate both players have rolled (must be ActivePlayer3/4 and Opponent3/4)\ndiff --git a/server/gameplay/actions/stage_card_draw.py b/server/gameplay/actions/stage_card_draw.py\nindex 5578205..116c91d 100644\n--- a/server/gameplay/actions/stage_card_draw.py\n+++ b/server/gameplay/actions/stage_card_draw.py\n@@ -11,7 +11,7 @@ from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT\n from ..cards import CardName, CARDS_MAP\n-from ..gameplay import CARD_DRAW, ABILITY_SELECTION\n+from ..gameplay import STAGE_CARD_DRAW, STAGE_ABILITY_SELECTION\n from ..gameplay import GamePlay, CardDrawMeta, AbilitySelectMeta\n \n \n@@ -25,7 +25,7 @@ class CardDrawAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -55,7 +55,7 @@ class CardSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -106,7 +106,7 @@ class CardSelectAction(Action):\n         self.game.stage_meta = None\n \n         # Transition to ability_selection stage\n-        self.game.stage = ABILITY_SELECTION\n+        self.game.stage = STAGE_ABILITY_SELECTION\n \n         # Auto-select if character has only one ability\n         if len(character.abilities) == 1:\n@@ -133,7 +133,7 @@ class DebugSetDrawnCardAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CARD_DRAW]\n+        return [STAGE_CARD_DRAW]\n \n     def _run(self, card_name: str) -> GamePlay:\n         # Validate card exists\ndiff --git a/server/gameplay/actions/stage_character_select.py b/server/gameplay/actions/stage_character_select.py\nindex cd8ba75..e79d53a 100644\n--- a/server/gameplay/actions/stage_character_select.py\n+++ b/server/gameplay/actions/stage_character_select.py\n@@ -10,12 +10,12 @@ from .action import Action\n from ..common import (\n     GameException,\n     ReportedException,\n-    CHARACTER_SELECT_ACTION,\n+    ACTION_CHARACTER_SELECT,\n )\n from ..gameplay import (\n-    CARD_DRAW,\n-    ABILITY_SELECTION,\n-    CHARACTER_SELECT,\n+    STAGE_CARD_DRAW,\n+    STAGE_ABILITY_SELECTION,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     CharacterSelectMeta,\n     CardDrawMeta,\n@@ -34,7 +34,7 @@ class CharacterPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CHARACTER_SELECT]\n+        return [STAGE_CHARACTER_SELECT]\n \n     def _run(self, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -70,7 +70,7 @@ class CharacterSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [CHARACTER_SELECT]\n+        return [STAGE_CHARACTER_SELECT]\n \n     def _run(self, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -94,14 +94,14 @@ class CharacterSelectAction(Action):\n         for char in player.characters.values():\n             char.effects = [\n                 effect for effect in char.effects\n-                if CHARACTER_SELECT_ACTION not in effect.dispose_actions\n+                if ACTION_CHARACTER_SELECT not in effect.dispose_actions\n             ]\n \n         # Update active player with selected character\n         self.game.active = ActivePlayer2(player=self.user, character=character)\n \n         # Transition to card_draw stage\n-        self.game.stage = CARD_DRAW\n+        self.game.stage = STAGE_CARD_DRAW\n \n         # Clear stage_meta - will be populated by CardDrawAction\n         self.game.stage_meta = None\ndiff --git a/server/gameplay/actions/stage_opponent_selection.py b/server/gameplay/actions/stage_opponent_selection.py\nindex 0195959..5afe93d 100644\n--- a/server/gameplay/actions/stage_opponent_selection.py\n+++ b/server/gameplay/actions/stage_opponent_selection.py\n@@ -10,7 +10,7 @@ import copy\n from .action import Action\n from ..common import GameException, ReportedException\n from ..effects import APPLY_TO_BATTLE_OPPONENT\n-from ..gameplay import BATTLE_DICE_ROLL, OPPONENT_SELECTION, GamePlay, Opponent2\n+from ..gameplay import STAGE_BATTLE_DICE_ROLL, STAGE_OPPONENT_SELECTION, GamePlay, Opponent2\n \n \n class OpponentPressAction(Action):\n@@ -23,7 +23,7 @@ class OpponentPressAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [OPPONENT_SELECTION]\n+        return [STAGE_OPPONENT_SELECTION]\n \n     def _run(self, opponent: str, character: str) -> GamePlay:\n         # Validate user is the active player\n@@ -69,7 +69,7 @@ class OpponentSelectAction(Action):\n \n     @property\n     def action_stages(self):\n-        return [OPPONENT_SELECTION]\n+        return [STAGE_OPPONENT_SELECTION]\n \n     def _run(self) -> GamePlay:\n         # Validate user is the active player\n@@ -120,7 +120,7 @@ class OpponentSelectAction(Action):\n                     opponent_character.effects.append(effect_copy)\n \n         # Transition to battle dice roll stage\n-        self.game.stage = BATTLE_DICE_ROLL\n+        self.game.stage = STAGE_BATTLE_DICE_ROLL\n         self.game.stage_meta = None  # Clear stage metadata\n \n         return self.game\ndiff --git a/server/gameplay/actions/test_action_properties.py b/server/gameplay/actions/test_action_properties.py\nindex 858c847..93833d2 100644\n--- a/server/gameplay/actions/test_action_properties.py\n+++ b/server/gameplay/actions/test_action_properties.py\n@@ -7,10 +7,10 @@ These tests verify that action properties work correctly across different game s\n import pytest\n \n from .action import Action\n-from ..common import GameException, KNIGHT, MAGE, ARCHER\n+from ..common import GameException, CHARACTER_KNIGHT, CHARACTER_MAGE, CHARACTER_ARCHER\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    CHARACTER_SELECT,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     ActivePlayer1,\n@@ -54,8 +54,8 @@ def test_active_character_with_active_player2():\n     \"\"\"Test active_character property with ActivePlayer2\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -73,8 +73,8 @@ def test_active_character_with_active_player3():\n     \"\"\"Test active_character property with ActivePlayer3\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -92,8 +92,8 @@ def test_active_character_with_active_player4():\n     \"\"\"Test active_character property with ActivePlayer4\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer4(player=\"player1\", character=ARCHER, dice_roll=[3], result=BattleResult(winner=True, score=3)),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer4(player=\"player1\", character=CHARACTER_ARCHER, dice_roll=[3], result=BattleResult(winner=True, score=3)),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n         },\n@@ -111,7 +111,7 @@ def test_active_character_with_active_player1_fails():\n     \"\"\"Test active_character property fails with ActivePlayer1 (no character selected)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -127,7 +127,7 @@ def test_active_character_with_no_active_fails():\n     \"\"\"Test active_character property fails when no active player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -148,9 +148,9 @@ def test_opponent_character_with_opponent2():\n     \"\"\"Test opponent_character property with Opponent2\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -169,9 +169,9 @@ def test_opponent_character_with_opponent3():\n     \"\"\"Test opponent_character property with Opponent3\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent3(player=\"player2\", character=ARCHER, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_ARCHER, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -190,9 +190,9 @@ def test_opponent_character_with_opponent4():\n     \"\"\"Test opponent_character property with Opponent4\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer4(player=\"player1\", character=KNIGHT, dice_roll=[6], result=BattleResult(winner=True, score=7)),\n-        opponent=Opponent4(player=\"player2\", character=MAGE, dice_roll=[1], result=BattleResult(winner=False, score=1)),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer4(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6], result=BattleResult(winner=True, score=7)),\n+        opponent=Opponent4(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[1], result=BattleResult(winner=False, score=1)),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -211,8 +211,8 @@ def test_opponent_character_with_no_opponent_fails():\n     \"\"\"Test opponent_character property fails when no opponent\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -233,7 +233,7 @@ def test_player_property():\n     \"\"\"Test player property returns correct player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -245,16 +245,16 @@ def test_player_property():\n     player = action.player\n \n     assert player.name == \"player1\"\n-    assert KNIGHT in player.characters\n-    assert player.characters[KNIGHT].health == KNIGHT_L1_DEFAULT_HEALTH\n-    assert player.characters[KNIGHT].attack == KNIGHT_L1_ATTACK\n+    assert CHARACTER_KNIGHT in player.characters\n+    assert player.characters[CHARACTER_KNIGHT].health == KNIGHT_L1_DEFAULT_HEALTH\n+    assert player.characters[CHARACTER_KNIGHT].attack == KNIGHT_L1_ATTACK\n \n \n def test_player_property_player_not_in_game_fails():\n     \"\"\"Test player property fails when player not in game\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -275,7 +275,7 @@ def test_stage_property_get():\n     \"\"\"Test stage property getter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n+        stage=STAGE_BATTLE_DICE_ROLL,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -283,14 +283,14 @@ def test_stage_property_get():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    assert action.stage == BATTLE_DICE_ROLL\n+    assert action.stage == STAGE_BATTLE_DICE_ROLL\n \n \n def test_stage_property_set():\n     \"\"\"Test stage property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -298,9 +298,9 @@ def test_stage_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    action.stage = BATTLE_DICE_ROLL\n-    assert action.stage == BATTLE_DICE_ROLL\n-    assert game.stage == BATTLE_DICE_ROLL\n+    action.stage = STAGE_BATTLE_DICE_ROLL\n+    assert action.stage == STAGE_BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n \n \n # ============================================================================\n@@ -311,9 +311,9 @@ def test_stage_property_set():\n def test_active_property_get():\n     \"\"\"Test active property getter\"\"\"\n     characters = init_characters()\n-    active_player = ActivePlayer2(player=\"player1\", character=KNIGHT)\n+    active_player = ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT)\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=active_player,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -323,14 +323,14 @@ def test_active_property_get():\n     action = ConcreteAction(\"player1\", game)\n     assert action.active == active_player\n     assert action.active.player == \"player1\"\n-    assert action.active.character == KNIGHT\n+    assert action.active.character == CHARACTER_KNIGHT\n \n \n def test_active_property_set():\n     \"\"\"Test active property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -338,7 +338,7 @@ def test_active_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    new_active = ActivePlayer2(player=\"player1\", character=MAGE)\n+    new_active = ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE)\n     action.active = new_active\n \n     assert action.active == new_active\n@@ -348,10 +348,10 @@ def test_active_property_set():\n def test_opponent_property_get():\n     \"\"\"Test opponent property getter\"\"\"\n     characters = init_characters()\n-    opponent = Opponent2(player=\"player2\", character=ARCHER)\n+    opponent = Opponent2(player=\"player2\", character=CHARACTER_ARCHER)\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=opponent,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -362,15 +362,15 @@ def test_opponent_property_get():\n     action = ConcreteAction(\"player1\", game)\n     assert action.opponent == opponent\n     assert action.opponent.player == \"player2\"\n-    assert action.opponent.character == ARCHER\n+    assert action.opponent.character == CHARACTER_ARCHER\n \n \n def test_opponent_property_set():\n     \"\"\"Test opponent property setter\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -379,7 +379,7 @@ def test_opponent_property_set():\n     )\n \n     action = ConcreteAction(\"player1\", game)\n-    new_opponent = Opponent2(player=\"player2\", character=MAGE)\n+    new_opponent = Opponent2(player=\"player2\", character=CHARACTER_MAGE)\n     action.opponent = new_opponent\n \n     assert action.opponent == new_opponent\ndiff --git a/server/gameplay/actions/test_connect_action.py b/server/gameplay/actions/test_connect_action.py\nindex 3e2564d..30dfb73 100644\n--- a/server/gameplay/actions/test_connect_action.py\n+++ b/server/gameplay/actions/test_connect_action.py\n@@ -10,14 +10,14 @@ import pytest\n from .connection import ConnectAction, MAX_PLAYERS\n from ..common import (\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n-    CHARACTER_SELECT,\n+    STAGE_CHARACTER_SELECT,\n     GamePlay,\n     Player,\n     Character,\n@@ -37,31 +37,31 @@ def test_connect_action_new_player():\n \n     assert \"player1\" in updated_game.players\n     assert updated_game.players[\"player1\"].name == \"player1\"\n-    assert updated_game.players[\"player1\"].status == CONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n     assert len(updated_game.players[\"player1\"].characters) == 3\n-    assert KNIGHT in updated_game.players[\"player1\"].characters\n-    assert ARCHER in updated_game.players[\"player1\"].characters\n-    assert MAGE in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_KNIGHT in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_ARCHER in updated_game.players[\"player1\"].characters\n+    assert CHARACTER_MAGE in updated_game.players[\"player1\"].characters\n     # Verify each character has empty cards list\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].cards == []\n-    assert updated_game.players[\"player1\"].characters[ARCHER].cards == []\n-    assert updated_game.players[\"player1\"].characters[MAGE].cards == []\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].cards == []\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_ARCHER].cards == []\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_MAGE].cards == []\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n \n def test_connect_action_existing_player_reconnect():\n     \"\"\"Test reconnecting an existing player who was disconnected\"\"\"\n     game = GamePlay()\n-    knight_char = Character(level=2, **CHARACTER_DEFAULT_STATS[KNIGHT])\n+    knight_char = Character(level=2, **CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT])\n     knight_char.cards = [\"talisman\"]  # Knight has a card\n     game.players[\"player1\"] = Player(\n         name=\"player1\",\n-        status=DISCONNECTED,\n+        status=STATUS_DISCONNECTED,\n         characters={\n             KNIGHT: knight_char,\n-            ARCHER: Character(level=1, **CHARACTER_DEFAULT_STATS[ARCHER]),\n-            MAGE: Character(level=1, **CHARACTER_DEFAULT_STATS[MAGE]),\n+            ARCHER: Character(level=1, **CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER]),\n+            MAGE: Character(level=1, **CHARACTER_DEFAULT_STATS[CHARACTER_MAGE]),\n         },\n     )\n \n@@ -69,9 +69,9 @@ def test_connect_action_existing_player_reconnect():\n     updated_game = action.run()\n \n     # Player should be reconnected with their existing data\n-    assert updated_game.players[\"player1\"].status == CONNECTED\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].cards == [\"talisman\"]\n-    assert updated_game.players[\"player1\"].characters[KNIGHT].level == 2\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].cards == [\"talisman\"]\n+    assert updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].level == 2\n \n \n def test_connect_action_game_full():\n@@ -82,7 +82,7 @@ def test_connect_action_game_full():\n     for i in range(MAX_PLAYERS):\n         player_name = f\"player{i+1}\"\n         characters = {}\n-        for char_type in [KNIGHT, ARCHER, MAGE]:\n+        for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n             characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n         game.players[player_name] = Player(name=player_name, characters=characters)\n \n@@ -95,10 +95,10 @@ def test_connect_action_game_full():\n def test_connect_action_second_player():\n     \"\"\"Test connecting a second player to a game with one player\"\"\"\n     game = GamePlay()\n-    game.stage = CHARACTER_SELECT\n+    game.stage = STAGE_CHARACTER_SELECT\n     game.active = ActivePlayer1(player=\"player1\")\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n \n@@ -106,8 +106,8 @@ def test_connect_action_second_player():\n     updated_game = action.run()\n \n     assert \"player2\" in updated_game.players\n-    assert updated_game.players[\"player2\"].status == CONNECTED\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player2\"].status == STATUS_CONNECTED\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"  # Active player should not change\n \n \n@@ -119,7 +119,7 @@ def test_connect_action_stage_none():\n \n     updated_game = action.run()\n \n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n \n@@ -133,25 +133,25 @@ def test_connect_action_character_stats():\n     player = updated_game.players[\"player1\"]\n \n     # Check knight stats\n-    knight = player.characters[KNIGHT]\n+    knight = player.characters[CHARACTER_KNIGHT]\n     assert knight.level == 1\n-    assert knight.health == CHARACTER_DEFAULT_STATS[KNIGHT][\"health\"]\n-    assert knight.max_health == CHARACTER_DEFAULT_STATS[KNIGHT][\"max_health\"]\n-    assert knight.dice == CHARACTER_DEFAULT_STATS[KNIGHT][\"dice\"]\n-    assert knight.attack == CHARACTER_DEFAULT_STATS[KNIGHT][\"attack\"]\n+    assert knight.health == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"health\"]\n+    assert knight.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"max_health\"]\n+    assert knight.dice == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"dice\"]\n+    assert knight.attack == CHARACTER_DEFAULT_STATS[CHARACTER_KNIGHT][\"attack\"]\n \n     # Check archer stats (no attack bonus)\n-    archer = player.characters[ARCHER]\n+    archer = player.characters[CHARACTER_ARCHER]\n     assert archer.level == 1\n-    assert archer.health == CHARACTER_DEFAULT_STATS[ARCHER][\"health\"]\n-    assert archer.max_health == CHARACTER_DEFAULT_STATS[ARCHER][\"max_health\"]\n-    assert archer.dice == CHARACTER_DEFAULT_STATS[ARCHER][\"dice\"]\n+    assert archer.health == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"health\"]\n+    assert archer.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"max_health\"]\n+    assert archer.dice == CHARACTER_DEFAULT_STATS[CHARACTER_ARCHER][\"dice\"]\n     assert archer.attack == ARCHER_L1_ATTACK\n \n     # Check mage stats (no attack bonus)\n-    mage = player.characters[MAGE]\n+    mage = player.characters[CHARACTER_MAGE]\n     assert mage.level == 1\n-    assert mage.health == CHARACTER_DEFAULT_STATS[MAGE][\"health\"]\n-    assert mage.max_health == CHARACTER_DEFAULT_STATS[MAGE][\"max_health\"]\n-    assert mage.dice == CHARACTER_DEFAULT_STATS[MAGE][\"dice\"]\n+    assert mage.health == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"health\"]\n+    assert mage.max_health == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"max_health\"]\n+    assert mage.dice == CHARACTER_DEFAULT_STATS[CHARACTER_MAGE][\"dice\"]\n     assert mage.attack == MAGE_L1_ATTACK\ndiff --git a/server/gameplay/actions/test_connection_integration.py b/server/gameplay/actions/test_connection_integration.py\nindex e63bdab..fed9856 100644\n--- a/server/gameplay/actions/test_connection_integration.py\n+++ b/server/gameplay/actions/test_connection_integration.py\n@@ -9,8 +9,8 @@ and leaving actions.\n import pytest\n \n from .connection import ConnectAction, DisconnectAction, LeaveAction\n-from ..common import CONNECTED, DISCONNECTED\n-from ..gameplay import CHARACTER_SELECT, GamePlay\n+from ..common import STATUS_CONNECTED, STATUS_DISCONNECTED\n+from ..gameplay import STAGE_CHARACTER_SELECT, GamePlay\n \n \n def test_connect_then_disconnect_then_reconnect():\n@@ -21,21 +21,21 @@ def test_connect_then_disconnect_then_reconnect():\n     connect_action = ConnectAction(\"player1\", game)\n     updated_game = connect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == CONNECTED\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player1\"\n \n     # Disconnect\n     disconnect_action = DisconnectAction(\"player1\", updated_game)\n     updated_game = disconnect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\n \n     # Reconnect\n     reconnect_action = ConnectAction(\"player1\", updated_game)\n     updated_game = reconnect_action.run()\n \n-    assert updated_game.players[\"player1\"].status == CONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_CONNECTED\n \n \n def test_multiple_players_connect_disconnect_leave():\n@@ -55,7 +55,7 @@ def test_multiple_players_connect_disconnect_leave():\n     disconnect_action = DisconnectAction(\"player2\", game)\n     game = disconnect_action.run()\n \n-    assert game.players[\"player2\"].status == DISCONNECTED\n+    assert game.players[\"player2\"].status == STATUS_DISCONNECTED\n     assert len(game.players) == 3  # Still in game\n \n     # Player3 leaves\n@@ -69,5 +69,5 @@ def test_multiple_players_connect_disconnect_leave():\n     reconnect_action = ConnectAction(\"player2\", game)\n     game = reconnect_action.run()\n \n-    assert game.players[\"player2\"].status == CONNECTED\n+    assert game.players[\"player2\"].status == STATUS_CONNECTED\n     assert len(game.players) == 2\ndiff --git a/server/gameplay/actions/test_disconnect_action.py b/server/gameplay/actions/test_disconnect_action.py\nindex 2337f53..c9fdb35 100644\n--- a/server/gameplay/actions/test_disconnect_action.py\n+++ b/server/gameplay/actions/test_disconnect_action.py\n@@ -10,11 +10,11 @@ import pytest\n from .connection import DisconnectAction\n from ..common import (\n     GameException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n-    CONNECTED,\n-    DISCONNECTED,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n+    STATUS_CONNECTED,\n+    STATUS_DISCONNECTED,\n )\n from ..gameplay import (\n     GamePlay,\n@@ -28,14 +28,14 @@ def test_disconnect_action_existing_player():\n     \"\"\"Test disconnecting an existing connected player\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n-    game.players[\"player1\"] = Player(name=\"player1\", status=CONNECTED, characters=characters)\n+    game.players[\"player1\"] = Player(name=\"player1\", status=STATUS_CONNECTED, characters=characters)\n \n     action = DisconnectAction(\"player1\", game)\n     updated_game = action.run()\n \n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\n     assert updated_game.players[\"player1\"].name == \"player1\"  # Other data preserved\n \n \n@@ -52,12 +52,12 @@ def test_disconnect_action_already_disconnected():\n     \"\"\"Test disconnecting a player who is already disconnected\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n-    game.players[\"player1\"] = Player(name=\"player1\", status=DISCONNECTED, characters=characters)\n+    game.players[\"player1\"] = Player(name=\"player1\", status=STATUS_DISCONNECTED, characters=characters)\n \n     action = DisconnectAction(\"player1\", game)\n     updated_game = action.run()\n \n     # Should still work and status remains disconnected\n-    assert updated_game.players[\"player1\"].status == DISCONNECTED\n+    assert updated_game.players[\"player1\"].status == STATUS_DISCONNECTED\ndiff --git a/server/gameplay/actions/test_leave_action.py b/server/gameplay/actions/test_leave_action.py\nindex e67ef2e..7b43472 100644\n--- a/server/gameplay/actions/test_leave_action.py\n+++ b/server/gameplay/actions/test_leave_action.py\n@@ -9,7 +9,7 @@ the only player leaving.\n import pytest\n \n from .connection import LeaveAction\n-from ..common import GameException, KNIGHT, ARCHER, MAGE\n+from ..common import GameException, CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE\n from ..gameplay import (\n     GamePlay,\n     Player,\n@@ -22,7 +22,7 @@ def test_leave_action_existing_player():\n     \"\"\"Test a player leaving the game\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n     game.players[\"player2\"] = Player(name=\"player2\", characters=characters)\n@@ -47,7 +47,7 @@ def test_leave_action_only_player():\n     \"\"\"Test the only player in the game leaving\"\"\"\n     game = GamePlay()\n     characters = {}\n-    for char_type in [KNIGHT, ARCHER, MAGE]:\n+    for char_type in [CHARACTER_KNIGHT, CHARACTER_ARCHER, CHARACTER_MAGE]:\n         characters[char_type] = Character(level=1, **CHARACTER_DEFAULT_STATS[char_type])\n     game.players[\"player1\"] = Player(name=\"player1\", characters=characters)\n \ndiff --git a/server/gameplay/actions/test_stage_ability_opponent_selection.py b/server/gameplay/actions/test_stage_ability_opponent_selection.py\nindex 75dfb7d..1f4618f 100644\n--- a/server/gameplay/actions/test_stage_ability_opponent_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_opponent_selection.py\n@@ -8,11 +8,11 @@ selected opponents for ability targeting and confirming selections to apply effe\n import pytest\n \n from .stage_ability_opponent_selection import AbilityOpponentPressAction, AbilityOpponentSelectAction\n-from ..common import GameException, ReportedException, KNIGHT, MAGE\n-from ..abilities import BATTLE_HOWL, FREEZE, ABILITIES_MAP\n+from ..common import GameException, ReportedException, CHARACTER_KNIGHT, CHARACTER_MAGE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_FREEZE, ABILITIES_MAP\n from ..gameplay import (\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n+    STAGE_ABILITY_OPPONENT_SELECTION,\n+    STAGE_OPPONENT_SELECTION,\n     GamePlay,\n     Player,\n     ActivePlayer2,\n@@ -25,9 +25,9 @@ def test_ability_opponent_press_action_valid():\n     \"\"\"Test pressing opponent's character highlights it in stage_meta\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -35,22 +35,22 @@ def test_ability_opponent_press_action_valid():\n     )\n \n     action = AbilityOpponentPressAction(\"player1\", game)\n-    updated_game = action.run(opponent=\"player2\", character=KNIGHT)\n+    updated_game = action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n     assert updated_game.stage_meta is not None\n     assert isinstance(updated_game.stage_meta, Opponent2)\n     assert updated_game.stage_meta.player == \"player2\"\n-    assert updated_game.stage_meta.character == KNIGHT\n-    assert updated_game.stage == ABILITY_OPPONENT_SELECTION  # Still in ability opponent selection\n+    assert updated_game.stage_meta.character == CHARACTER_KNIGHT\n+    assert updated_game.stage == STAGE_ABILITY_OPPONENT_SELECTION  # Still in ability opponent selection\n \n \n def test_ability_opponent_press_action_not_active_player():\n     \"\"\"Test pressing opponent when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -60,16 +60,16 @@ def test_ability_opponent_press_action_not_active_player():\n     action = AbilityOpponentPressAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(opponent=\"player1\", character=KNIGHT)\n+        action.run(opponent=\"player1\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_wrong_stage():\n     \"\"\"Test pressing opponent in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -79,32 +79,32 @@ def test_ability_opponent_press_action_wrong_stage():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(opponent=\"player2\", character=KNIGHT)\n+        action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_invalid_opponent():\n     \"\"\"Test pressing non-existent opponent raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"not in game\"):\n-        action.run(opponent=\"nonexistent\", character=KNIGHT)\n+        action.run(opponent=\"nonexistent\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_self_as_opponent():\n     \"\"\"Test pressing self as opponent raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -114,18 +114,18 @@ def test_ability_opponent_press_action_self_as_opponent():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"Cannot select yourself as opponent\"):\n-        action.run(opponent=\"player1\", character=KNIGHT)\n+        action.run(opponent=\"player1\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_press_action_dead_character():\n     \"\"\"Test pressing dead character raises error\"\"\"\n     characters = init_characters()\n     # Kill the knight\n-    characters[KNIGHT].health = 0\n+    characters[CHARACTER_KNIGHT].health = 0\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n-        ability=ABILITIES_MAP[FREEZE],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n+        ability=ABILITIES_MAP[ABILITY_FREEZE],\n         players={\n             \"player1\": Player(name=\"player1\", characters=init_characters()),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -135,7 +135,7 @@ def test_ability_opponent_press_action_dead_character():\n     action = AbilityOpponentPressAction(\"player1\", game)\n \n     with pytest.raises(ReportedException, match=\"is dead and can't be targeted\"):\n-        action.run(opponent=\"player2\", character=KNIGHT)\n+        action.run(opponent=\"player2\", character=CHARACTER_KNIGHT)\n \n \n def test_ability_opponent_select_action_valid():\n@@ -143,10 +143,10 @@ def test_ability_opponent_select_action_valid():\n     characters1 = init_characters()\n     characters2 = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters1),\n             \"player2\": Player(name=\"player2\", characters=characters2),\n@@ -157,28 +157,28 @@ def test_ability_opponent_select_action_valid():\n     updated_game = action.run()\n \n     # Check stage transition\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.stage_meta is None\n \n     # Check ability_opponent is set\n     assert updated_game.ability_opponent is not None\n     assert updated_game.ability_opponent.player == \"player2\"\n-    assert updated_game.ability_opponent.character == KNIGHT\n+    assert updated_game.ability_opponent.character == CHARACTER_KNIGHT\n \n     # Check effects were applied to target character\n-    target_character = updated_game.players[\"player2\"].characters[KNIGHT]\n+    target_character = updated_game.players[\"player2\"].characters[CHARACTER_KNIGHT]\n     assert len(target_character.effects) > 0\n-    assert target_character.effects[0].source == BATTLE_HOWL\n+    assert target_character.effects[0].source == ABILITY_BATTLE_HOWL\n \n \n def test_ability_opponent_select_action_not_active_player():\n     \"\"\"Test confirming ability opponent selection when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -195,10 +195,10 @@ def test_ability_opponent_select_action_wrong_stage():\n     \"\"\"Test confirming ability opponent selection in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -215,9 +215,9 @@ def test_ability_opponent_select_action_no_target_selected():\n     \"\"\"Test confirming ability opponent selection without selecting target raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        ability=ABILITIES_MAP[BATTLE_HOWL],\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        ability=ABILITIES_MAP[ABILITY_BATTLE_HOWL],\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -235,13 +235,13 @@ def test_ability_opponent_select_action_dead_character():\n     characters1 = init_characters()\n     characters2 = init_characters()\n     # Kill the target knight\n-    characters2[KNIGHT].health = 0\n+    characters2[CHARACTER_KNIGHT].health = 0\n \n     game = GamePlay(\n-        stage=ABILITY_OPPONENT_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n-        ability=ABILITIES_MAP[FREEZE],\n-        stage_meta=Opponent2(player=\"player2\", character=KNIGHT),\n+        stage=STAGE_ABILITY_OPPONENT_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n+        ability=ABILITIES_MAP[ABILITY_FREEZE],\n+        stage_meta=Opponent2(player=\"player2\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters1),\n             \"player2\": Player(name=\"player2\", characters=characters2),\ndiff --git a/server/gameplay/actions/test_stage_ability_selection.py b/server/gameplay/actions/test_stage_ability_selection.py\nindex b3c0106..60c2eb1 100644\n--- a/server/gameplay/actions/test_stage_ability_selection.py\n+++ b/server/gameplay/actions/test_stage_ability_selection.py\n@@ -3,8 +3,8 @@ Tests for Ability Selection Stage Actions.\n \n These tests verify ability selection behavior including highlighting\n selected abilities and confirming selections to transition to:\n-- ability_opponent_selection (for effects requiring target selection, e.g., FREEZE)\n-- opponent_selection (for effects applied to battle opponent, e.g., BATTLE_HOWL, BOUNCING_ARROW)\n+- ability_opponent_selection (for effects requiring target selection, e.g., ABILITY_FREEZE)\n+- opponent_selection (for effects applied to battle opponent, e.g., ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW)\n \"\"\"\n \n import pytest\n@@ -13,17 +13,17 @@ from .stage_ability_selection import AbilityPressAction, AbilitySelectAction\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n )\n from ..effects import REROLL_DICE\n-from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE\n from ..gameplay import (\n-    ABILITY_SELECTION,\n-    ABILITY_OPPONENT_SELECTION,\n-    OPPONENT_SELECTION,\n-    CHARACTER_SELECT,\n+    STAGE_ABILITY_SELECTION,\n+    STAGE_ABILITY_OPPONENT_SELECTION,\n+    STAGE_OPPONENT_SELECTION,\n+    STAGE_CHARACTER_SELECT,\n )\n from ..effects import RerollDiceEffect\n from ..gameplay import (\n@@ -38,25 +38,25 @@ def test_ability_press_action_valid():\n     \"\"\"Test pressing an ability highlights it in stage_meta\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=BATTLE_HOWL)\n+    updated_game = action.run(ability=ABILITY_BATTLE_HOWL)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == BATTLE_HOWL\n-    assert updated_game.stage == ABILITY_SELECTION  # Still in ability selection\n+    assert updated_game.stage_meta.selected == ABILITY_BATTLE_HOWL\n+    assert updated_game.stage == STAGE_ABILITY_SELECTION  # Still in ability selection\n \n \n def test_ability_press_action_not_active_player():\n     \"\"\"Test pressing ability when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -66,88 +66,88 @@ def test_ability_press_action_not_active_player():\n     action = AbilityPressAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_press_action_wrong_stage():\n     \"\"\"Test pressing ability in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_press_action_invalid_ability():\n     \"\"\"Test pressing ability not available for character raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n \n-    # Knight should have BATTLE_HOWL, not FREEZE (which is for mage)\n+    # Knight should have ABILITY_BATTLE_HOWL, not ABILITY_FREEZE (which is for mage)\n     with pytest.raises(ReportedException, match=\"not available for this character\"):\n-        action.run(ability=FREEZE)\n+        action.run(ability=ABILITY_FREEZE)\n \n \n def test_ability_press_action_archer():\n-    \"\"\"Test pressing archer's ability (BOUNCING_ARROW) works correctly\"\"\"\n+    \"\"\"Test pressing archer's ability (ABILITY_BOUNCING_ARROW) works correctly\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == BOUNCING_ARROW\n+    assert updated_game.stage_meta.selected == ABILITY_BOUNCING_ARROW\n \n \n def test_ability_press_action_mage():\n-    \"\"\"Test pressing mage's ability (FREEZE) works correctly\"\"\"\n+    \"\"\"Test pressing mage's ability (ABILITY_FREEZE) works correctly\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilityPressAction(\"player1\", game)\n-    updated_game = action.run(ability=FREEZE)\n+    updated_game = action.run(ability=ABILITY_FREEZE)\n \n     assert updated_game.stage_meta is not None\n-    assert updated_game.stage_meta.selected == FREEZE\n+    assert updated_game.stage_meta.selected == ABILITY_FREEZE\n \n \n def test_ability_select_action_valid():\n     \"\"\"Test confirming ability selection transitions to opponent_selection (for battle opponent effects)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BATTLE_HOWL)\n+    updated_game = action.run(ability=ABILITY_BATTLE_HOWL)\n \n-    # BATTLE_HOWL applies to battle opponent, so skip ability_opponent_selection\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    # ABILITY_BATTLE_HOWL applies to battle opponent, so skip ability_opponent_selection\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == BATTLE_HOWL\n+    assert updated_game.ability.name == ABILITY_BATTLE_HOWL\n     assert updated_game.stage_meta is None\n \n \n@@ -155,8 +155,8 @@ def test_ability_select_action_not_active_player():\n     \"\"\"Test confirming ability selection when not active player raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -166,76 +166,76 @@ def test_ability_select_action_not_active_player():\n     action = AbilitySelectAction(\"player2\", game)\n \n     with pytest.raises(ReportedException, match=\"It's not your turn\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_select_action_wrong_stage():\n     \"\"\"Test confirming ability selection in wrong stage raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_CHARACTER_SELECT,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n \n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n-        action.run(ability=BATTLE_HOWL)\n+        action.run(ability=ABILITY_BATTLE_HOWL)\n \n \n def test_ability_select_action_invalid_ability():\n     \"\"\"Test confirming ability not available for character raises error\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n \n-    # Knight should have BATTLE_HOWL, not BOUNCING_ARROW (which is for archer)\n+    # Knight should have ABILITY_BATTLE_HOWL, not ABILITY_BOUNCING_ARROW (which is for archer)\n     with pytest.raises(ReportedException, match=\"not available for this character\"):\n-        action.run(ability=BOUNCING_ARROW)\n+        action.run(ability=ABILITY_BOUNCING_ARROW)\n \n \n def test_ability_select_action_archer():\n     \"\"\"Test confirming archer's ability selection skips to opponent_selection\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n-    # BOUNCING_ARROW applies to self, so skip ability_opponent_selection\n-    assert updated_game.stage == OPPONENT_SELECTION\n+    # ABILITY_BOUNCING_ARROW applies to self, so skip ability_opponent_selection\n+    assert updated_game.stage == STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == BOUNCING_ARROW\n+    assert updated_game.ability.name == ABILITY_BOUNCING_ARROW\n     assert updated_game.stage_meta is None\n \n \n def test_ability_select_action_archer_applies_reroll_effect():\n-    \"\"\"Test confirming BOUNCING_ARROW applies RerollDiceEffect to active player's character\"\"\"\n+    \"\"\"Test confirming ABILITY_BOUNCING_ARROW applies RerollDiceEffect to active player's character\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=ARCHER),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_ARCHER),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     # Verify archer has no effects before\n-    assert len(game.players[\"player1\"].characters[ARCHER].effects) == 0\n+    assert len(game.players[\"player1\"].characters[CHARACTER_ARCHER].effects) == 0\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=BOUNCING_ARROW)\n+    updated_game = action.run(ability=ABILITY_BOUNCING_ARROW)\n \n     # Verify RerollDiceEffect was applied to the active player's archer\n-    archer = updated_game.players[\"player1\"].characters[ARCHER]\n+    archer = updated_game.players[\"player1\"].characters[CHARACTER_ARCHER]\n     assert len(archer.effects) == 1\n     assert isinstance(archer.effects[0], RerollDiceEffect)\n     assert archer.effects[0].name == REROLL_DICE\n@@ -247,16 +247,16 @@ def test_ability_select_action_mage():\n     \"\"\"Test confirming mage's ability selection transitions to ability_opponent_selection\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=ABILITY_SELECTION,\n-        active=ActivePlayer2(player=\"player1\", character=MAGE),\n+        stage=STAGE_ABILITY_SELECTION,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_MAGE),\n         players={\"player1\": Player(name=\"player1\", characters=characters)},\n     )\n \n     action = AbilitySelectAction(\"player1\", game)\n-    updated_game = action.run(ability=FREEZE)\n+    updated_game = action.run(ability=ABILITY_FREEZE)\n \n-    # FREEZE requires opponent selection (SkipTurnEffect), so go to ability_opponent_selection\n-    assert updated_game.stage == ABILITY_OPPONENT_SELECTION\n+    # ABILITY_FREEZE requires opponent selection (SkipTurnEffect), so go to ability_opponent_selection\n+    assert updated_game.stage == STAGE_ABILITY_STAGE_OPPONENT_SELECTION\n     assert updated_game.ability is not None\n-    assert updated_game.ability.name == FREEZE\n+    assert updated_game.ability.name == ABILITY_FREEZE\n     assert updated_game.stage_meta is None\ndiff --git a/server/gameplay/actions/test_stage_battle_dice_roll.py b/server/gameplay/actions/test_stage_battle_dice_roll.py\nindex bbc80fd..80e63ff 100644\n--- a/server/gameplay/actions/test_stage_battle_dice_roll.py\n+++ b/server/gameplay/actions/test_stage_battle_dice_roll.py\n@@ -19,11 +19,11 @@ from .stage_battle import (\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    ARCHER,\n-    MAGE,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_ARCHER,\n+    CHARACTER_MAGE,\n )\n-from ..abilities import BATTLE_HOWL, BOUNCING_ARROW, FREEZE\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_BOUNCING_ARROW, ABILITY_FREEZE\n from ..effects import (\n     AttackBonusEffect,\n     AttackNegBonusEffect,\n@@ -31,10 +31,10 @@ from ..effects import (\n     RerollDiceEffect,\n )\n from ..gameplay import (\n-    BATTLE_DICE_ROLL,\n-    BATTLE_END,\n-    CHARACTER_SELECT,\n-    OPPONENT_SELECTION,\n+    STAGE_BATTLE_DICE_ROLL,\n+    STAGE_BATTLE_END,\n+    STAGE_CHARACTER_SELECT,\n+    STAGE_OPPONENT_SELECTION,\n )\n from ..gameplay import (\n     GamePlay,\n@@ -60,9 +60,9 @@ def test_active_player_roll_action_valid():\n     \"\"\"Test active player successfully rolls dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -75,9 +75,9 @@ def test_active_player_roll_action_valid():\n     # Verify active player upgraded to ActivePlayer3 with dice_roll\n     assert isinstance(updated_game.active, ActivePlayer3)\n     assert updated_game.active.player == \"player1\"\n-    assert updated_game.active.character == KNIGHT\n+    assert updated_game.active.character == CHARACTER_KNIGHT\n     assert updated_game.active.dice_roll is not None\n-    assert len(updated_game.active.dice_roll) == characters[KNIGHT].dice\n+    assert len(updated_game.active.dice_roll) == characters[CHARACTER_KNIGHT].dice\n     assert all(1 <= d <= 6 for d in updated_game.active.dice_roll)\n \n     # Opponent should still be Opponent2 (hasn't rolled yet)\n@@ -88,9 +88,9 @@ def test_active_player_roll_triggers_winner_calculation():\n     \"\"\"Test that when active player rolls and opponent already rolled, winner is calculated\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -109,7 +109,7 @@ def test_active_player_roll_wrong_stage():\n     \"\"\"Test active player roll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -126,9 +126,9 @@ def test_active_player_roll_not_active_player():\n     \"\"\"Test active player roll fails when user is not the active player\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -145,9 +145,9 @@ def test_active_player_roll_player_not_in_game():\n     \"\"\"Test active player roll fails when player doesn't exist in game\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player2\": Player(name=\"player2\", characters=characters),\n         },\n@@ -163,7 +163,7 @@ def test_active_player_roll_no_character():\n     \"\"\"Test active player roll fails when no character selected\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n+        stage=STAGE_BATTLE_DICE_ROLL,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -185,9 +185,9 @@ def test_opponent_roll_action_valid():\n     \"\"\"Test opponent successfully rolls dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -200,9 +200,9 @@ def test_opponent_roll_action_valid():\n     # Verify opponent upgraded to Opponent3 with dice_roll\n     assert isinstance(updated_game.opponent, Opponent3)\n     assert updated_game.opponent.player == \"player2\"\n-    assert updated_game.opponent.character == MAGE\n+    assert updated_game.opponent.character == CHARACTER_MAGE\n     assert updated_game.opponent.dice_roll is not None\n-    assert len(updated_game.opponent.dice_roll) == characters[MAGE].dice\n+    assert len(updated_game.opponent.dice_roll) == characters[CHARACTER_MAGE].dice\n     assert all(1 <= d <= 6 for d in updated_game.opponent.dice_roll)\n \n     # Active player should still be ActivePlayer2 (hasn't rolled yet)\n@@ -213,9 +213,9 @@ def test_opponent_roll_triggers_winner_calculation():\n     \"\"\"Test that when opponent rolls and active already rolled, winner is calculated\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -234,7 +234,7 @@ def test_opponent_roll_wrong_stage():\n     \"\"\"Test opponent roll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -252,9 +252,9 @@ def test_opponent_roll_not_opponent():\n     \"\"\"Test opponent roll fails when user is not the opponent\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -271,8 +271,8 @@ def test_opponent_roll_no_opponent():\n     \"\"\"Test opponent roll fails when no opponent exists\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n         opponent=None,\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -298,7 +298,7 @@ def test_reroll_action_valid_draw():\n     game = get_debug_preset(\"battle_draw\")\n \n     # Verify initial state is a draw\n-    assert game.stage == BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n     assert isinstance(game.active, ActivePlayer4)\n     assert isinstance(game.opponent, Opponent4)\n     assert game.active.result.winner is False\n@@ -311,16 +311,16 @@ def test_reroll_action_valid_draw():\n     assert isinstance(updated_game.active, ActivePlayer2)\n     assert isinstance(updated_game.opponent, Opponent2)\n     assert updated_game.active.player == \"player1\"\n-    assert updated_game.active.character == KNIGHT\n+    assert updated_game.active.character == CHARACTER_KNIGHT\n     assert updated_game.opponent.player == \"player2\"\n-    assert updated_game.opponent.character == ARCHER\n+    assert updated_game.opponent.character == CHARACTER_ARCHER\n \n \n def test_reroll_action_wrong_stage():\n     \"\"\"Test reroll fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -347,9 +347,9 @@ def test_reroll_action_active_not_rolled():\n     \"\"\"Test reroll fails when active player hasn't rolled yet (not ActivePlayer4)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -367,9 +367,9 @@ def test_reroll_action_opponent_not_rolled():\n     \"\"\"Test reroll fails when opponent hasn't rolled yet (not Opponent4)\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -384,25 +384,25 @@ def test_reroll_action_opponent_not_rolled():\n \n \n def test_reroll_action_winner_exists():\n-    \"\"\"Test reroll fails when there's already a winner (stage is BATTLE_END)\"\"\"\n+    \"\"\"Test reroll fails when there's already a winner (stage is STAGE_BATTLE_END)\"\"\"\n     game = get_debug_preset(\"battle_player_1_win\")\n \n-    # Verify initial state has a winner and is in BATTLE_END stage\n+    # Verify initial state has a winner and is in STAGE_BATTLE_END stage\n     assert game.active.result.winner is True\n     assert game.opponent.result.winner is False\n-    assert game.stage == BATTLE_END\n+    assert game.stage == STAGE_BATTLE_END\n \n     action = RerollAction(\"player1\", game)\n \n-    # Should fail because stage is BATTLE_END, not BATTLE_DICE_ROLL\n+    # Should fail because stage is STAGE_BATTLE_END, not STAGE_BATTLE_DICE_ROLL\n     with pytest.raises(GameException, match=\"Cannot perform action in stage\"):\n         action.run()\n \n \n def test_reroll_action_winner_not_determined():\n     \"\"\"Test reroll fails when there's a winner (ActivePlayer4/Opponent4 with winner=True)\"\"\"\n-    # Use battle_player_1_win preset but keep stage as BATTLE_DICE_ROLL\n-    game = get_debug_preset(\"battle_player_1_win\", stage=BATTLE_DICE_ROLL)\n+    # Use battle_player_1_win preset but keep stage as STAGE_BATTLE_DICE_ROLL\n+    game = get_debug_preset(\"battle_player_1_win\", stage=STAGE_BATTLE_DICE_ROLL)\n \n     # Verify state: player1 won (knight dice=[6] + attack=1 = 7 > mage dice=[3] = 3)\n     assert isinstance(game.active, ActivePlayer4)\n@@ -458,12 +458,12 @@ def test_calculate_winner_draw():\n \n \n def test_set_winner_if_both_rolled_upgrades_to_player4():\n-    \"\"\"Test set_winner_if_both_rolled upgrades both players to Player4/Opponent4 and transitions to BATTLE_END\"\"\"\n+    \"\"\"Test set_winner_if_both_rolled upgrades both players to Player4/Opponent4 and transitions to STAGE_BATTLE_END\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -479,17 +479,17 @@ def test_set_winner_if_both_rolled_upgrades_to_player4():\n     assert game.opponent.result.winner is False\n     assert game.active.result.score == 7\n     assert game.opponent.result.score == 3\n-    # Verify stage transitioned to BATTLE_END\n-    assert game.stage == BATTLE_END\n+    # Verify stage transitioned to STAGE_BATTLE_END\n+    assert game.stage == STAGE_BATTLE_END\n \n \n def test_set_winner_if_both_rolled_does_nothing_when_not_both_rolled():\n     \"\"\"Test set_winner_if_both_rolled does nothing when only one player rolled\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -512,9 +512,9 @@ def test_debug_set_battle_dice_rolls_valid():\n     \"\"\"Test debug action successfully sets dice rolls and recalculates winner\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -545,9 +545,9 @@ def test_debug_set_battle_dice_rolls_creates_draw():\n     \"\"\"Test debug action can create a draw scenario\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=ARCHER, dice_roll=[1]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_ARCHER, dice_roll=[1]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -573,7 +573,7 @@ def test_debug_set_battle_dice_rolls_wrong_stage():\n     \"\"\"Test debug action fails in wrong stage\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=CHARACTER_SELECT,\n+        stage=STAGE_CHARACTER_SELECT,\n         active=ActivePlayer1(player=\"player1\"),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n@@ -589,9 +589,9 @@ def test_debug_set_battle_dice_rolls_active_not_rolled():\n     \"\"\"Test debug action fails when active player hasn't rolled yet\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer2(player=\"player1\", character=KNIGHT),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[3]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer2(player=\"player1\", character=CHARACTER_KNIGHT),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[3]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -607,9 +607,9 @@ def test_debug_set_battle_dice_rolls_opponent_not_rolled():\n     \"\"\"Test debug action fails when opponent hasn't rolled yet\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[6]),\n-        opponent=Opponent2(player=\"player2\", character=MAGE),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[6]),\n+        opponent=Opponent2(player=\"player2\", character=CHARACTER_MAGE),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -625,9 +625,9 @@ def test_debug_set_battle_dice_rolls_invalid_dice_count():\n     \"\"\"Test debug action fails when dice count doesn't match character dice\"\"\"\n     characters = init_characters()\n     game = GamePlay(\n-        stage=BATTLE_DICE_ROLL,\n-        active=ActivePlayer3(player=\"player1\", character=KNIGHT, dice_roll=[1]),\n-        opponent=Opponent3(player=\"player2\", character=MAGE, dice_roll=[6]),\n+        stage=STAGE_BATTLE_DICE_ROLL,\n+        active=ActivePlayer3(player=\"player1\", character=CHARACTER_KNIGHT, dice_roll=[1]),\n+        opponent=Opponent3(player=\"player2\", character=CHARACTER_MAGE, dice_roll=[6]),\n         players={\n             \"player1\": Player(name=\"player1\", characters=characters),\n             \"player2\": Player(name=\"player2\", characters=characters),\n@@ -659,9 +659,9 @@ def test_reroll_effect_action():\n     # - Second RerollDiceEffect (to test all are removed)\n     # - AttackBonusEffect and SkipTurnEffect (to test other effects are preserved)\n     active_character = game.players[game.active.player].characters[game.active.character]\n-    active_character.effects.append(RerollDiceEffect(source=BOUNCING_ARROW))\n-    active_character.effects.append(AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2))\n-    active_character.effects.append(SkipTurnEffect(source=FREEZE))\n+    active_character.effects.append(RerollDiceEffect(source=ABILITY_BOUNCING_ARROW))\n+    active_character.effects.append(AttackBonusEffect(source=ABILITY_BATTLE_HOWL, attack_bonus=2))\n+    active_character.effects.append(SkipTurnEffect(source=ABILITY_FREEZE))\n \n     # Verify initial state: 4 effects total (1 original + 3 added)\n     assert len(active_character.effects) == 4\n@@ -671,12 +671,12 @@ def test_reroll_effect_action():\n \n     # Verify preset created game state as ActivePlayer4/Opponent4 (both rolled, winner calculated)\n     # Archer lost: dice=[2] = 2 < mage dice=[5] = 5\n-    # Stage stays BATTLE_DICE_ROLL because loser has reroll effect available\n+    # Stage stays STAGE_BATTLE_DICE_ROLL because loser has reroll effect available\n     assert isinstance(game.active, ActivePlayer4)\n     assert isinstance(game.opponent, Opponent4)\n     assert game.active.result.winner is False\n     assert game.opponent.result.winner is True\n-    assert game.stage == BATTLE_DICE_ROLL\n+    assert game.stage == STAGE_BATTLE_DICE_ROLL\n \n     # Perform reroll using RerollEffectAction\n     action = RerollEffectAction(\"player1\", game)\ndiff --git a/server/gameplay/actions/test_stage_battle_end.py b/server/gameplay/actions/test_stage_battle_end.py\nindex 996f74f..53362bc 100644\n--- a/server/gameplay/actions/test_stage_battle_end.py\n+++ b/server/gameplay/actions/test_stage_battle_end.py\n@@ -16,12 +16,12 @@ from .battle_end import BattleEndAction\n from ..common import (\n     GameException,\n     ReportedException,\n-    KNIGHT,\n-    MAGE,\n-    ARCHER,\n+    CHARACTER_KNIGHT,\n+    CHARACTER_MAGE,\n+    CHARACTER_ARCHER,\n )\n-from ..abilities import BATTLE_HOWL, FREEZE, BOUNCING_ARROW\n-from ..gameplay import BATTLE_END, CHARACTER_SELECT\n+from ..abilities import ABILITY_BATTLE_HOWL, ABILITY_FREEZE, ABILITY_BOUNCING_ARROW\n+from ..gameplay import STAGE_BATTLE_END, STAGE_CHARACTER_SELECT\n from ..effects import AttackNegBonusEffect, SkipTurnEffect, RerollDiceEffect\n from ..gameplay import (\n     GamePlay,\n@@ -39,20 +39,20 @@ def test_battle_end_clears_battle_effects():\n     characters2 = init_characters()\n \n     # Add BattleEffect to both characters\n-    characters1[KNIGHT].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-2))\n-    characters2[MAGE].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-1))\n+    characters1[CHARACTER_KNIGHT].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-2))\n+    characters2[CHARACTER_MAGE].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-1))\n \n     game = GamePlay(\n-        stage=BATTLE_END,\n+        stage=STAGE_BATTLE_END,\n         active=ActivePlayer4(\n             player=\"player1\",\n-            character=KNIGHT,\n+            character=CHARACTER_KNIGHT,\n             dice_roll=[6],\n             result=BattleResult(winner=True, score=7)\n         ),\n         opponent=Opponent4(\n             player=\"player2\",\n-            character=MAGE,\n+            character=CHARACTER_MAGE,\n             dice_roll=[5],\n             result=BattleResult(winner=False, score=5)\n         ),\n@@ -63,19 +63,19 @@ def test_battle_end_clears_battle_effects():\n     )\n \n     # Verify effects exist before battle end\n-    assert len(game.players[\"player1\"].characters[KNIGHT].effects) == 1\n-    assert len(game.players[\"player2\"].characters[MAGE].effects) == 1\n+    assert len(game.players[\"player1\"].characters[CHARACTER_KNIGHT].effects) == 1\n+    assert len(game.players[\"player2\"].characters[CHARACTER_MAGE].effects) == 1\n \n     # Execute battle end action\n     action = BattleEndAction(\"player1\", game)\n     updated_game = action.run()\n \n     # Verify BattleEffects are cleared from both characters\n-    assert len(updated_game.players[\"player1\"].characters[KNIGHT].effects) == 0\n-    assert len(updated_game.players[\"player2\"].characters[MAGE].effects) == 0\n+    assert len(updated_game.players[\"player1\"].characters[CHARACTER_KNIGHT].effects) == 0\n+    assert len(updated_game.players[\"player2\"].characters[CHARACTER_MAGE].effects) == 0\n \n     # Verify game transitioned to next turn\n-    assert updated_game.stage == CHARACTER_SELECT\n+    assert updated_game.stage == STAGE_CHARACTER_SELECT\n     assert updated_game.active.player == \"player2\"  # Next player's turn\n \n \n@@ -85,22 +85,22 @@ def test_battle_end_disposes_reroll_effect():\n     characters2 = init_characters()\n \n     # Add RerollDiceEffect to active player\n-    characters1[ARCHER].effects.append(RerollDiceEffect(source=BOUNCING_ARROW, reroll_dice=True))\n+    characters1[CHARACTER_ARCHER].effects.append(RerollDiceEffect(source=ABILITY_BOUNCING_ARROW, reroll_dice=True))\n \n     # Add BattleEffect to opponent\n-    characters2[KNIGHT].effects.append(AttackNegBonusEffect(source=BATTLE_HOWL, attack_neg_bonus=-2))\n+    characters2[CHARACTER_KNIGHT].effects.append(AttackNegBonusEffect(source=ABILITY_BATTLE_HOWL, attack_neg_bonus=-2))\n \n     game = GamePlay(\n-        stage=BATTLE_END,\n+        stage=STAGE_BATTLE_END,\n         active=ActivePlayer4(\n             player=\"player1\",\n-            character=ARCHER,\n+            character=CHARACTER_ARCHER,\n             dice_roll=[6],\n             result=BattleResult(winner=True, score=7)\n         ),\n         opponent=Opponent4(\n             player=\"player2\",\n-            character=KNIGHT,\n+            character=CHARACTER_KNIGHT,\n             dice_roll=[5],\n             result=BattleResult(winner=False, score=5)\n         ),\n@@ -111,18 +111,18 "
        },
        "id": "mobile-landscape",
        "name": "mobile-landscape",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "shard": null,
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.55.1",
    "workers": 1,
    "webServer": null
  },
  "suites": [],
  "errors": [
    {
      "message": "Error: Process from config.webServer was not able to start. Exit code: 1",
      "stack": "Error: Process from config.webServer was not able to start. Exit code: 1"
    }
  ],
  "stats": {
    "startTime": "2026-01-22T19:41:31.920Z",
    "duration": 5128.549,
    "expected": 0,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}