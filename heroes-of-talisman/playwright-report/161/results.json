{
  "config": {
    "configFile": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/playwright.config.js",
    "rootDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
    "forbidOnly": false,
    "fullyParallel": true,
    "globalSetup": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-setup.js",
    "globalTeardown": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e/global-teardown.js",
    "globalTimeout": 0,
    "grep": {},
    "grepInvert": null,
    "maxFailures": 0,
    "metadata": {
      "ci": {
        "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/7d8f37382697c6e10db68b8e0b5a26936e4eef15",
        "commitHash": "7d8f37382697c6e10db68b8e0b5a26936e4eef15",
        "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/32",
        "prTitle": "claude/refactor-models-split-x1B0p",
        "prBaseHash": "7b34bb9c3140eefd84c9de32797c3a0b1d144776",
        "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21110613059"
      },
      "gitCommit": {
        "shortHash": "7d8f373",
        "hash": "7d8f37382697c6e10db68b8e0b5a26936e4eef15",
        "subject": "Merge 0d43da1bbdb3c7da57138b2154919e09b3087f80 into 7b34bb9c3140eefd84c9de32797c3a0b1d144776",
        "body": "Merge 0d43da1bbdb3c7da57138b2154919e09b3087f80 into 7b34bb9c3140eefd84c9de32797c3a0b1d144776\n",
        "author": {
          "name": "mark kolodkin",
          "email": "mark.kolodkin@gmail.com",
          "time": 1768734007000
        },
        "committer": {
          "name": "GitHub",
          "email": "noreply@github.com",
          "time": 1768734007000
        },
        "branch": "HEAD"
      },
      "gitDiff": "diff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nnew file mode 100644\nindex 0000000..0064a3a\n--- /dev/null\n+++ b/server/gameplay/abilities.py\n@@ -0,0 +1,50 @@\n+from __future__ import annotations\n+\n+from pydantic import Field\n+\n+from .gameplay import (\n+    StrictModel,\n+    AbilityName,\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    APPLY_TO_SELECTED_OPPONENT,\n+)\n+from .effects import (\n+    EffectUnion,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    SkipTurnEffect,\n+)\n+\n+\n+class Ability(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n+\n+    @property\n+    def requires_opponent_selection(self) -> bool:\n+        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n+        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n+\n+\n+ABILITIES_MAP: dict[AbilityName, Ability] = {\n+    BATTLE_HOWL: Ability(\n+        name=BATTLE_HOWL,\n+        effects=[\n+            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+        ],\n+    ),\n+    BOUNCING_ARROW: Ability(\n+        name=BOUNCING_ARROW,\n+        effects=[\n+            RerollDiceEffect(source=BOUNCING_ARROW),\n+        ],\n+    ),\n+    FREEZE: Ability(\n+        name=FREEZE,\n+        effects=[\n+            SkipTurnEffect(source=FREEZE),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nnew file mode 100644\nindex 0000000..6b13dc5\n--- /dev/null\n+++ b/server/gameplay/effects.py\n@@ -0,0 +1,141 @@\n+from __future__ import annotations\n+\n+from typing import Literal, Annotated, Union, Self\n+\n+from pydantic import Field, model_validator\n+\n+from .gameplay import (\n+    StrictModel,\n+    AbilityName,\n+    ActionName,\n+    ApplyToTarget,\n+    # Effect name constants\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Action name constants for dispose_actions\n+    CHARACTER_SELECT_ACTION,\n+    BATTLE_END_ACTION,\n+    ACTION_REROLL_EFFECT,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+    APPLY_TO_BATTLE_OPPONENT,\n+    APPLY_TO_SELECTED_OPPONENT,\n+    # Ability name constants for source validation\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    # Source map\n+    EFFECTS_SOURCE_ABILITY_MAP,\n+)\n+\n+\n+class Effect(StrictModel):\n+    \"\"\"\n+    Base class for all effects.\n+    Each effect specifies when it should be disposed via dispose_actions field.\n+    Each effect specifies who receives the effect via apply_to field.\n+    \"\"\"\n+\n+    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n+    source: AbilityName\n+    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n+    apply_to: ApplyToTarget  # Who receives this effect\n+\n+    @model_validator(mode=\"after\")\n+    def validate_source(self) -> Self:\n+        \"\"\"Validate that source is valid for this effect type\"\"\"\n+        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        if self.source not in valid_sources and len(valid_sources) > 0:\n+            raise ValueError(\n+                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n+                f\"Valid sources: {valid_sources}\"\n+            )\n+        return self\n+\n+\n+class SkipTurnEffect(Effect):\n+    \"\"\"\n+    Character can't participate in the next turn.\n+    Disposed after character selection.\n+    Applied to selected opponent (requires ability_opponent_selection stage).\n+    \"\"\"\n+\n+    name: Literal[SKIP_TURN] = SKIP_TURN\n+    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n+    skip_next_turn: bool = True\n+\n+\n+class AttackBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is increased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    attack_bonus: int\n+\n+\n+class RerollDiceEffect(Effect):\n+    \"\"\"\n+    Character's dice are rerolled if lost the battle.\n+    Disposed at battle end or when the reroll effect action is used.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[REROLL_DICE] = REROLL_DICE\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    reroll_dice: bool = True\n+\n+\n+class AttackNegBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is decreased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to battle opponent (no separate selection required).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n+    attack_neg_bonus: int\n+\n+\n+class DrawCardEffect(Effect):\n+    \"\"\"\n+    Character draws cards at the start of battle.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DRAW_CARD] = DRAW_CARD\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    draw_count: int = 1\n+\n+\n+# Define EffectUnion for discriminated union of all effect types (without base classes)\n+EffectUnion = Annotated[\n+    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Field(discriminator=\"name\"),\n+]\n+\n+\n+class EffectTotal(StrictModel):\n+    \"\"\"\n+    Aggregated effect totals for a character.\n+    Combines all active effects into a single summary.\n+    \"\"\"\n+\n+    attack_bonus: int = 0\n+    attack_neg_bonus: int = 0\n+    skip_next_turn: bool = False\n+    reroll_dice_available: bool = False\n+    draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nnew file mode 100644\nindex 0000000..22f8224\n--- /dev/null\n+++ b/server/gameplay/gameplay.py\n@@ -0,0 +1,419 @@\n+from __future__ import annotations\n+\n+from typing import Dict, Optional, Literal\n+\n+from pydantic import BaseModel, ConfigDict, Field, computed_field\n+\n+########################################################\n+# Connection statuses\n+########################################################\n+CONNECTED = \"connected\"\n+DISCONNECTED = \"disconnected\"\n+CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n+ConnectionStatus = Literal[*CONNECTION_STATUSES]\n+\n+########################################################\n+# Stages\n+########################################################\n+CHARACTER_SELECT = \"character_select\"\n+ABILITY_SELECTION = \"ability_selection\"\n+ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n+OPPONENT_SELECTION = \"opponent_selection\"\n+BATTLE_DICE_ROLL = \"battle_dice_roll\"\n+BATTLE_END = \"battle_end\"\n+STAGES_NAMES = [\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+]\n+StageName = Literal[*STAGES_NAMES]\n+\n+########################################################\n+# Character types\n+########################################################\n+KNIGHT = \"knight\"\n+ARCHER = \"archer\"\n+MAGE = \"mage\"\n+CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n+ChatacterType = Literal[*CHARACTER_TYPES]\n+\n+BATTLE_HOWL = \"battle_howl\"\n+BOUNCING_ARROW = \"bouncing_arrow\"\n+FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+AbilityName = Literal[*ABILITIES_NAMES]\n+\n+# Effect names\n+ATTACK_BONUS = \"attack_bonus\"\n+ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+REROLL_DICE = \"reroll_dice\"\n+SKIP_TURN = \"skip_turn\"\n+DRAW_CARD = \"draw_card\"\n+\n+# Effect apply_to targets - specifies who receives the effect\n+APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n+APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n+APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n+\n+APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n+ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n+\n+# Effect-to-Source mapping: defines which abilities can create which effects\n+# This is used for validation to ensure effects have valid source abilities\n+EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n+    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n+    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n+    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n+    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+}\n+\n+########################################################\n+# Actions\n+########################################################\n+CONNECT = \"connect\"\n+LEAVE = \"leave\"\n+DISCONNECT = \"disconnect\"\n+CHARACTER_PRESS = \"character_press\"\n+CHARACTER_SELECT_ACTION = \"character_select\"\n+ABILITY_PRESS = \"ability_press\"\n+ABILITY_SELECT = \"ability_select\"\n+ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n+ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n+OPPONENT_PRESS = \"opponent_press\"\n+OPPONENT_SELECT = \"opponent_select\"\n+ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n+OPPONENT_ROLL = \"opponent_roll\"\n+ACTION_REROLL = \"action_reroll\"\n+ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n+BATTLE_END_ACTION = \"battle_end\"\n+DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n+\n+ACTION_NAMES = [\n+    CONNECT,\n+    LEAVE,\n+    DISCONNECT,\n+    CHARACTER_PRESS,\n+    CHARACTER_SELECT_ACTION,\n+    ABILITY_PRESS,\n+    ABILITY_SELECT,\n+    ABILITY_OPPONENT_PRESS,\n+    ABILITY_OPPONENT_SELECT,\n+    OPPONENT_PRESS,\n+    OPPONENT_SELECT,\n+    ACTIVE_PLAYER_ROLL,\n+    OPPONENT_ROLL,\n+    ACTION_REROLL,\n+    ACTION_REROLL_EFFECT,\n+    BATTLE_END_ACTION,\n+    DEBUG_SET_BATTLE_DICE_ROLLS,\n+]\n+ActionName = Literal[*ACTION_NAMES]\n+\n+\n+class GameException(Exception):\n+    pass\n+\n+\n+class ReportedException(GameException):\n+    pass\n+\n+\n+def recursive_db_model_dump(model: BaseModel) -> dict:\n+    \"\"\"\n+    Recursively dump model for database storage.\n+    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n+    \"\"\"\n+    result = {}\n+\n+    # Iterate over all fields and their values\n+    for field_name, field_value in model:\n+        if isinstance(field_value, BaseModel):\n+            # Nested model - call its db_model_dump if it's a StrictModel\n+            if hasattr(field_value, \"db_model_dump\"):\n+                result[field_name] = field_value.db_model_dump()\n+            else:\n+                result[field_name] = field_value.model_dump()\n+        elif isinstance(field_value, dict):\n+            # Dict of values (possibly models)\n+            result[field_name] = {\n+                k: (\n+                    v.db_model_dump()\n+                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n+                    else v.model_dump() if isinstance(v, BaseModel) else v\n+                )\n+                for k, v in field_value.items()\n+            }\n+        elif isinstance(field_value, (list, tuple, set)):\n+            # Collection of values (possibly models) - preserve collection type\n+            processed_items = [\n+                (\n+                    item.db_model_dump()\n+                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n+                    else item.model_dump() if isinstance(item, BaseModel) else item\n+                )\n+                for item in field_value\n+            ]\n+            # Preserve the original collection type\n+            result[field_name] = type(field_value)(processed_items)\n+        else:\n+            # Primitive value\n+            result[field_name] = field_value\n+\n+    return result\n+\n+\n+class StrictModel(BaseModel):\n+    model_config = ConfigDict(extra=\"forbid\")\n+\n+    def db_model_dump(self) -> dict:\n+        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n+        return recursive_db_model_dump(self)\n+\n+\n+class Character(StrictModel):\n+\n+    level: int\n+    health: int\n+    max_health: int\n+    dice: int\n+    attack: int\n+    abilities: list[Ability] = Field(default_factory=list)\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+    @computed_field\n+    @property\n+    def is_alive(self) -> bool:\n+        \"\"\"Character is alive if health > 0\"\"\"\n+        return self.health > 0\n+\n+    @computed_field\n+    @property\n+    def effect(self) -> EffectTotal:\n+        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n+        from .effects import (\n+            EffectTotal,\n+            AttackBonusEffect,\n+            AttackNegBonusEffect,\n+            SkipTurnEffect,\n+            RerollDiceEffect,\n+            DrawCardEffect,\n+        )\n+\n+        total = EffectTotal()\n+\n+        for eff in self.effects:\n+            if isinstance(eff, AttackBonusEffect):\n+                total.attack_bonus += eff.attack_bonus\n+            elif isinstance(eff, AttackNegBonusEffect):\n+                total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, SkipTurnEffect):\n+                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n+            elif isinstance(eff, RerollDiceEffect):\n+                total.reroll_dice_available = True\n+            elif isinstance(eff, DrawCardEffect):\n+                total.draw_card_count += eff.draw_count\n+\n+        return total\n+\n+    def db_model_dump(self) -> dict:\n+        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n+\n+\n+class CharacterSelectMeta(StrictModel):\n+    \"\"\"Stage metadata for character selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted character\n+\n+\n+class AbilitySelectMeta(StrictModel):\n+    \"\"\"Stage metadata for ability selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted ability\n+\n+\n+class ActivePlayer1(StrictModel):\n+    \"\"\"Selected character for battle\"\"\"\n+\n+    player: str  # Character name\n+\n+\n+class BattleResult(StrictModel):\n+    winner: bool\n+    score: int  # result of the battle, sum of dice_roll and attack\n+\n+\n+class ActivePlayer2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class ActivePlayer3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class ActivePlayer4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n+\n+\n+class Opponent2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class Opponent3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class Opponent4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+Opponent = Opponent2 | Opponent3 | Opponent4\n+\n+\n+class Player(StrictModel):\n+    name: str\n+    status: ConnectionStatus = CONNECTED\n+    cards: list[str] = Field(default_factory=list)\n+    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n+\n+\n+########################################################\n+# GamePlay model\n+########################################################\n+class GamePlay(StrictModel):\n+    stage: StageName = CHARACTER_SELECT\n+    players: dict[str, Player] = Field(default_factory=dict)\n+    active: Optional[ActivePlayer] = None  # The active player and its selections\n+    ability: Optional[Ability] = None  # Selected ability\n+    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n+    opponent: Optional[Opponent] = None  # Selected opponent for battle\n+    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+\n+    def reorder_players(self, username: str):\n+        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n+        if username not in self.players:\n+            return\n+\n+        # Get all player keys\n+        player_keys = list(self.players.keys())\n+\n+        # Find the index of the username\n+        user_index = player_keys.index(username)\n+\n+        # Circular shift: username first, then the rest\n+        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n+\n+        # Build new dict with reordered keys\n+        reordered_dict = {key: self.players[key] for key in reordered_keys}\n+\n+        # Update in-place\n+        self.players.clear()\n+        self.players.update(reordered_dict)\n+\n+\n+DEFAULT_GAME = GamePlay()\n+\n+KNIGHT_L1_DEFAULT_HEALTH = 2\n+KNIGHT_L1_MAX_HEALTH = 2\n+KNIGHT_L1_DICE = 1\n+KNIGHT_L1_ATTACK = 1\n+KNIGHT_L1_ABILITY = BATTLE_HOWL\n+\n+ARCHER_L1_DEFAULT_HEALTH = 3\n+ARCHER_L1_MAX_HEALTH = 3\n+ARCHER_L1_DICE = 1\n+ARCHER_L1_ATTACK = 0\n+ARCHER_L1_ABILITY = BOUNCING_ARROW\n+\n+MAGE_L1_DEFAULT_HEALTH = 2\n+MAGE_L1_MAX_HEALTH = 2\n+MAGE_L1_DICE = 1\n+MAGE_L1_ATTACK = 0\n+MAGE_L1_ABILITY = FREEZE\n+\n+def get_character_default_stats() -> dict:\n+    \"\"\"Get character default stats with abilities. Uses lazy import to avoid circular dependency.\"\"\"\n+    from .abilities import ABILITIES_MAP\n+\n+    return {\n+        \"knight\": {\n+            \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n+            \"max_health\": KNIGHT_L1_MAX_HEALTH,\n+            \"dice\": KNIGHT_L1_DICE,\n+            \"attack\": KNIGHT_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n+        },\n+        \"archer\": {\n+            \"health\": ARCHER_L1_DEFAULT_HEALTH,\n+            \"max_health\": ARCHER_L1_MAX_HEALTH,\n+            \"dice\": ARCHER_L1_DICE,\n+            \"attack\": ARCHER_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n+        },\n+        \"mage\": {\n+            \"health\": MAGE_L1_DEFAULT_HEALTH,\n+            \"max_health\": MAGE_L1_MAX_HEALTH,\n+            \"dice\": MAGE_L1_DICE,\n+            \"attack\": MAGE_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n+        },\n+    }\n+\n+\n+# Lazy-evaluated CHARACTER_DEFAULT_STATS for backwards compatibility\n+_CHARACTER_DEFAULT_STATS = None\n+\n+\n+def _get_cached_character_default_stats():\n+    global _CHARACTER_DEFAULT_STATS\n+    if _CHARACTER_DEFAULT_STATS is None:\n+        _CHARACTER_DEFAULT_STATS = get_character_default_stats()\n+    return _CHARACTER_DEFAULT_STATS\n+\n+\n+# Property-like access for CHARACTER_DEFAULT_STATS\n+class _CharacterDefaultStatsProxy:\n+    def __getitem__(self, key):\n+        return _get_cached_character_default_stats()[key]\n+\n+    def __iter__(self):\n+        return iter(_get_cached_character_default_stats())\n+\n+    def items(self):\n+        return _get_cached_character_default_stats().items()\n+\n+    def keys(self):\n+        return _get_cached_character_default_stats().keys()\n+\n+    def values(self):\n+        return _get_cached_character_default_stats().values()\n+\n+\n+CHARACTER_DEFAULT_STATS = _CharacterDefaultStatsProxy()\n+\n+\n+def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n+    \"\"\"Initialize all character types with default stats\"\"\"\n+    stats = get_character_default_stats()\n+    return {\n+        char_type: Character(level=level, **stats[char_type])\n+        for char_type in [KNIGHT, ARCHER, MAGE]\n+    }\ndiff --git a/server/gameplay/models.py b/server/gameplay/models.py\nindex d8a1106..7aa309e 100644\n--- a/server/gameplay/models.py\n+++ b/server/gameplay/models.py\n@@ -1,96 +1,69 @@\n-from typing import Dict, Optional, Literal, Annotated, Union, Self\n-\n-from pydantic import BaseModel, ConfigDict, Field, computed_field, Discriminator, model_validator\n-\n-########################################################\n-# Connection statuses\n-########################################################\n-CONNECTED = \"connected\"\n-DISCONNECTED = \"disconnected\"\n-CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n-ConnectionStatus = Literal[*CONNECTION_STATUSES]\n-\n-########################################################\n-# Stages\n-########################################################\n-CHARACTER_SELECT = \"character_select\"\n-ABILITY_SELECTION = \"ability_selection\"\n-ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n-OPPONENT_SELECTION = \"opponent_selection\"\n-BATTLE_DICE_ROLL = \"battle_dice_roll\"\n-BATTLE_END = \"battle_end\"\n-STAGES_NAMES = [\n+\"\"\"\n+Backwards compatibility - re-exports from split modules.\n+Import directly from effects, abilities, or gameplay for new code.\n+\"\"\"\n+\n+# Re-export from effects\n+from .effects import (\n+    Effect,\n+    SkipTurnEffect,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    AttackNegBonusEffect,\n+    DrawCardEffect,\n+    EffectUnion,\n+    EffectTotal,\n+)\n+\n+# Re-export from abilities\n+from .abilities import (\n+    Ability,\n+    ABILITIES_MAP,\n+)\n+\n+# Re-export from gameplay (everything else)\n+from .gameplay import (\n+    # Connection statuses\n+    CONNECTED,\n+    DISCONNECTED,\n+    CONNECTION_STATUSES,\n+    ConnectionStatus,\n+    # Stages\n     CHARACTER_SELECT,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n     BATTLE_DICE_ROLL,\n     BATTLE_END,\n-]\n-StageName = Literal[*STAGES_NAMES]\n-\n-########################################################\n-# Character types\n-########################################################\n-KNIGHT = \"knight\"\n-ARCHER = \"archer\"\n-MAGE = \"mage\"\n-CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n-ChatacterType = Literal[*CHARACTER_TYPES]\n-\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n-AbilityName = Literal[*ABILITIES_NAMES]\n-\n-# Effect names\n-ATTACK_BONUS = \"attack_bonus\"\n-ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n-REROLL_DICE = \"reroll_dice\"\n-SKIP_TURN = \"skip_turn\"\n-DRAW_CARD = \"draw_card\"\n-\n-# Effect apply_to targets - specifies who receives the effect\n-APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n-APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n-APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n-\n-APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n-ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n-\n-# Effect-to-Source mapping: defines which abilities can create which effects\n-# This is used for validation to ensure effects have valid source abilities\n-EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n-}\n-\n-########################################################\n-# Actions\n-########################################################\n-CONNECT = \"connect\"\n-LEAVE = \"leave\"\n-DISCONNECT = \"disconnect\"\n-CHARACTER_PRESS = \"character_press\"\n-CHARACTER_SELECT_ACTION = \"character_select\"\n-ABILITY_PRESS = \"ability_press\"\n-ABILITY_SELECT = \"ability_select\"\n-ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n-ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n-OPPONENT_PRESS = \"opponent_press\"\n-OPPONENT_SELECT = \"opponent_select\"\n-ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n-OPPONENT_ROLL = \"opponent_roll\"\n-ACTION_REROLL = \"action_reroll\"\n-ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n-BATTLE_END_ACTION = \"battle_end\"\n-DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n-\n-ACTION_NAMES = [\n+    STAGES_NAMES,\n+    StageName,\n+    # Character types\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+    CHARACTER_TYPES,\n+    ChatacterType,\n+    # Ability names\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    ABILITIES_NAMES,\n+    AbilityName,\n+    # Effect names\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Apply to targets\n+    APPLY_TO_SELF,\n+    APPLY_TO_BATTLE_OPPONENT,\n+    APPLY_TO_SELECTED_OPPONENT,\n+    APPLY_TO_TARGETS,\n+    ApplyToTarget,\n+    # Effect source map\n+    EFFECTS_SOURCE_ABILITY_MAP,\n+    # Actions\n     CONNECT,\n     LEAVE,\n     DISCONNECT,\n@@ -108,405 +81,47 @@ ACTION_NAMES = [\n     ACTION_REROLL_EFFECT,\n     BATTLE_END_ACTION,\n     DEBUG_SET_BATTLE_DICE_ROLLS,\n-]\n-ActionName = Literal[*ACTION_NAMES]\n-\n-\n-class GameException(Exception):\n-    pass\n-\n-\n-class ReportedException(GameException):\n-    pass\n-\n-\n-def recursive_db_model_dump(model: BaseModel) -> dict:\n-    \"\"\"\n-    Recursively dump model for database storage.\n-    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n-    \"\"\"\n-    result = {}\n-\n-    # Iterate over all fields and their values\n-    for field_name, field_value in model:\n-        if isinstance(field_value, BaseModel):\n-            # Nested model - call its db_model_dump if it's a StrictModel\n-            if hasattr(field_value, \"db_model_dump\"):\n-                result[field_name] = field_value.db_model_dump()\n-            else:\n-                result[field_name] = field_value.model_dump()\n-        elif isinstance(field_value, dict):\n-            # Dict of values (possibly models)\n-            result[field_name] = {\n-                k: (\n-                    v.db_model_dump()\n-                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n-                    else v.model_dump() if isinstance(v, BaseModel) else v\n-                )\n-                for k, v in field_value.items()\n-            }\n-        elif isinstance(field_value, (list, tuple, set)):\n-            # Collection of values (possibly models) - preserve collection type\n-            processed_items = [\n-                (\n-                    item.db_model_dump()\n-                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n-                    else item.model_dump() if isinstance(item, BaseModel) else item\n-                )\n-                for item in field_value\n-            ]\n-            # Preserve the original collection type\n-            result[field_name] = type(field_value)(processed_items)\n-        else:\n-            # Primitive value\n-            result[field_name] = field_value\n-\n-    return result\n-\n-\n-class StrictModel(BaseModel):\n-    model_config = ConfigDict(extra=\"forbid\")\n-\n-    def db_model_dump(self) -> dict:\n-        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n-        return recursive_db_model_dump(self)\n-\n-\n-class Effect(StrictModel):\n-    \"\"\"\n-    Base class for all effects.\n-    Each effect specifies when it should be disposed via dispose_actions field.\n-    Each effect specifies who receives the effect via apply_to field.\n-    \"\"\"\n-\n-    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n-    source: AbilityName\n-    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n-    apply_to: ApplyToTarget  # Who receives this effect\n-\n-    @model_validator(mode=\"after\")\n-    def validate_source(self) -> Self:\n-        \"\"\"Validate that source is valid for this effect type\"\"\"\n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n-        if self.source not in valid_sources and len(valid_sources) > 0:\n-            raise ValueError(\n-                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n-                f\"Valid sources: {valid_sources}\"\n-            )\n-        return self\n-\n-\n-class SkipTurnEffect(Effect):\n-    \"\"\"\n-    Character can't participate in the next turn.\n-    Disposed after character selection.\n-    Applied to selected opponent (requires ability_opponent_selection stage).\n-    \"\"\"\n-\n-    name: Literal[SKIP_TURN] = SKIP_TURN\n-    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n-    skip_next_turn: bool = True\n-\n-\n-class AttackBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is increased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    attack_bonus: int\n-\n-\n-class RerollDiceEffect(Effect):\n-    \"\"\"\n-    Character's dice are rerolled if lost the battle.\n-    Disposed at battle end or when the reroll effect action is used.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[REROLL_DICE] = REROLL_DICE\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    reroll_dice: bool = True\n-\n-\n-class AttackNegBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is decreased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to battle opponent (no separate selection required).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n-    attack_neg_bonus: int\n-\n-\n-class DrawCardEffect(Effect):\n-    \"\"\"\n-    Character draws cards at the start of battle.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[DRAW_CARD] = DRAW_CARD\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    draw_count: int = 1\n-\n-\n-# Define EffectUnion for discriminated union of all effect types (without base classes)\n-EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n-    Field(discriminator=\"name\"),\n-]\n-\n-\n-class Ability(StrictModel):\n-    name: str\n-    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n-\n-    @property\n-    def requires_opponent_selection(self) -> bool:\n-        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n-        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n-\n-\n-class EffectTotal(StrictModel):\n-    \"\"\"\n-    Aggregated effect totals for a character.\n-    Combines all active effects into a single summary.\n-    \"\"\"\n-\n-    attack_bonus: int = 0\n-    attack_neg_bonus: int = 0\n-    skip_next_turn: bool = False\n-    reroll_dice_available: bool = False\n-    draw_card_count: int = 0\n-\n-\n-ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n-        effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n-        ],\n-    ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n-        effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n-        ],\n-    ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n-        effects=[\n-            SkipTurnEffect(source=FREEZE),\n-        ],\n-    ),\n-}\n-\n-\n-class Character(StrictModel):\n-\n-    level: int\n-    health: int\n-    max_health: int\n-    dice: int\n-    attack: int\n-    abilities: list[Ability] = Field(default_factory=list)\n-    effects: list[EffectUnion] = Field(default_factory=list)\n-\n-    @computed_field\n-    @property\n-    def is_alive(self) -> bool:\n-        \"\"\"Character is alive if health > 0\"\"\"\n-        return self.health > 0\n-\n-    @computed_field\n-    @property\n-    def effect(self) -> EffectTotal:\n-        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n-        total = EffectTotal()\n-\n-        for eff in self.effects:\n-            if isinstance(eff, AttackBonusEffect):\n-                total.attack_bonus += eff.attack_bonus\n-            elif isinstance(eff, AttackNegBonusEffect):\n-                total.attack_neg_bonus += eff.attack_neg_bonus\n-            elif isinstance(eff, SkipTurnEffect):\n-                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n-            elif isinstance(eff, RerollDiceEffect):\n-                total.reroll_dice_available = True\n-            elif isinstance(eff, DrawCardEffect):\n-                total.draw_card_count += eff.draw_count\n-\n-        return total\n-\n-    def db_model_dump(self) -> dict:\n-        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n-\n-\n-class CharacterSelectMeta(StrictModel):\n-    \"\"\"Stage metadata for character selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted character\n-\n-\n-class AbilitySelectMeta(StrictModel):\n-    \"\"\"Stage metadata for ability selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted ability\n-\n-\n-class ActivePlayer1(StrictModel):\n-    \"\"\"Selected character for battle\"\"\"\n-\n-    player: str  # Character name\n-\n-\n-class BattleResult(StrictModel):\n-    winner: bool\n-    score: int  # result of the battle, sum of dice_roll and attack\n-\n-\n-class ActivePlayer2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class ActivePlayer3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class ActivePlayer4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n-\n-\n-class Opponent2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class Opponent3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class Opponent4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-Opponent = Opponent2 | Opponent3 | Opponent4\n-\n-\n-class Player(StrictModel):\n-    name: str\n-    status: ConnectionStatus = CONNECTED\n-    cards: list[str] = Field(default_factory=list)\n-    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n-\n-\n-########################################################\n-# GamePlay model\n-########################################################\n-class GamePlay(StrictModel):\n-    stage: StageName = CHARACTER_SELECT\n-    players: dict[str, Player] = Field(default_factory=dict)\n-    active: Optional[ActivePlayer] = None  # The active player and its selections\n-    ability: Optional[Ability] = None  # Selected ability\n-    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n-    opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n-\n-    def reorder_players(self, username: str):\n-        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n-        if username not in self.players:\n-            return\n-\n-        # Get all player keys\n-        player_keys = list(self.players.keys())\n-\n-        # Find the index of the username\n-        user_index = player_keys.index(username)\n-\n-        # Circular shift: username first, then the rest\n-        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n-\n-        # Build new dict with reordered keys\n-        reordered_dict = {key: self.players[key] for key in reordered_keys}\n-\n-        # Update in-place\n-        self.players.clear()\n-        self.players.update(reordered_dict)\n-\n-\n-DEFAULT_GAME = GamePlay()\n-\n-KNIGHT_L1_DEFAULT_HEALTH = 2\n-KNIGHT_L1_MAX_HEALTH = 2\n-KNIGHT_L1_DICE = 1\n-KNIGHT_L1_ATTACK = 1\n-KNIGHT_L1_ABILITY = BATTLE_HOWL\n-\n-ARCHER_L1_DEFAULT_HEALTH = 3\n-ARCHER_L1_MAX_HEALTH = 3\n-ARCHER_L1_DICE = 1\n-ARCHER_L1_ATTACK = 0\n-ARCHER_L1_ABILITY = BOUNCING_ARROW\n-\n-MAGE_L1_DEFAULT_HEALTH = 2\n-MAGE_L1_MAX_HEALTH = 2\n-MAGE_L1_DICE = 1\n-MAGE_L1_ATTACK = 0\n-MAGE_L1_ABILITY = FREEZE\n-\n-CHARACTER_DEFAULT_STATS = {\n-    \"knight\": {\n-        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n-        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n-        \"dice\": KNIGHT_L1_DICE,\n-        \"attack\": KNIGHT_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n-    },\n-    \"archer\": {\n-        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n-        \"max_health\": ARCHER_L1_MAX_HEALTH,\n-        \"dice\": ARCHER_L1_DICE,\n-        \"attack\": ARCHER_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n-    },\n-    \"mage\": {\n-        \"health\": MAGE_L1_DEFAULT_HEALTH,\n-        \"max_health\": MAGE_L1_MAX_HEALTH,\n-        \"dice\": MAGE_L1_DICE,\n-        \"attack\": MAGE_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n-    },\n-}\n-\n-\n-def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n-    \"\"\"Initialize all character types with default stats\"\"\"\n-    return {\n-        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n-        for char_type in [KNIGHT, ARCHER, MAGE]\n-    }\n+    ACTION_NAMES,\n+    ActionName,\n+    # Exceptions\n+    GameException,\n+    ReportedException,\n+    # Utilities\n+    recursive_db_model_dump,\n+    StrictModel,\n+    # Character and game models\n+    Character,\n+    CharacterSelectMeta,\n+    AbilitySelectMeta,\n+    ActivePlayer1,\n+    BattleResult,\n+    ActivePlayer2,\n+    ActivePlayer3,\n+    ActivePlayer4,\n+    ActivePlayer,\n+    Opponent2,\n+    Opponent3,\n+    Opponent4,\n+    Opponent,\n+    Player,\n+    GamePlay,\n+    DEFAULT_GAME,\n+    # Character default stats\n+    KNIGHT_L1_DEFAULT_HEALTH,\n+    KNIGHT_L1_MAX_HEALTH,\n+    KNIGHT_L1_DICE,\n+    KNIGHT_L1_ATTACK,\n+    KNIGHT_L1_ABILITY,\n+    ARCHER_L1_DEFAULT_HEALTH,\n+    ARCHER_L1_MAX_HEALTH,\n+    ARCHER_L1_DICE,\n+    ARCHER_L1_ATTACK,\n+    ARCHER_L1_ABILITY,\n+    MAGE_L1_DEFAULT_HEALTH,\n+    MAGE_L1_MAX_HEALTH,\n+    MAGE_L1_DICE,\n+    MAGE_L1_ATTACK,\n+    MAGE_L1_ABILITY,\n+    CHARACTER_DEFAULT_STATS,\n+    init_characters,\n+)"
    },
    "preserveOutput": "always",
    "reporter": [
      [
        "html",
        {
          "open": "never"
        }
      ],
      [
        "json",
        {
          "outputFile": "playwright-report/results.json"
        }
      ],
      [
        "junit",
        {
          "outputFile": "playwright-report/results.xml"
        }
      ]
    ],
    "reportSlowTests": {
      "max": 5,
      "threshold": 300000
    },
    "quiet": false,
    "projects": [
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/7d8f37382697c6e10db68b8e0b5a26936e4eef15",
            "commitHash": "7d8f37382697c6e10db68b8e0b5a26936e4eef15",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/32",
            "prTitle": "claude/refactor-models-split-x1B0p",
            "prBaseHash": "7b34bb9c3140eefd84c9de32797c3a0b1d144776",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21110613059"
          },
          "gitCommit": {
            "shortHash": "7d8f373",
            "hash": "7d8f37382697c6e10db68b8e0b5a26936e4eef15",
            "subject": "Merge 0d43da1bbdb3c7da57138b2154919e09b3087f80 into 7b34bb9c3140eefd84c9de32797c3a0b1d144776",
            "body": "Merge 0d43da1bbdb3c7da57138b2154919e09b3087f80 into 7b34bb9c3140eefd84c9de32797c3a0b1d144776\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768734007000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768734007000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nnew file mode 100644\nindex 0000000..0064a3a\n--- /dev/null\n+++ b/server/gameplay/abilities.py\n@@ -0,0 +1,50 @@\n+from __future__ import annotations\n+\n+from pydantic import Field\n+\n+from .gameplay import (\n+    StrictModel,\n+    AbilityName,\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    APPLY_TO_SELECTED_OPPONENT,\n+)\n+from .effects import (\n+    EffectUnion,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    SkipTurnEffect,\n+)\n+\n+\n+class Ability(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n+\n+    @property\n+    def requires_opponent_selection(self) -> bool:\n+        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n+        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n+\n+\n+ABILITIES_MAP: dict[AbilityName, Ability] = {\n+    BATTLE_HOWL: Ability(\n+        name=BATTLE_HOWL,\n+        effects=[\n+            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+        ],\n+    ),\n+    BOUNCING_ARROW: Ability(\n+        name=BOUNCING_ARROW,\n+        effects=[\n+            RerollDiceEffect(source=BOUNCING_ARROW),\n+        ],\n+    ),\n+    FREEZE: Ability(\n+        name=FREEZE,\n+        effects=[\n+            SkipTurnEffect(source=FREEZE),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nnew file mode 100644\nindex 0000000..6b13dc5\n--- /dev/null\n+++ b/server/gameplay/effects.py\n@@ -0,0 +1,141 @@\n+from __future__ import annotations\n+\n+from typing import Literal, Annotated, Union, Self\n+\n+from pydantic import Field, model_validator\n+\n+from .gameplay import (\n+    StrictModel,\n+    AbilityName,\n+    ActionName,\n+    ApplyToTarget,\n+    # Effect name constants\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Action name constants for dispose_actions\n+    CHARACTER_SELECT_ACTION,\n+    BATTLE_END_ACTION,\n+    ACTION_REROLL_EFFECT,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+    APPLY_TO_BATTLE_OPPONENT,\n+    APPLY_TO_SELECTED_OPPONENT,\n+    # Ability name constants for source validation\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    # Source map\n+    EFFECTS_SOURCE_ABILITY_MAP,\n+)\n+\n+\n+class Effect(StrictModel):\n+    \"\"\"\n+    Base class for all effects.\n+    Each effect specifies when it should be disposed via dispose_actions field.\n+    Each effect specifies who receives the effect via apply_to field.\n+    \"\"\"\n+\n+    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n+    source: AbilityName\n+    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n+    apply_to: ApplyToTarget  # Who receives this effect\n+\n+    @model_validator(mode=\"after\")\n+    def validate_source(self) -> Self:\n+        \"\"\"Validate that source is valid for this effect type\"\"\"\n+        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        if self.source not in valid_sources and len(valid_sources) > 0:\n+            raise ValueError(\n+                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n+                f\"Valid sources: {valid_sources}\"\n+            )\n+        return self\n+\n+\n+class SkipTurnEffect(Effect):\n+    \"\"\"\n+    Character can't participate in the next turn.\n+    Disposed after character selection.\n+    Applied to selected opponent (requires ability_opponent_selection stage).\n+    \"\"\"\n+\n+    name: Literal[SKIP_TURN] = SKIP_TURN\n+    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n+    skip_next_turn: bool = True\n+\n+\n+class AttackBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is increased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    attack_bonus: int\n+\n+\n+class RerollDiceEffect(Effect):\n+    \"\"\"\n+    Character's dice are rerolled if lost the battle.\n+    Disposed at battle end or when the reroll effect action is used.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[REROLL_DICE] = REROLL_DICE\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    reroll_dice: bool = True\n+\n+\n+class AttackNegBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is decreased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to battle opponent (no separate selection required).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n+    attack_neg_bonus: int\n+\n+\n+class DrawCardEffect(Effect):\n+    \"\"\"\n+    Character draws cards at the start of battle.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DRAW_CARD] = DRAW_CARD\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    draw_count: int = 1\n+\n+\n+# Define EffectUnion for discriminated union of all effect types (without base classes)\n+EffectUnion = Annotated[\n+    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Field(discriminator=\"name\"),\n+]\n+\n+\n+class EffectTotal(StrictModel):\n+    \"\"\"\n+    Aggregated effect totals for a character.\n+    Combines all active effects into a single summary.\n+    \"\"\"\n+\n+    attack_bonus: int = 0\n+    attack_neg_bonus: int = 0\n+    skip_next_turn: bool = False\n+    reroll_dice_available: bool = False\n+    draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nnew file mode 100644\nindex 0000000..22f8224\n--- /dev/null\n+++ b/server/gameplay/gameplay.py\n@@ -0,0 +1,419 @@\n+from __future__ import annotations\n+\n+from typing import Dict, Optional, Literal\n+\n+from pydantic import BaseModel, ConfigDict, Field, computed_field\n+\n+########################################################\n+# Connection statuses\n+########################################################\n+CONNECTED = \"connected\"\n+DISCONNECTED = \"disconnected\"\n+CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n+ConnectionStatus = Literal[*CONNECTION_STATUSES]\n+\n+########################################################\n+# Stages\n+########################################################\n+CHARACTER_SELECT = \"character_select\"\n+ABILITY_SELECTION = \"ability_selection\"\n+ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n+OPPONENT_SELECTION = \"opponent_selection\"\n+BATTLE_DICE_ROLL = \"battle_dice_roll\"\n+BATTLE_END = \"battle_end\"\n+STAGES_NAMES = [\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+]\n+StageName = Literal[*STAGES_NAMES]\n+\n+########################################################\n+# Character types\n+########################################################\n+KNIGHT = \"knight\"\n+ARCHER = \"archer\"\n+MAGE = \"mage\"\n+CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n+ChatacterType = Literal[*CHARACTER_TYPES]\n+\n+BATTLE_HOWL = \"battle_howl\"\n+BOUNCING_ARROW = \"bouncing_arrow\"\n+FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+AbilityName = Literal[*ABILITIES_NAMES]\n+\n+# Effect names\n+ATTACK_BONUS = \"attack_bonus\"\n+ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+REROLL_DICE = \"reroll_dice\"\n+SKIP_TURN = \"skip_turn\"\n+DRAW_CARD = \"draw_card\"\n+\n+# Effect apply_to targets - specifies who receives the effect\n+APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n+APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n+APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n+\n+APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n+ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n+\n+# Effect-to-Source mapping: defines which abilities can create which effects\n+# This is used for validation to ensure effects have valid source abilities\n+EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n+    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n+    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n+    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n+    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+}\n+\n+########################################################\n+# Actions\n+########################################################\n+CONNECT = \"connect\"\n+LEAVE = \"leave\"\n+DISCONNECT = \"disconnect\"\n+CHARACTER_PRESS = \"character_press\"\n+CHARACTER_SELECT_ACTION = \"character_select\"\n+ABILITY_PRESS = \"ability_press\"\n+ABILITY_SELECT = \"ability_select\"\n+ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n+ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n+OPPONENT_PRESS = \"opponent_press\"\n+OPPONENT_SELECT = \"opponent_select\"\n+ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n+OPPONENT_ROLL = \"opponent_roll\"\n+ACTION_REROLL = \"action_reroll\"\n+ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n+BATTLE_END_ACTION = \"battle_end\"\n+DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n+\n+ACTION_NAMES = [\n+    CONNECT,\n+    LEAVE,\n+    DISCONNECT,\n+    CHARACTER_PRESS,\n+    CHARACTER_SELECT_ACTION,\n+    ABILITY_PRESS,\n+    ABILITY_SELECT,\n+    ABILITY_OPPONENT_PRESS,\n+    ABILITY_OPPONENT_SELECT,\n+    OPPONENT_PRESS,\n+    OPPONENT_SELECT,\n+    ACTIVE_PLAYER_ROLL,\n+    OPPONENT_ROLL,\n+    ACTION_REROLL,\n+    ACTION_REROLL_EFFECT,\n+    BATTLE_END_ACTION,\n+    DEBUG_SET_BATTLE_DICE_ROLLS,\n+]\n+ActionName = Literal[*ACTION_NAMES]\n+\n+\n+class GameException(Exception):\n+    pass\n+\n+\n+class ReportedException(GameException):\n+    pass\n+\n+\n+def recursive_db_model_dump(model: BaseModel) -> dict:\n+    \"\"\"\n+    Recursively dump model for database storage.\n+    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n+    \"\"\"\n+    result = {}\n+\n+    # Iterate over all fields and their values\n+    for field_name, field_value in model:\n+        if isinstance(field_value, BaseModel):\n+            # Nested model - call its db_model_dump if it's a StrictModel\n+            if hasattr(field_value, \"db_model_dump\"):\n+                result[field_name] = field_value.db_model_dump()\n+            else:\n+                result[field_name] = field_value.model_dump()\n+        elif isinstance(field_value, dict):\n+            # Dict of values (possibly models)\n+            result[field_name] = {\n+                k: (\n+                    v.db_model_dump()\n+                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n+                    else v.model_dump() if isinstance(v, BaseModel) else v\n+                )\n+                for k, v in field_value.items()\n+            }\n+        elif isinstance(field_value, (list, tuple, set)):\n+            # Collection of values (possibly models) - preserve collection type\n+            processed_items = [\n+                (\n+                    item.db_model_dump()\n+                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n+                    else item.model_dump() if isinstance(item, BaseModel) else item\n+                )\n+                for item in field_value\n+            ]\n+            # Preserve the original collection type\n+            result[field_name] = type(field_value)(processed_items)\n+        else:\n+            # Primitive value\n+            result[field_name] = field_value\n+\n+    return result\n+\n+\n+class StrictModel(BaseModel):\n+    model_config = ConfigDict(extra=\"forbid\")\n+\n+    def db_model_dump(self) -> dict:\n+        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n+        return recursive_db_model_dump(self)\n+\n+\n+class Character(StrictModel):\n+\n+    level: int\n+    health: int\n+    max_health: int\n+    dice: int\n+    attack: int\n+    abilities: list[Ability] = Field(default_factory=list)\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+    @computed_field\n+    @property\n+    def is_alive(self) -> bool:\n+        \"\"\"Character is alive if health > 0\"\"\"\n+        return self.health > 0\n+\n+    @computed_field\n+    @property\n+    def effect(self) -> EffectTotal:\n+        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n+        from .effects import (\n+            EffectTotal,\n+            AttackBonusEffect,\n+            AttackNegBonusEffect,\n+            SkipTurnEffect,\n+            RerollDiceEffect,\n+            DrawCardEffect,\n+        )\n+\n+        total = EffectTotal()\n+\n+        for eff in self.effects:\n+            if isinstance(eff, AttackBonusEffect):\n+                total.attack_bonus += eff.attack_bonus\n+            elif isinstance(eff, AttackNegBonusEffect):\n+                total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, SkipTurnEffect):\n+                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n+            elif isinstance(eff, RerollDiceEffect):\n+                total.reroll_dice_available = True\n+            elif isinstance(eff, DrawCardEffect):\n+                total.draw_card_count += eff.draw_count\n+\n+        return total\n+\n+    def db_model_dump(self) -> dict:\n+        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n+\n+\n+class CharacterSelectMeta(StrictModel):\n+    \"\"\"Stage metadata for character selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted character\n+\n+\n+class AbilitySelectMeta(StrictModel):\n+    \"\"\"Stage metadata for ability selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted ability\n+\n+\n+class ActivePlayer1(StrictModel):\n+    \"\"\"Selected character for battle\"\"\"\n+\n+    player: str  # Character name\n+\n+\n+class BattleResult(StrictModel):\n+    winner: bool\n+    score: int  # result of the battle, sum of dice_roll and attack\n+\n+\n+class ActivePlayer2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class ActivePlayer3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class ActivePlayer4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n+\n+\n+class Opponent2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class Opponent3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class Opponent4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+Opponent = Opponent2 | Opponent3 | Opponent4\n+\n+\n+class Player(StrictModel):\n+    name: str\n+    status: ConnectionStatus = CONNECTED\n+    cards: list[str] = Field(default_factory=list)\n+    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n+\n+\n+########################################################\n+# GamePlay model\n+########################################################\n+class GamePlay(StrictModel):\n+    stage: StageName = CHARACTER_SELECT\n+    players: dict[str, Player] = Field(default_factory=dict)\n+    active: Optional[ActivePlayer] = None  # The active player and its selections\n+    ability: Optional[Ability] = None  # Selected ability\n+    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n+    opponent: Optional[Opponent] = None  # Selected opponent for battle\n+    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+\n+    def reorder_players(self, username: str):\n+        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n+        if username not in self.players:\n+            return\n+\n+        # Get all player keys\n+        player_keys = list(self.players.keys())\n+\n+        # Find the index of the username\n+        user_index = player_keys.index(username)\n+\n+        # Circular shift: username first, then the rest\n+        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n+\n+        # Build new dict with reordered keys\n+        reordered_dict = {key: self.players[key] for key in reordered_keys}\n+\n+        # Update in-place\n+        self.players.clear()\n+        self.players.update(reordered_dict)\n+\n+\n+DEFAULT_GAME = GamePlay()\n+\n+KNIGHT_L1_DEFAULT_HEALTH = 2\n+KNIGHT_L1_MAX_HEALTH = 2\n+KNIGHT_L1_DICE = 1\n+KNIGHT_L1_ATTACK = 1\n+KNIGHT_L1_ABILITY = BATTLE_HOWL\n+\n+ARCHER_L1_DEFAULT_HEALTH = 3\n+ARCHER_L1_MAX_HEALTH = 3\n+ARCHER_L1_DICE = 1\n+ARCHER_L1_ATTACK = 0\n+ARCHER_L1_ABILITY = BOUNCING_ARROW\n+\n+MAGE_L1_DEFAULT_HEALTH = 2\n+MAGE_L1_MAX_HEALTH = 2\n+MAGE_L1_DICE = 1\n+MAGE_L1_ATTACK = 0\n+MAGE_L1_ABILITY = FREEZE\n+\n+def get_character_default_stats() -> dict:\n+    \"\"\"Get character default stats with abilities. Uses lazy import to avoid circular dependency.\"\"\"\n+    from .abilities import ABILITIES_MAP\n+\n+    return {\n+        \"knight\": {\n+            \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n+            \"max_health\": KNIGHT_L1_MAX_HEALTH,\n+            \"dice\": KNIGHT_L1_DICE,\n+            \"attack\": KNIGHT_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n+        },\n+        \"archer\": {\n+            \"health\": ARCHER_L1_DEFAULT_HEALTH,\n+            \"max_health\": ARCHER_L1_MAX_HEALTH,\n+            \"dice\": ARCHER_L1_DICE,\n+            \"attack\": ARCHER_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n+        },\n+        \"mage\": {\n+            \"health\": MAGE_L1_DEFAULT_HEALTH,\n+            \"max_health\": MAGE_L1_MAX_HEALTH,\n+            \"dice\": MAGE_L1_DICE,\n+            \"attack\": MAGE_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n+        },\n+    }\n+\n+\n+# Lazy-evaluated CHARACTER_DEFAULT_STATS for backwards compatibility\n+_CHARACTER_DEFAULT_STATS = None\n+\n+\n+def _get_cached_character_default_stats():\n+    global _CHARACTER_DEFAULT_STATS\n+    if _CHARACTER_DEFAULT_STATS is None:\n+        _CHARACTER_DEFAULT_STATS = get_character_default_stats()\n+    return _CHARACTER_DEFAULT_STATS\n+\n+\n+# Property-like access for CHARACTER_DEFAULT_STATS\n+class _CharacterDefaultStatsProxy:\n+    def __getitem__(self, key):\n+        return _get_cached_character_default_stats()[key]\n+\n+    def __iter__(self):\n+        return iter(_get_cached_character_default_stats())\n+\n+    def items(self):\n+        return _get_cached_character_default_stats().items()\n+\n+    def keys(self):\n+        return _get_cached_character_default_stats().keys()\n+\n+    def values(self):\n+        return _get_cached_character_default_stats().values()\n+\n+\n+CHARACTER_DEFAULT_STATS = _CharacterDefaultStatsProxy()\n+\n+\n+def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n+    \"\"\"Initialize all character types with default stats\"\"\"\n+    stats = get_character_default_stats()\n+    return {\n+        char_type: Character(level=level, **stats[char_type])\n+        for char_type in [KNIGHT, ARCHER, MAGE]\n+    }\ndiff --git a/server/gameplay/models.py b/server/gameplay/models.py\nindex d8a1106..7aa309e 100644\n--- a/server/gameplay/models.py\n+++ b/server/gameplay/models.py\n@@ -1,96 +1,69 @@\n-from typing import Dict, Optional, Literal, Annotated, Union, Self\n-\n-from pydantic import BaseModel, ConfigDict, Field, computed_field, Discriminator, model_validator\n-\n-########################################################\n-# Connection statuses\n-########################################################\n-CONNECTED = \"connected\"\n-DISCONNECTED = \"disconnected\"\n-CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n-ConnectionStatus = Literal[*CONNECTION_STATUSES]\n-\n-########################################################\n-# Stages\n-########################################################\n-CHARACTER_SELECT = \"character_select\"\n-ABILITY_SELECTION = \"ability_selection\"\n-ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n-OPPONENT_SELECTION = \"opponent_selection\"\n-BATTLE_DICE_ROLL = \"battle_dice_roll\"\n-BATTLE_END = \"battle_end\"\n-STAGES_NAMES = [\n+\"\"\"\n+Backwards compatibility - re-exports from split modules.\n+Import directly from effects, abilities, or gameplay for new code.\n+\"\"\"\n+\n+# Re-export from effects\n+from .effects import (\n+    Effect,\n+    SkipTurnEffect,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    AttackNegBonusEffect,\n+    DrawCardEffect,\n+    EffectUnion,\n+    EffectTotal,\n+)\n+\n+# Re-export from abilities\n+from .abilities import (\n+    Ability,\n+    ABILITIES_MAP,\n+)\n+\n+# Re-export from gameplay (everything else)\n+from .gameplay import (\n+    # Connection statuses\n+    CONNECTED,\n+    DISCONNECTED,\n+    CONNECTION_STATUSES,\n+    ConnectionStatus,\n+    # Stages\n     CHARACTER_SELECT,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n     BATTLE_DICE_ROLL,\n     BATTLE_END,\n-]\n-StageName = Literal[*STAGES_NAMES]\n-\n-########################################################\n-# Character types\n-########################################################\n-KNIGHT = \"knight\"\n-ARCHER = \"archer\"\n-MAGE = \"mage\"\n-CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n-ChatacterType = Literal[*CHARACTER_TYPES]\n-\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n-AbilityName = Literal[*ABILITIES_NAMES]\n-\n-# Effect names\n-ATTACK_BONUS = \"attack_bonus\"\n-ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n-REROLL_DICE = \"reroll_dice\"\n-SKIP_TURN = \"skip_turn\"\n-DRAW_CARD = \"draw_card\"\n-\n-# Effect apply_to targets - specifies who receives the effect\n-APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n-APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n-APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n-\n-APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n-ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n-\n-# Effect-to-Source mapping: defines which abilities can create which effects\n-# This is used for validation to ensure effects have valid source abilities\n-EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n-}\n-\n-########################################################\n-# Actions\n-########################################################\n-CONNECT = \"connect\"\n-LEAVE = \"leave\"\n-DISCONNECT = \"disconnect\"\n-CHARACTER_PRESS = \"character_press\"\n-CHARACTER_SELECT_ACTION = \"character_select\"\n-ABILITY_PRESS = \"ability_press\"\n-ABILITY_SELECT = \"ability_select\"\n-ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n-ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n-OPPONENT_PRESS = \"opponent_press\"\n-OPPONENT_SELECT = \"opponent_select\"\n-ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n-OPPONENT_ROLL = \"opponent_roll\"\n-ACTION_REROLL = \"action_reroll\"\n-ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n-BATTLE_END_ACTION = \"battle_end\"\n-DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n-\n-ACTION_NAMES = [\n+    STAGES_NAMES,\n+    StageName,\n+    # Character types\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+    CHARACTER_TYPES,\n+    ChatacterType,\n+    # Ability names\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    ABILITIES_NAMES,\n+    AbilityName,\n+    # Effect names\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Apply to targets\n+    APPLY_TO_SELF,\n+    APPLY_TO_BATTLE_OPPONENT,\n+    APPLY_TO_SELECTED_OPPONENT,\n+    APPLY_TO_TARGETS,\n+    ApplyToTarget,\n+    # Effect source map\n+    EFFECTS_SOURCE_ABILITY_MAP,\n+    # Actions\n     CONNECT,\n     LEAVE,\n     DISCONNECT,\n@@ -108,405 +81,47 @@ ACTION_NAMES = [\n     ACTION_REROLL_EFFECT,\n     BATTLE_END_ACTION,\n     DEBUG_SET_BATTLE_DICE_ROLLS,\n-]\n-ActionName = Literal[*ACTION_NAMES]\n-\n-\n-class GameException(Exception):\n-    pass\n-\n-\n-class ReportedException(GameException):\n-    pass\n-\n-\n-def recursive_db_model_dump(model: BaseModel) -> dict:\n-    \"\"\"\n-    Recursively dump model for database storage.\n-    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n-    \"\"\"\n-    result = {}\n-\n-    # Iterate over all fields and their values\n-    for field_name, field_value in model:\n-        if isinstance(field_value, BaseModel):\n-            # Nested model - call its db_model_dump if it's a StrictModel\n-            if hasattr(field_value, \"db_model_dump\"):\n-                result[field_name] = field_value.db_model_dump()\n-            else:\n-                result[field_name] = field_value.model_dump()\n-        elif isinstance(field_value, dict):\n-            # Dict of values (possibly models)\n-            result[field_name] = {\n-                k: (\n-                    v.db_model_dump()\n-                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n-                    else v.model_dump() if isinstance(v, BaseModel) else v\n-                )\n-                for k, v in field_value.items()\n-            }\n-        elif isinstance(field_value, (list, tuple, set)):\n-            # Collection of values (possibly models) - preserve collection type\n-            processed_items = [\n-                (\n-                    item.db_model_dump()\n-                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n-                    else item.model_dump() if isinstance(item, BaseModel) else item\n-                )\n-                for item in field_value\n-            ]\n-            # Preserve the original collection type\n-            result[field_name] = type(field_value)(processed_items)\n-        else:\n-            # Primitive value\n-            result[field_name] = field_value\n-\n-    return result\n-\n-\n-class StrictModel(BaseModel):\n-    model_config = ConfigDict(extra=\"forbid\")\n-\n-    def db_model_dump(self) -> dict:\n-        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n-        return recursive_db_model_dump(self)\n-\n-\n-class Effect(StrictModel):\n-    \"\"\"\n-    Base class for all effects.\n-    Each effect specifies when it should be disposed via dispose_actions field.\n-    Each effect specifies who receives the effect via apply_to field.\n-    \"\"\"\n-\n-    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n-    source: AbilityName\n-    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n-    apply_to: ApplyToTarget  # Who receives this effect\n-\n-    @model_validator(mode=\"after\")\n-    def validate_source(self) -> Self:\n-        \"\"\"Validate that source is valid for this effect type\"\"\"\n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n-        if self.source not in valid_sources and len(valid_sources) > 0:\n-            raise ValueError(\n-                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n-                f\"Valid sources: {valid_sources}\"\n-            )\n-        return self\n-\n-\n-class SkipTurnEffect(Effect):\n-    \"\"\"\n-    Character can't participate in the next turn.\n-    Disposed after character selection.\n-    Applied to selected opponent (requires ability_opponent_selection stage).\n-    \"\"\"\n-\n-    name: Literal[SKIP_TURN] = SKIP_TURN\n-    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n-    skip_next_turn: bool = True\n-\n-\n-class AttackBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is increased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    attack_bonus: int\n-\n-\n-class RerollDiceEffect(Effect):\n-    \"\"\"\n-    Character's dice are rerolled if lost the battle.\n-    Disposed at battle end or when the reroll effect action is used.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[REROLL_DICE] = REROLL_DICE\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    reroll_dice: bool = True\n-\n-\n-class AttackNegBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is decreased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to battle opponent (no separate selection required).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n-    attack_neg_bonus: int\n-\n-\n-class DrawCardEffect(Effect):\n-    \"\"\"\n-    Character draws cards at the start of battle.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[DRAW_CARD] = DRAW_CARD\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    draw_count: int = 1\n-\n-\n-# Define EffectUnion for discriminated union of all effect types (without base classes)\n-EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n-    Field(discriminator=\"name\"),\n-]\n-\n-\n-class Ability(StrictModel):\n-    name: str\n-    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n-\n-    @property\n-    def requires_opponent_selection(self) -> bool:\n-        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n-        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n-\n-\n-class EffectTotal(StrictModel):\n-    \"\"\"\n-    Aggregated effect totals for a character.\n-    Combines all active effects into a single summary.\n-    \"\"\"\n-\n-    attack_bonus: int = 0\n-    attack_neg_bonus: int = 0\n-    skip_next_turn: bool = False\n-    reroll_dice_available: bool = False\n-    draw_card_count: int = 0\n-\n-\n-ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n-        effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n-        ],\n-    ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n-        effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n-        ],\n-    ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n-        effects=[\n-            SkipTurnEffect(source=FREEZE),\n-        ],\n-    ),\n-}\n-\n-\n-class Character(StrictModel):\n-\n-    level: int\n-    health: int\n-    max_health: int\n-    dice: int\n-    attack: int\n-    abilities: list[Ability] = Field(default_factory=list)\n-    effects: list[EffectUnion] = Field(default_factory=list)\n-\n-    @computed_field\n-    @property\n-    def is_alive(self) -> bool:\n-        \"\"\"Character is alive if health > 0\"\"\"\n-        return self.health > 0\n-\n-    @computed_field\n-    @property\n-    def effect(self) -> EffectTotal:\n-        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n-        total = EffectTotal()\n-\n-        for eff in self.effects:\n-            if isinstance(eff, AttackBonusEffect):\n-                total.attack_bonus += eff.attack_bonus\n-            elif isinstance(eff, AttackNegBonusEffect):\n-                total.attack_neg_bonus += eff.attack_neg_bonus\n-            elif isinstance(eff, SkipTurnEffect):\n-                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n-            elif isinstance(eff, RerollDiceEffect):\n-                total.reroll_dice_available = True\n-            elif isinstance(eff, DrawCardEffect):\n-                total.draw_card_count += eff.draw_count\n-\n-        return total\n-\n-    def db_model_dump(self) -> dict:\n-        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n-\n-\n-class CharacterSelectMeta(StrictModel):\n-    \"\"\"Stage metadata for character selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted character\n-\n-\n-class AbilitySelectMeta(StrictModel):\n-    \"\"\"Stage metadata for ability selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted ability\n-\n-\n-class ActivePlayer1(StrictModel):\n-    \"\"\"Selected character for battle\"\"\"\n-\n-    player: str  # Character name\n-\n-\n-class BattleResult(StrictModel):\n-    winner: bool\n-    score: int  # result of the battle, sum of dice_roll and attack\n-\n-\n-class ActivePlayer2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class ActivePlayer3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class ActivePlayer4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n-\n-\n-class Opponent2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class Opponent3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class Opponent4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-Opponent = Opponent2 | Opponent3 | Opponent4\n-\n-\n-class Player(StrictModel):\n-    name: str\n-    status: ConnectionStatus = CONNECTED\n-    cards: list[str] = Field(default_factory=list)\n-    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n-\n-\n-########################################################\n-# GamePlay model\n-########################################################\n-class GamePlay(StrictModel):\n-    stage: StageName = CHARACTER_SELECT\n-    players: dict[str, Player] = Field(default_factory=dict)\n-    active: Optional[ActivePlayer] = None  # The active player and its selections\n-    ability: Optional[Ability] = None  # Selected ability\n-    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n-    opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n-\n-    def reorder_players(self, username: str):\n-        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n-        if username not in self.players:\n-            return\n-\n-        # Get all player keys\n-        player_keys = list(self.players.keys())\n-\n-        # Find the index of the username\n-        user_index = player_keys.index(username)\n-\n-        # Circular shift: username first, then the rest\n-        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n-\n-        # Build new dict with reordered keys\n-        reordered_dict = {key: self.players[key] for key in reordered_keys}\n-\n-        # Update in-place\n-        self.players.clear()\n-        self.players.update(reordered_dict)\n-\n-\n-DEFAULT_GAME = GamePlay()\n-\n-KNIGHT_L1_DEFAULT_HEALTH = 2\n-KNIGHT_L1_MAX_HEALTH = 2\n-KNIGHT_L1_DICE = 1\n-KNIGHT_L1_ATTACK = 1\n-KNIGHT_L1_ABILITY = BATTLE_HOWL\n-\n-ARCHER_L1_DEFAULT_HEALTH = 3\n-ARCHER_L1_MAX_HEALTH = 3\n-ARCHER_L1_DICE = 1\n-ARCHER_L1_ATTACK = 0\n-ARCHER_L1_ABILITY = BOUNCING_ARROW\n-\n-MAGE_L1_DEFAULT_HEALTH = 2\n-MAGE_L1_MAX_HEALTH = 2\n-MAGE_L1_DICE = 1\n-MAGE_L1_ATTACK = 0\n-MAGE_L1_ABILITY = FREEZE\n-\n-CHARACTER_DEFAULT_STATS = {\n-    \"knight\": {\n-        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n-        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n-        \"dice\": KNIGHT_L1_DICE,\n-        \"attack\": KNIGHT_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n-    },\n-    \"archer\": {\n-        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n-        \"max_health\": ARCHER_L1_MAX_HEALTH,\n-        \"dice\": ARCHER_L1_DICE,\n-        \"attack\": ARCHER_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n-    },\n-    \"mage\": {\n-        \"health\": MAGE_L1_DEFAULT_HEALTH,\n-        \"max_health\": MAGE_L1_MAX_HEALTH,\n-        \"dice\": MAGE_L1_DICE,\n-        \"attack\": MAGE_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n-    },\n-}\n-\n-\n-def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n-    \"\"\"Initialize all character types with default stats\"\"\"\n-    return {\n-        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n-        for char_type in [KNIGHT, ARCHER, MAGE]\n-    }\n+    ACTION_NAMES,\n+    ActionName,\n+    # Exceptions\n+    GameException,\n+    ReportedException,\n+    # Utilities\n+    recursive_db_model_dump,\n+    StrictModel,\n+    # Character and game models\n+    Character,\n+    CharacterSelectMeta,\n+    AbilitySelectMeta,\n+    ActivePlayer1,\n+    BattleResult,\n+    ActivePlayer2,\n+    ActivePlayer3,\n+    ActivePlayer4,\n+    ActivePlayer,\n+    Opponent2,\n+    Opponent3,\n+    Opponent4,\n+    Opponent,\n+    Player,\n+    GamePlay,\n+    DEFAULT_GAME,\n+    # Character default stats\n+    KNIGHT_L1_DEFAULT_HEALTH,\n+    KNIGHT_L1_MAX_HEALTH,\n+    KNIGHT_L1_DICE,\n+    KNIGHT_L1_ATTACK,\n+    KNIGHT_L1_ABILITY,\n+    ARCHER_L1_DEFAULT_HEALTH,\n+    ARCHER_L1_MAX_HEALTH,\n+    ARCHER_L1_DICE,\n+    ARCHER_L1_ATTACK,\n+    ARCHER_L1_ABILITY,\n+    MAGE_L1_DEFAULT_HEALTH,\n+    MAGE_L1_MAX_HEALTH,\n+    MAGE_L1_DICE,\n+    MAGE_L1_ATTACK,\n+    MAGE_L1_ABILITY,\n+    CHARACTER_DEFAULT_STATS,\n+    init_characters,\n+)"
        },
        "id": "chromium",
        "name": "chromium",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      },
      {
        "outputDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/test-results",
        "repeatEach": 1,
        "retries": 0,
        "metadata": {
          "ci": {
            "commitHref": "https://github.com/kolodkin/heroes-of-talisman/commit/7d8f37382697c6e10db68b8e0b5a26936e4eef15",
            "commitHash": "7d8f37382697c6e10db68b8e0b5a26936e4eef15",
            "prHref": "https://github.com/kolodkin/heroes-of-talisman/pull/32",
            "prTitle": "claude/refactor-models-split-x1B0p",
            "prBaseHash": "7b34bb9c3140eefd84c9de32797c3a0b1d144776",
            "buildHref": "https://github.com/kolodkin/heroes-of-talisman/actions/runs/21110613059"
          },
          "gitCommit": {
            "shortHash": "7d8f373",
            "hash": "7d8f37382697c6e10db68b8e0b5a26936e4eef15",
            "subject": "Merge 0d43da1bbdb3c7da57138b2154919e09b3087f80 into 7b34bb9c3140eefd84c9de32797c3a0b1d144776",
            "body": "Merge 0d43da1bbdb3c7da57138b2154919e09b3087f80 into 7b34bb9c3140eefd84c9de32797c3a0b1d144776\n",
            "author": {
              "name": "mark kolodkin",
              "email": "mark.kolodkin@gmail.com",
              "time": 1768734007000
            },
            "committer": {
              "name": "GitHub",
              "email": "noreply@github.com",
              "time": 1768734007000
            },
            "branch": "HEAD"
          },
          "gitDiff": "diff --git a/server/gameplay/abilities.py b/server/gameplay/abilities.py\nnew file mode 100644\nindex 0000000..0064a3a\n--- /dev/null\n+++ b/server/gameplay/abilities.py\n@@ -0,0 +1,50 @@\n+from __future__ import annotations\n+\n+from pydantic import Field\n+\n+from .gameplay import (\n+    StrictModel,\n+    AbilityName,\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    APPLY_TO_SELECTED_OPPONENT,\n+)\n+from .effects import (\n+    EffectUnion,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    SkipTurnEffect,\n+)\n+\n+\n+class Ability(StrictModel):\n+    name: str\n+    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n+\n+    @property\n+    def requires_opponent_selection(self) -> bool:\n+        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n+        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n+\n+\n+ABILITIES_MAP: dict[AbilityName, Ability] = {\n+    BATTLE_HOWL: Ability(\n+        name=BATTLE_HOWL,\n+        effects=[\n+            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n+        ],\n+    ),\n+    BOUNCING_ARROW: Ability(\n+        name=BOUNCING_ARROW,\n+        effects=[\n+            RerollDiceEffect(source=BOUNCING_ARROW),\n+        ],\n+    ),\n+    FREEZE: Ability(\n+        name=FREEZE,\n+        effects=[\n+            SkipTurnEffect(source=FREEZE),\n+        ],\n+    ),\n+}\ndiff --git a/server/gameplay/effects.py b/server/gameplay/effects.py\nnew file mode 100644\nindex 0000000..6b13dc5\n--- /dev/null\n+++ b/server/gameplay/effects.py\n@@ -0,0 +1,141 @@\n+from __future__ import annotations\n+\n+from typing import Literal, Annotated, Union, Self\n+\n+from pydantic import Field, model_validator\n+\n+from .gameplay import (\n+    StrictModel,\n+    AbilityName,\n+    ActionName,\n+    ApplyToTarget,\n+    # Effect name constants\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Action name constants for dispose_actions\n+    CHARACTER_SELECT_ACTION,\n+    BATTLE_END_ACTION,\n+    ACTION_REROLL_EFFECT,\n+    # Apply to constants\n+    APPLY_TO_SELF,\n+    APPLY_TO_BATTLE_OPPONENT,\n+    APPLY_TO_SELECTED_OPPONENT,\n+    # Ability name constants for source validation\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    # Source map\n+    EFFECTS_SOURCE_ABILITY_MAP,\n+)\n+\n+\n+class Effect(StrictModel):\n+    \"\"\"\n+    Base class for all effects.\n+    Each effect specifies when it should be disposed via dispose_actions field.\n+    Each effect specifies who receives the effect via apply_to field.\n+    \"\"\"\n+\n+    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n+    source: AbilityName\n+    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n+    apply_to: ApplyToTarget  # Who receives this effect\n+\n+    @model_validator(mode=\"after\")\n+    def validate_source(self) -> Self:\n+        \"\"\"Validate that source is valid for this effect type\"\"\"\n+        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n+        if self.source not in valid_sources and len(valid_sources) > 0:\n+            raise ValueError(\n+                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n+                f\"Valid sources: {valid_sources}\"\n+            )\n+        return self\n+\n+\n+class SkipTurnEffect(Effect):\n+    \"\"\"\n+    Character can't participate in the next turn.\n+    Disposed after character selection.\n+    Applied to selected opponent (requires ability_opponent_selection stage).\n+    \"\"\"\n+\n+    name: Literal[SKIP_TURN] = SKIP_TURN\n+    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n+    skip_next_turn: bool = True\n+\n+\n+class AttackBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is increased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    attack_bonus: int\n+\n+\n+class RerollDiceEffect(Effect):\n+    \"\"\"\n+    Character's dice are rerolled if lost the battle.\n+    Disposed at battle end or when the reroll effect action is used.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[REROLL_DICE] = REROLL_DICE\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    reroll_dice: bool = True\n+\n+\n+class AttackNegBonusEffect(Effect):\n+    \"\"\"\n+    Character's attack is decreased by the value of the effect.\n+    Disposed at battle end.\n+    Applied to battle opponent (no separate selection required).\n+    \"\"\"\n+\n+    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n+    attack_neg_bonus: int\n+\n+\n+class DrawCardEffect(Effect):\n+    \"\"\"\n+    Character draws cards at the start of battle.\n+    Disposed at battle end.\n+    Applied to self (active player's character).\n+    \"\"\"\n+\n+    name: Literal[DRAW_CARD] = DRAW_CARD\n+    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n+    apply_to: ApplyToTarget = APPLY_TO_SELF\n+    draw_count: int = 1\n+\n+\n+# Define EffectUnion for discriminated union of all effect types (without base classes)\n+EffectUnion = Annotated[\n+    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n+    Field(discriminator=\"name\"),\n+]\n+\n+\n+class EffectTotal(StrictModel):\n+    \"\"\"\n+    Aggregated effect totals for a character.\n+    Combines all active effects into a single summary.\n+    \"\"\"\n+\n+    attack_bonus: int = 0\n+    attack_neg_bonus: int = 0\n+    skip_next_turn: bool = False\n+    reroll_dice_available: bool = False\n+    draw_card_count: int = 0\ndiff --git a/server/gameplay/gameplay.py b/server/gameplay/gameplay.py\nnew file mode 100644\nindex 0000000..22f8224\n--- /dev/null\n+++ b/server/gameplay/gameplay.py\n@@ -0,0 +1,419 @@\n+from __future__ import annotations\n+\n+from typing import Dict, Optional, Literal\n+\n+from pydantic import BaseModel, ConfigDict, Field, computed_field\n+\n+########################################################\n+# Connection statuses\n+########################################################\n+CONNECTED = \"connected\"\n+DISCONNECTED = \"disconnected\"\n+CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n+ConnectionStatus = Literal[*CONNECTION_STATUSES]\n+\n+########################################################\n+# Stages\n+########################################################\n+CHARACTER_SELECT = \"character_select\"\n+ABILITY_SELECTION = \"ability_selection\"\n+ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n+OPPONENT_SELECTION = \"opponent_selection\"\n+BATTLE_DICE_ROLL = \"battle_dice_roll\"\n+BATTLE_END = \"battle_end\"\n+STAGES_NAMES = [\n+    CHARACTER_SELECT,\n+    ABILITY_SELECTION,\n+    ABILITY_OPPONENT_SELECTION,\n+    OPPONENT_SELECTION,\n+    BATTLE_DICE_ROLL,\n+    BATTLE_END,\n+]\n+StageName = Literal[*STAGES_NAMES]\n+\n+########################################################\n+# Character types\n+########################################################\n+KNIGHT = \"knight\"\n+ARCHER = \"archer\"\n+MAGE = \"mage\"\n+CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n+ChatacterType = Literal[*CHARACTER_TYPES]\n+\n+BATTLE_HOWL = \"battle_howl\"\n+BOUNCING_ARROW = \"bouncing_arrow\"\n+FREEZE = \"freeze\"\n+ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n+AbilityName = Literal[*ABILITIES_NAMES]\n+\n+# Effect names\n+ATTACK_BONUS = \"attack_bonus\"\n+ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n+REROLL_DICE = \"reroll_dice\"\n+SKIP_TURN = \"skip_turn\"\n+DRAW_CARD = \"draw_card\"\n+\n+# Effect apply_to targets - specifies who receives the effect\n+APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n+APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n+APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n+\n+APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n+ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n+\n+# Effect-to-Source mapping: defines which abilities can create which effects\n+# This is used for validation to ensure effects have valid source abilities\n+EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n+    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n+    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n+    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n+    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n+    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n+}\n+\n+########################################################\n+# Actions\n+########################################################\n+CONNECT = \"connect\"\n+LEAVE = \"leave\"\n+DISCONNECT = \"disconnect\"\n+CHARACTER_PRESS = \"character_press\"\n+CHARACTER_SELECT_ACTION = \"character_select\"\n+ABILITY_PRESS = \"ability_press\"\n+ABILITY_SELECT = \"ability_select\"\n+ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n+ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n+OPPONENT_PRESS = \"opponent_press\"\n+OPPONENT_SELECT = \"opponent_select\"\n+ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n+OPPONENT_ROLL = \"opponent_roll\"\n+ACTION_REROLL = \"action_reroll\"\n+ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n+BATTLE_END_ACTION = \"battle_end\"\n+DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n+\n+ACTION_NAMES = [\n+    CONNECT,\n+    LEAVE,\n+    DISCONNECT,\n+    CHARACTER_PRESS,\n+    CHARACTER_SELECT_ACTION,\n+    ABILITY_PRESS,\n+    ABILITY_SELECT,\n+    ABILITY_OPPONENT_PRESS,\n+    ABILITY_OPPONENT_SELECT,\n+    OPPONENT_PRESS,\n+    OPPONENT_SELECT,\n+    ACTIVE_PLAYER_ROLL,\n+    OPPONENT_ROLL,\n+    ACTION_REROLL,\n+    ACTION_REROLL_EFFECT,\n+    BATTLE_END_ACTION,\n+    DEBUG_SET_BATTLE_DICE_ROLLS,\n+]\n+ActionName = Literal[*ACTION_NAMES]\n+\n+\n+class GameException(Exception):\n+    pass\n+\n+\n+class ReportedException(GameException):\n+    pass\n+\n+\n+def recursive_db_model_dump(model: BaseModel) -> dict:\n+    \"\"\"\n+    Recursively dump model for database storage.\n+    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n+    \"\"\"\n+    result = {}\n+\n+    # Iterate over all fields and their values\n+    for field_name, field_value in model:\n+        if isinstance(field_value, BaseModel):\n+            # Nested model - call its db_model_dump if it's a StrictModel\n+            if hasattr(field_value, \"db_model_dump\"):\n+                result[field_name] = field_value.db_model_dump()\n+            else:\n+                result[field_name] = field_value.model_dump()\n+        elif isinstance(field_value, dict):\n+            # Dict of values (possibly models)\n+            result[field_name] = {\n+                k: (\n+                    v.db_model_dump()\n+                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n+                    else v.model_dump() if isinstance(v, BaseModel) else v\n+                )\n+                for k, v in field_value.items()\n+            }\n+        elif isinstance(field_value, (list, tuple, set)):\n+            # Collection of values (possibly models) - preserve collection type\n+            processed_items = [\n+                (\n+                    item.db_model_dump()\n+                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n+                    else item.model_dump() if isinstance(item, BaseModel) else item\n+                )\n+                for item in field_value\n+            ]\n+            # Preserve the original collection type\n+            result[field_name] = type(field_value)(processed_items)\n+        else:\n+            # Primitive value\n+            result[field_name] = field_value\n+\n+    return result\n+\n+\n+class StrictModel(BaseModel):\n+    model_config = ConfigDict(extra=\"forbid\")\n+\n+    def db_model_dump(self) -> dict:\n+        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n+        return recursive_db_model_dump(self)\n+\n+\n+class Character(StrictModel):\n+\n+    level: int\n+    health: int\n+    max_health: int\n+    dice: int\n+    attack: int\n+    abilities: list[Ability] = Field(default_factory=list)\n+    effects: list[EffectUnion] = Field(default_factory=list)\n+\n+    @computed_field\n+    @property\n+    def is_alive(self) -> bool:\n+        \"\"\"Character is alive if health > 0\"\"\"\n+        return self.health > 0\n+\n+    @computed_field\n+    @property\n+    def effect(self) -> EffectTotal:\n+        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n+        from .effects import (\n+            EffectTotal,\n+            AttackBonusEffect,\n+            AttackNegBonusEffect,\n+            SkipTurnEffect,\n+            RerollDiceEffect,\n+            DrawCardEffect,\n+        )\n+\n+        total = EffectTotal()\n+\n+        for eff in self.effects:\n+            if isinstance(eff, AttackBonusEffect):\n+                total.attack_bonus += eff.attack_bonus\n+            elif isinstance(eff, AttackNegBonusEffect):\n+                total.attack_neg_bonus += eff.attack_neg_bonus\n+            elif isinstance(eff, SkipTurnEffect):\n+                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n+            elif isinstance(eff, RerollDiceEffect):\n+                total.reroll_dice_available = True\n+            elif isinstance(eff, DrawCardEffect):\n+                total.draw_card_count += eff.draw_count\n+\n+        return total\n+\n+    def db_model_dump(self) -> dict:\n+        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n+\n+\n+class CharacterSelectMeta(StrictModel):\n+    \"\"\"Stage metadata for character selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted character\n+\n+\n+class AbilitySelectMeta(StrictModel):\n+    \"\"\"Stage metadata for ability selection stage\"\"\"\n+\n+    selected: str  # Currently highlighted ability\n+\n+\n+class ActivePlayer1(StrictModel):\n+    \"\"\"Selected character for battle\"\"\"\n+\n+    player: str  # Character name\n+\n+\n+class BattleResult(StrictModel):\n+    winner: bool\n+    score: int  # result of the battle, sum of dice_roll and attack\n+\n+\n+class ActivePlayer2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class ActivePlayer3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class ActivePlayer4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n+\n+\n+class Opponent2(StrictModel):\n+    player: str\n+    character: str\n+\n+\n+class Opponent3(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+\n+\n+class Opponent4(StrictModel):\n+    player: str\n+    character: str\n+    dice_roll: list[int]\n+    result: BattleResult\n+\n+\n+Opponent = Opponent2 | Opponent3 | Opponent4\n+\n+\n+class Player(StrictModel):\n+    name: str\n+    status: ConnectionStatus = CONNECTED\n+    cards: list[str] = Field(default_factory=list)\n+    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n+\n+\n+########################################################\n+# GamePlay model\n+########################################################\n+class GamePlay(StrictModel):\n+    stage: StageName = CHARACTER_SELECT\n+    players: dict[str, Player] = Field(default_factory=dict)\n+    active: Optional[ActivePlayer] = None  # The active player and its selections\n+    ability: Optional[Ability] = None  # Selected ability\n+    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n+    opponent: Optional[Opponent] = None  # Selected opponent for battle\n+    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n+\n+    def reorder_players(self, username: str):\n+        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n+        if username not in self.players:\n+            return\n+\n+        # Get all player keys\n+        player_keys = list(self.players.keys())\n+\n+        # Find the index of the username\n+        user_index = player_keys.index(username)\n+\n+        # Circular shift: username first, then the rest\n+        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n+\n+        # Build new dict with reordered keys\n+        reordered_dict = {key: self.players[key] for key in reordered_keys}\n+\n+        # Update in-place\n+        self.players.clear()\n+        self.players.update(reordered_dict)\n+\n+\n+DEFAULT_GAME = GamePlay()\n+\n+KNIGHT_L1_DEFAULT_HEALTH = 2\n+KNIGHT_L1_MAX_HEALTH = 2\n+KNIGHT_L1_DICE = 1\n+KNIGHT_L1_ATTACK = 1\n+KNIGHT_L1_ABILITY = BATTLE_HOWL\n+\n+ARCHER_L1_DEFAULT_HEALTH = 3\n+ARCHER_L1_MAX_HEALTH = 3\n+ARCHER_L1_DICE = 1\n+ARCHER_L1_ATTACK = 0\n+ARCHER_L1_ABILITY = BOUNCING_ARROW\n+\n+MAGE_L1_DEFAULT_HEALTH = 2\n+MAGE_L1_MAX_HEALTH = 2\n+MAGE_L1_DICE = 1\n+MAGE_L1_ATTACK = 0\n+MAGE_L1_ABILITY = FREEZE\n+\n+def get_character_default_stats() -> dict:\n+    \"\"\"Get character default stats with abilities. Uses lazy import to avoid circular dependency.\"\"\"\n+    from .abilities import ABILITIES_MAP\n+\n+    return {\n+        \"knight\": {\n+            \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n+            \"max_health\": KNIGHT_L1_MAX_HEALTH,\n+            \"dice\": KNIGHT_L1_DICE,\n+            \"attack\": KNIGHT_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n+        },\n+        \"archer\": {\n+            \"health\": ARCHER_L1_DEFAULT_HEALTH,\n+            \"max_health\": ARCHER_L1_MAX_HEALTH,\n+            \"dice\": ARCHER_L1_DICE,\n+            \"attack\": ARCHER_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n+        },\n+        \"mage\": {\n+            \"health\": MAGE_L1_DEFAULT_HEALTH,\n+            \"max_health\": MAGE_L1_MAX_HEALTH,\n+            \"dice\": MAGE_L1_DICE,\n+            \"attack\": MAGE_L1_ATTACK,\n+            \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n+        },\n+    }\n+\n+\n+# Lazy-evaluated CHARACTER_DEFAULT_STATS for backwards compatibility\n+_CHARACTER_DEFAULT_STATS = None\n+\n+\n+def _get_cached_character_default_stats():\n+    global _CHARACTER_DEFAULT_STATS\n+    if _CHARACTER_DEFAULT_STATS is None:\n+        _CHARACTER_DEFAULT_STATS = get_character_default_stats()\n+    return _CHARACTER_DEFAULT_STATS\n+\n+\n+# Property-like access for CHARACTER_DEFAULT_STATS\n+class _CharacterDefaultStatsProxy:\n+    def __getitem__(self, key):\n+        return _get_cached_character_default_stats()[key]\n+\n+    def __iter__(self):\n+        return iter(_get_cached_character_default_stats())\n+\n+    def items(self):\n+        return _get_cached_character_default_stats().items()\n+\n+    def keys(self):\n+        return _get_cached_character_default_stats().keys()\n+\n+    def values(self):\n+        return _get_cached_character_default_stats().values()\n+\n+\n+CHARACTER_DEFAULT_STATS = _CharacterDefaultStatsProxy()\n+\n+\n+def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n+    \"\"\"Initialize all character types with default stats\"\"\"\n+    stats = get_character_default_stats()\n+    return {\n+        char_type: Character(level=level, **stats[char_type])\n+        for char_type in [KNIGHT, ARCHER, MAGE]\n+    }\ndiff --git a/server/gameplay/models.py b/server/gameplay/models.py\nindex d8a1106..7aa309e 100644\n--- a/server/gameplay/models.py\n+++ b/server/gameplay/models.py\n@@ -1,96 +1,69 @@\n-from typing import Dict, Optional, Literal, Annotated, Union, Self\n-\n-from pydantic import BaseModel, ConfigDict, Field, computed_field, Discriminator, model_validator\n-\n-########################################################\n-# Connection statuses\n-########################################################\n-CONNECTED = \"connected\"\n-DISCONNECTED = \"disconnected\"\n-CONNECTION_STATUSES = [CONNECTED, DISCONNECTED]\n-ConnectionStatus = Literal[*CONNECTION_STATUSES]\n-\n-########################################################\n-# Stages\n-########################################################\n-CHARACTER_SELECT = \"character_select\"\n-ABILITY_SELECTION = \"ability_selection\"\n-ABILITY_OPPONENT_SELECTION = \"ability_opponent_selection\"\n-OPPONENT_SELECTION = \"opponent_selection\"\n-BATTLE_DICE_ROLL = \"battle_dice_roll\"\n-BATTLE_END = \"battle_end\"\n-STAGES_NAMES = [\n+\"\"\"\n+Backwards compatibility - re-exports from split modules.\n+Import directly from effects, abilities, or gameplay for new code.\n+\"\"\"\n+\n+# Re-export from effects\n+from .effects import (\n+    Effect,\n+    SkipTurnEffect,\n+    AttackBonusEffect,\n+    RerollDiceEffect,\n+    AttackNegBonusEffect,\n+    DrawCardEffect,\n+    EffectUnion,\n+    EffectTotal,\n+)\n+\n+# Re-export from abilities\n+from .abilities import (\n+    Ability,\n+    ABILITIES_MAP,\n+)\n+\n+# Re-export from gameplay (everything else)\n+from .gameplay import (\n+    # Connection statuses\n+    CONNECTED,\n+    DISCONNECTED,\n+    CONNECTION_STATUSES,\n+    ConnectionStatus,\n+    # Stages\n     CHARACTER_SELECT,\n     ABILITY_SELECTION,\n     ABILITY_OPPONENT_SELECTION,\n     OPPONENT_SELECTION,\n     BATTLE_DICE_ROLL,\n     BATTLE_END,\n-]\n-StageName = Literal[*STAGES_NAMES]\n-\n-########################################################\n-# Character types\n-########################################################\n-KNIGHT = \"knight\"\n-ARCHER = \"archer\"\n-MAGE = \"mage\"\n-CHARACTER_TYPES = [KNIGHT, ARCHER, MAGE]\n-ChatacterType = Literal[*CHARACTER_TYPES]\n-\n-BATTLE_HOWL = \"battle_howl\"\n-BOUNCING_ARROW = \"bouncing_arrow\"\n-FREEZE = \"freeze\"\n-ABILITIES_NAMES: list[str] = [BATTLE_HOWL, BOUNCING_ARROW, FREEZE]\n-AbilityName = Literal[*ABILITIES_NAMES]\n-\n-# Effect names\n-ATTACK_BONUS = \"attack_bonus\"\n-ATTACK_NEG_BONUS = \"attack_neg_bonus\"\n-REROLL_DICE = \"reroll_dice\"\n-SKIP_TURN = \"skip_turn\"\n-DRAW_CARD = \"draw_card\"\n-\n-# Effect apply_to targets - specifies who receives the effect\n-APPLY_TO_SELF = \"self\"  # Applied to active player's character when ability is selected\n-APPLY_TO_BATTLE_OPPONENT = \"battle_opponent\"  # Applied to opponent when battle starts\n-APPLY_TO_SELECTED_OPPONENT = \"selected_opponent\"  # Requires ability_opponent_selection stage\n-\n-APPLY_TO_TARGETS = [APPLY_TO_SELF, APPLY_TO_BATTLE_OPPONENT, APPLY_TO_SELECTED_OPPONENT]\n-ApplyToTarget = Literal[*APPLY_TO_TARGETS]\n-\n-# Effect-to-Source mapping: defines which abilities can create which effects\n-# This is used for validation to ensure effects have valid source abilities\n-EFFECTS_SOURCE_ABILITY_MAP: dict[str, set[str]] = {\n-    ATTACK_BONUS: {BATTLE_HOWL},  # AttackBonusEffect can come from BATTLE_HOWL\n-    ATTACK_NEG_BONUS: set(),  # AttackNegBonusEffect - TBD: add abilities that grant attack penalty\n-    REROLL_DICE: {BOUNCING_ARROW},  # RerollDiceEffect can come from BOUNCING_ARROW\n-    SKIP_TURN: {FREEZE},  # SkipTurnEffect can come from FREEZE\n-    DRAW_CARD: set(),  # DrawCardEffect - TBD: add abilities that grant card draw\n-}\n-\n-########################################################\n-# Actions\n-########################################################\n-CONNECT = \"connect\"\n-LEAVE = \"leave\"\n-DISCONNECT = \"disconnect\"\n-CHARACTER_PRESS = \"character_press\"\n-CHARACTER_SELECT_ACTION = \"character_select\"\n-ABILITY_PRESS = \"ability_press\"\n-ABILITY_SELECT = \"ability_select\"\n-ABILITY_OPPONENT_PRESS = \"ability_opponent_press\"\n-ABILITY_OPPONENT_SELECT = \"ability_opponent_select\"\n-OPPONENT_PRESS = \"opponent_press\"\n-OPPONENT_SELECT = \"opponent_select\"\n-ACTIVE_PLAYER_ROLL = \"active_player_roll\"\n-OPPONENT_ROLL = \"opponent_roll\"\n-ACTION_REROLL = \"action_reroll\"\n-ACTION_REROLL_EFFECT = \"action_reroll_effect\"\n-BATTLE_END_ACTION = \"battle_end\"\n-DEBUG_SET_BATTLE_DICE_ROLLS = \"debug_set_battle_dice_rolls\"\n-\n-ACTION_NAMES = [\n+    STAGES_NAMES,\n+    StageName,\n+    # Character types\n+    KNIGHT,\n+    ARCHER,\n+    MAGE,\n+    CHARACTER_TYPES,\n+    ChatacterType,\n+    # Ability names\n+    BATTLE_HOWL,\n+    BOUNCING_ARROW,\n+    FREEZE,\n+    ABILITIES_NAMES,\n+    AbilityName,\n+    # Effect names\n+    ATTACK_BONUS,\n+    ATTACK_NEG_BONUS,\n+    REROLL_DICE,\n+    SKIP_TURN,\n+    DRAW_CARD,\n+    # Apply to targets\n+    APPLY_TO_SELF,\n+    APPLY_TO_BATTLE_OPPONENT,\n+    APPLY_TO_SELECTED_OPPONENT,\n+    APPLY_TO_TARGETS,\n+    ApplyToTarget,\n+    # Effect source map\n+    EFFECTS_SOURCE_ABILITY_MAP,\n+    # Actions\n     CONNECT,\n     LEAVE,\n     DISCONNECT,\n@@ -108,405 +81,47 @@ ACTION_NAMES = [\n     ACTION_REROLL_EFFECT,\n     BATTLE_END_ACTION,\n     DEBUG_SET_BATTLE_DICE_ROLLS,\n-]\n-ActionName = Literal[*ACTION_NAMES]\n-\n-\n-class GameException(Exception):\n-    pass\n-\n-\n-class ReportedException(GameException):\n-    pass\n-\n-\n-def recursive_db_model_dump(model: BaseModel) -> dict:\n-    \"\"\"\n-    Recursively dump model for database storage.\n-    Calls db_model_dump() on all nested StrictModel instances to exclude computed fields.\n-    \"\"\"\n-    result = {}\n-\n-    # Iterate over all fields and their values\n-    for field_name, field_value in model:\n-        if isinstance(field_value, BaseModel):\n-            # Nested model - call its db_model_dump if it's a StrictModel\n-            if hasattr(field_value, \"db_model_dump\"):\n-                result[field_name] = field_value.db_model_dump()\n-            else:\n-                result[field_name] = field_value.model_dump()\n-        elif isinstance(field_value, dict):\n-            # Dict of values (possibly models)\n-            result[field_name] = {\n-                k: (\n-                    v.db_model_dump()\n-                    if isinstance(v, BaseModel) and hasattr(v, \"db_model_dump\")\n-                    else v.model_dump() if isinstance(v, BaseModel) else v\n-                )\n-                for k, v in field_value.items()\n-            }\n-        elif isinstance(field_value, (list, tuple, set)):\n-            # Collection of values (possibly models) - preserve collection type\n-            processed_items = [\n-                (\n-                    item.db_model_dump()\n-                    if isinstance(item, BaseModel) and hasattr(item, \"db_model_dump\")\n-                    else item.model_dump() if isinstance(item, BaseModel) else item\n-                )\n-                for item in field_value\n-            ]\n-            # Preserve the original collection type\n-            result[field_name] = type(field_value)(processed_items)\n-        else:\n-            # Primitive value\n-            result[field_name] = field_value\n-\n-    return result\n-\n-\n-class StrictModel(BaseModel):\n-    model_config = ConfigDict(extra=\"forbid\")\n-\n-    def db_model_dump(self) -> dict:\n-        \"\"\"Recursively use self.db_model_dump() on all nested models using recursive_model_dump()\"\"\"\n-        return recursive_db_model_dump(self)\n-\n-\n-class Effect(StrictModel):\n-    \"\"\"\n-    Base class for all effects.\n-    Each effect specifies when it should be disposed via dispose_actions field.\n-    Each effect specifies who receives the effect via apply_to field.\n-    \"\"\"\n-\n-    name: Literal[\"effect\"] = \"effect\"  # Discriminator field for polymorphic serialization\n-    source: AbilityName\n-    dispose_actions: list[ActionName]  # Action names when this effect should be disposed\n-    apply_to: ApplyToTarget  # Who receives this effect\n-\n-    @model_validator(mode=\"after\")\n-    def validate_source(self) -> Self:\n-        \"\"\"Validate that source is valid for this effect type\"\"\"\n-        valid_sources = EFFECTS_SOURCE_ABILITY_MAP.get(self.name, set())\n-        if self.source not in valid_sources and len(valid_sources) > 0:\n-            raise ValueError(\n-                f\"Invalid source '{self.source}' for {self.__class__.__name__}. \"\n-                f\"Valid sources: {valid_sources}\"\n-            )\n-        return self\n-\n-\n-class SkipTurnEffect(Effect):\n-    \"\"\"\n-    Character can't participate in the next turn.\n-    Disposed after character selection.\n-    Applied to selected opponent (requires ability_opponent_selection stage).\n-    \"\"\"\n-\n-    name: Literal[SKIP_TURN] = SKIP_TURN\n-    dispose_actions: list[ActionName] = [CHARACTER_SELECT_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELECTED_OPPONENT\n-    skip_next_turn: bool = True\n-\n-\n-class AttackBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is increased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_BONUS] = ATTACK_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    attack_bonus: int\n-\n-\n-class RerollDiceEffect(Effect):\n-    \"\"\"\n-    Character's dice are rerolled if lost the battle.\n-    Disposed at battle end or when the reroll effect action is used.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[REROLL_DICE] = REROLL_DICE\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION, ACTION_REROLL_EFFECT]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    reroll_dice: bool = True\n-\n-\n-class AttackNegBonusEffect(Effect):\n-    \"\"\"\n-    Character's attack is decreased by the value of the effect.\n-    Disposed at battle end.\n-    Applied to battle opponent (no separate selection required).\n-    \"\"\"\n-\n-    name: Literal[ATTACK_NEG_BONUS] = ATTACK_NEG_BONUS\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_BATTLE_OPPONENT\n-    attack_neg_bonus: int\n-\n-\n-class DrawCardEffect(Effect):\n-    \"\"\"\n-    Character draws cards at the start of battle.\n-    Disposed at battle end.\n-    Applied to self (active player's character).\n-    \"\"\"\n-\n-    name: Literal[DRAW_CARD] = DRAW_CARD\n-    dispose_actions: list[ActionName] = [BATTLE_END_ACTION]\n-    apply_to: ApplyToTarget = APPLY_TO_SELF\n-    draw_count: int = 1\n-\n-\n-# Define EffectUnion for discriminated union of all effect types (without base classes)\n-EffectUnion = Annotated[\n-    Union[AttackBonusEffect, AttackNegBonusEffect, RerollDiceEffect, SkipTurnEffect, DrawCardEffect],\n-    Field(discriminator=\"name\"),\n-]\n-\n-\n-class Ability(StrictModel):\n-    name: str\n-    effects: list[EffectUnion] = Field(default_factory=list)  # effects that are applied when the ability is used\n-\n-    @property\n-    def requires_opponent_selection(self) -> bool:\n-        \"\"\"Check if any effect requires opponent selection (via ability_opponent_selection stage)\"\"\"\n-        return any(effect.apply_to == APPLY_TO_SELECTED_OPPONENT for effect in self.effects)\n-\n-\n-class EffectTotal(StrictModel):\n-    \"\"\"\n-    Aggregated effect totals for a character.\n-    Combines all active effects into a single summary.\n-    \"\"\"\n-\n-    attack_bonus: int = 0\n-    attack_neg_bonus: int = 0\n-    skip_next_turn: bool = False\n-    reroll_dice_available: bool = False\n-    draw_card_count: int = 0\n-\n-\n-ABILITIES_MAP: dict[AbilityName, Ability] = {\n-    BATTLE_HOWL: Ability(\n-        name=BATTLE_HOWL,\n-        effects=[\n-            AttackBonusEffect(source=BATTLE_HOWL, attack_bonus=2),\n-        ],\n-    ),\n-    BOUNCING_ARROW: Ability(\n-        name=BOUNCING_ARROW,\n-        effects=[\n-            RerollDiceEffect(source=BOUNCING_ARROW),\n-        ],\n-    ),\n-    FREEZE: Ability(\n-        name=FREEZE,\n-        effects=[\n-            SkipTurnEffect(source=FREEZE),\n-        ],\n-    ),\n-}\n-\n-\n-class Character(StrictModel):\n-\n-    level: int\n-    health: int\n-    max_health: int\n-    dice: int\n-    attack: int\n-    abilities: list[Ability] = Field(default_factory=list)\n-    effects: list[EffectUnion] = Field(default_factory=list)\n-\n-    @computed_field\n-    @property\n-    def is_alive(self) -> bool:\n-        \"\"\"Character is alive if health > 0\"\"\"\n-        return self.health > 0\n-\n-    @computed_field\n-    @property\n-    def effect(self) -> EffectTotal:\n-        \"\"\"Aggregate all active effects into a single EffectTotal\"\"\"\n-        total = EffectTotal()\n-\n-        for eff in self.effects:\n-            if isinstance(eff, AttackBonusEffect):\n-                total.attack_bonus += eff.attack_bonus\n-            elif isinstance(eff, AttackNegBonusEffect):\n-                total.attack_neg_bonus += eff.attack_neg_bonus\n-            elif isinstance(eff, SkipTurnEffect):\n-                total.skip_next_turn = total.skip_next_turn or eff.skip_next_turn\n-            elif isinstance(eff, RerollDiceEffect):\n-                total.reroll_dice_available = True\n-            elif isinstance(eff, DrawCardEffect):\n-                total.draw_card_count += eff.draw_count\n-\n-        return total\n-\n-    def db_model_dump(self) -> dict:\n-        return self.model_dump(exclude={\"is_alive\", \"effect\"})\n-\n-\n-class CharacterSelectMeta(StrictModel):\n-    \"\"\"Stage metadata for character selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted character\n-\n-\n-class AbilitySelectMeta(StrictModel):\n-    \"\"\"Stage metadata for ability selection stage\"\"\"\n-\n-    selected: str  # Currently highlighted ability\n-\n-\n-class ActivePlayer1(StrictModel):\n-    \"\"\"Selected character for battle\"\"\"\n-\n-    player: str  # Character name\n-\n-\n-class BattleResult(StrictModel):\n-    winner: bool\n-    score: int  # result of the battle, sum of dice_roll and attack\n-\n-\n-class ActivePlayer2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class ActivePlayer3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class ActivePlayer4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-ActivePlayer = ActivePlayer1 | ActivePlayer2 | ActivePlayer3 | ActivePlayer4\n-\n-\n-class Opponent2(StrictModel):\n-    player: str\n-    character: str\n-\n-\n-class Opponent3(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-\n-\n-class Opponent4(StrictModel):\n-    player: str\n-    character: str\n-    dice_roll: list[int]\n-    result: BattleResult\n-\n-\n-Opponent = Opponent2 | Opponent3 | Opponent4\n-\n-\n-class Player(StrictModel):\n-    name: str\n-    status: ConnectionStatus = CONNECTED\n-    cards: list[str] = Field(default_factory=list)\n-    characters: Dict[ChatacterType, Character] = Field(default_factory=dict)\n-\n-\n-########################################################\n-# GamePlay model\n-########################################################\n-class GamePlay(StrictModel):\n-    stage: StageName = CHARACTER_SELECT\n-    players: dict[str, Player] = Field(default_factory=dict)\n-    active: Optional[ActivePlayer] = None  # The active player and its selections\n-    ability: Optional[Ability] = None  # Selected ability\n-    ability_opponent: Optional[Opponent2] = None  # Selected ability opponent\n-    opponent: Optional[Opponent] = None  # Selected opponent for battle\n-    stage_meta: Optional[Ability | CharacterSelectMeta | AbilitySelectMeta | Opponent2] = None  # Temporary stage-specific metadata\n-\n-    def reorder_players(self, username: str):\n-        \"\"\"Reorder players dict in-place with username first (circular shift)\"\"\"\n-        if username not in self.players:\n-            return\n-\n-        # Get all player keys\n-        player_keys = list(self.players.keys())\n-\n-        # Find the index of the username\n-        user_index = player_keys.index(username)\n-\n-        # Circular shift: username first, then the rest\n-        reordered_keys = player_keys[user_index:] + player_keys[:user_index]\n-\n-        # Build new dict with reordered keys\n-        reordered_dict = {key: self.players[key] for key in reordered_keys}\n-\n-        # Update in-place\n-        self.players.clear()\n-        self.players.update(reordered_dict)\n-\n-\n-DEFAULT_GAME = GamePlay()\n-\n-KNIGHT_L1_DEFAULT_HEALTH = 2\n-KNIGHT_L1_MAX_HEALTH = 2\n-KNIGHT_L1_DICE = 1\n-KNIGHT_L1_ATTACK = 1\n-KNIGHT_L1_ABILITY = BATTLE_HOWL\n-\n-ARCHER_L1_DEFAULT_HEALTH = 3\n-ARCHER_L1_MAX_HEALTH = 3\n-ARCHER_L1_DICE = 1\n-ARCHER_L1_ATTACK = 0\n-ARCHER_L1_ABILITY = BOUNCING_ARROW\n-\n-MAGE_L1_DEFAULT_HEALTH = 2\n-MAGE_L1_MAX_HEALTH = 2\n-MAGE_L1_DICE = 1\n-MAGE_L1_ATTACK = 0\n-MAGE_L1_ABILITY = FREEZE\n-\n-CHARACTER_DEFAULT_STATS = {\n-    \"knight\": {\n-        \"health\": KNIGHT_L1_DEFAULT_HEALTH,\n-        \"max_health\": KNIGHT_L1_MAX_HEALTH,\n-        \"dice\": KNIGHT_L1_DICE,\n-        \"attack\": KNIGHT_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[KNIGHT_L1_ABILITY]],\n-    },\n-    \"archer\": {\n-        \"health\": ARCHER_L1_DEFAULT_HEALTH,\n-        \"max_health\": ARCHER_L1_MAX_HEALTH,\n-        \"dice\": ARCHER_L1_DICE,\n-        \"attack\": ARCHER_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[ARCHER_L1_ABILITY]],\n-    },\n-    \"mage\": {\n-        \"health\": MAGE_L1_DEFAULT_HEALTH,\n-        \"max_health\": MAGE_L1_MAX_HEALTH,\n-        \"dice\": MAGE_L1_DICE,\n-        \"attack\": MAGE_L1_ATTACK,\n-        \"abilities\": [ABILITIES_MAP[MAGE_L1_ABILITY]],\n-    },\n-}\n-\n-\n-def init_characters(level: int = 1) -> Dict[ChatacterType, Character]:\n-    \"\"\"Initialize all character types with default stats\"\"\"\n-    return {\n-        char_type: Character(level=level, **CHARACTER_DEFAULT_STATS[char_type])\n-        for char_type in [KNIGHT, ARCHER, MAGE]\n-    }\n+    ACTION_NAMES,\n+    ActionName,\n+    # Exceptions\n+    GameException,\n+    ReportedException,\n+    # Utilities\n+    recursive_db_model_dump,\n+    StrictModel,\n+    # Character and game models\n+    Character,\n+    CharacterSelectMeta,\n+    AbilitySelectMeta,\n+    ActivePlayer1,\n+    BattleResult,\n+    ActivePlayer2,\n+    ActivePlayer3,\n+    ActivePlayer4,\n+    ActivePlayer,\n+    Opponent2,\n+    Opponent3,\n+    Opponent4,\n+    Opponent,\n+    Player,\n+    GamePlay,\n+    DEFAULT_GAME,\n+    # Character default stats\n+    KNIGHT_L1_DEFAULT_HEALTH,\n+    KNIGHT_L1_MAX_HEALTH,\n+    KNIGHT_L1_DICE,\n+    KNIGHT_L1_ATTACK,\n+    KNIGHT_L1_ABILITY,\n+    ARCHER_L1_DEFAULT_HEALTH,\n+    ARCHER_L1_MAX_HEALTH,\n+    ARCHER_L1_DICE,\n+    ARCHER_L1_ATTACK,\n+    ARCHER_L1_ABILITY,\n+    MAGE_L1_DEFAULT_HEALTH,\n+    MAGE_L1_MAX_HEALTH,\n+    MAGE_L1_DICE,\n+    MAGE_L1_ATTACK,\n+    MAGE_L1_ABILITY,\n+    CHARACTER_DEFAULT_STATS,\n+    init_characters,\n+)"
        },
        "id": "mobile-landscape",
        "name": "mobile-landscape",
        "testDir": "/home/runner/work/heroes-of-talisman/heroes-of-talisman/e2e",
        "testIgnore": [],
        "testMatch": [
          "**/*.@(spec|test).?(c|m)[jt]s?(x)"
        ],
        "timeout": 30000
      }
    ],
    "shard": null,
    "updateSnapshots": "missing",
    "updateSourceMethod": "patch",
    "version": "1.55.1",
    "workers": 1,
    "webServer": null
  },
  "suites": [],
  "errors": [
    {
      "message": "Error: Process from config.webServer was not able to start. Exit code: 1",
      "stack": "Error: Process from config.webServer was not able to start. Exit code: 1"
    }
  ],
  "stats": {
    "startTime": "2026-01-18T11:01:39.020Z",
    "duration": 4315.457,
    "expected": 0,
    "skipped": 0,
    "unexpected": 0,
    "flaky": 0
  }
}